{
    "Slug": "an-end-to-end-prototype-of-aes-encryption-with-acs-authentication-and-acs-token-authorization",
    "Title": "ACS 認証と ACS トークン承認を使用した AES 暗号化のエンド ツー エンド プロトタイプ",
    "Summary": "This is a “sequel” to the author’s previous post An End-to-End Prototype of PlayReady Protection with ACS Authentication and ACS Token Authorization.",
    "Content": "<h1>はじめに</h1>\nこれは、 <a href=\"https://azure.microsoft.com/blog/2014/11/17/an-end-to-end-prototype-of-playready-protection-with-acs-authentication-and-acs-token-authorization/\" target=\"_blank\">ACS 認証と ACS トークン承認を使用した PlayReady Protection のエンド ツー エンドプロトタイプの著者の以前の</a>投稿の「続編」です。\n\n場合によっては、完全な DRM 保護が義務付けられたり、経済的に理にかなっていない場合があります。 代わりに、AES 暗号化を使用することもできます。 ただし、AES 暗号化は DRM とは大きく異なり、DRM ではないことに注意してください。 DRM と AES 暗号化の違いを次の表にまとめます。\n<table border=\"0\" width=\"599\" cellspacing=\"0\" cellpadding=\"1\">\n<tbody>\n<tr>\n<td valign=\"top\" width=\"215\"><strong>比較</strong></td>\n<td valign=\"top\" width=\"188\"><strong>PlayReady などの DRM</strong></td>\n<td valign=\"top\" width=\"194\"><strong>AES-128 などの暗号化</strong></td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">コンテンツの保護とファイルの保護</td>\n<td valign=\"top\" width=\"188\">コンテンツ</td>\n<td valign=\"top\" width=\"194\">コンテンツ</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">承認されたユーザーは信頼されていますか?</td>\n<td valign=\"top\" width=\"188\">いいえ。承認済みユーザーが保護されたコンテンツでできることは、DRM ライセンスに含まれる制限と権利によって制限されます。</td>\n<td valign=\"top\" width=\"194\">はい。承認されたユーザーは、コンテンツ (コピー、保存、共有、および/またはすべてのディスプレイ デバイスへのエクスポート) で何でも実行できます</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">保護するコンテンツの性質</td>\n<td valign=\"top\" width=\"188\">動画などの共有の関心事のコンテンツに適用</td>\n<td valign=\"top\" width=\"194\">個人のコンテンツに適用され、ユーザーは共有しないことを信頼されます。</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">クライアント デバイスで暗号化を解除した後、コンテンツは保護されますか?</td>\n<td valign=\"top\" width=\"188\">はい</td>\n<td valign=\"top\" width=\"194\">いいえ</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">コンテンツ アクセスは日付/時刻によって制限できますか?</td>\n<td valign=\"top\" width=\"188\">はい</td>\n<td valign=\"top\" width=\"194\">いいえ</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">アプリケーションのホワイトリスト登録</td>\n<td valign=\"top\" width=\"188\">はい</td>\n<td valign=\"top\" width=\"194\">いいえ</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">ドメインのバインドと管理</td>\n<td valign=\"top\" width=\"188\">はい</td>\n<td valign=\"top\" width=\"194\">いいえ</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">暗号化キーのローテーション</td>\n<td valign=\"top\" width=\"188\">はい</td>\n<td valign=\"top\" width=\"194\">いいえ</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">停電</td>\n<td valign=\"top\" width=\"188\">はい</td>\n<td valign=\"top\" width=\"194\">いいえ</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">出力保護</td>\n<td valign=\"top\" width=\"188\">はい</td>\n<td valign=\"top\" width=\"194\">いいえ</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">ライセンス チェーン</td>\n<td valign=\"top\" width=\"188\">はい</td>\n<td valign=\"top\" width=\"194\">いいえ</td>\n</tr>\n</tbody>\n</table>\n<a href=\"https://azure.microsoft.com/blog/2014/09/10/announcing-public-availability-of-azure-media-services-content-protection-services/\">Azure Media Servicesコンテンツ保護</a>は、動的な AES 暗号化機能により、\"1 クリック\" AES 暗号化を実現します。\n\nこのブログでは、トークン承認を使用したスムーズ ストリーミング資産の AES 暗号化のエンド ツー エンドのプロトタイプを紹介します。 承認トークンは、PlayReady 保護のエンド ツー エンド プロトタイプで使用されるのと同じ ACS 2.0 名前空間によって発行されます。\n\n&nbsp;\n<h1>エンドツーエンドのプロトタイプ</h1>\n<h2>設計と機能</h2>\nこの取り組みの目的は、以下をカバーするエンドツーエンドのプロトタイプを提供することにある。\n<ul>\n <li>AMS 内の資産に対するトークン制限を使用した AES-128 動的暗号化。</li>\n <li>Azure Media Services暗号化解除キーを配信するためのキー配信サービス。</li>\n <li>SWT 承認トークンを発行するための STS としての <a href=\"https://msdn.microsoft.com/en-us/library/azure/hh147631.aspx\">Azure ACS</a> (Microsoft Azure Active Directory Access Control)。</li>\n <li>OSMF プレーヤー\n<ol>\n <li>ACS サービス ID によって認証されます。</li>\n <li>ACS から承認トークンを取得します。</li>\n <li>は、ACS トークンを使用して AMS キー配信サービスから復号化キーを取得し、</li>\n <li>復号化とビデオ再生。</li>\n</ol>\n</li>\n</ul>\nこのエンドツーエンドのプロトタイプの設計を次の図に示します。\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/11/19/Blog_Secure_Delivery_AES.jpg\"><img style=\"padding-top: 0px; padding-left: 0px; padding-right: 0px; border-width: 0px;\" title=\"Blog_Secure_Delivery_AES\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/Blog_Secure_Delivery_AES_thumb.jpg\" alt=\"Blog_Secure_Delivery_AES\" width=\"631\" height=\"469\" border=\"0\"></a>\n\n&nbsp;\n\nエンド ツー エンドのプロトタイプは、Azure とAzure Media Servicesでホストされます。 プロトタイプに関連する情報を次に示します。\n<ul>\n <li>AES 動的暗号化の下でのスムーズ ストリーミング資産の URL。</li>\n <li><a href=\"https://willzhanmediaservice.keydelivery.mediaservices.windows.net/?KID=1814f449-0550-4977-abd5-fe3efeaf6086\" target=\"_blank\">キー配信 URL</a>。</li>\n <li><a href=\"https://willzhanacs.accesscontrol.windows.net/\">SWT 承認トークンを発行する Azure ACS 名前空間の URL</a>。</li>\n <li>OSMF プレーヤーの URL。</li>\n</ul>\n&nbsp;\n<h2>実行方法</h2>\n<ol>\n <li><a href=\"https://azure.microsoft.com/blog/2014/10/27/microsoft-adaptive-streaming-plugin-for-osmf-update/\">OSMF 用アダプティブ ストリーミング プラグイン</a>を使用して構築された OSMF プレーヤーを参照します。 必要な情報は、プレイヤー ページ UI に既にあります。</li>\n <li>[再生] ボタンをクリックするたびに ACS からの新しい承認トークンが要求され、新しい承認トークンが OSMF プラグインによって使用され、再生用の復号化キーが要求されます。 ACS 2.0 名前空間からの承認トークンがプレーヤー ページに表示されます。 プレーヤーのスクリーンショットを次に示します。</li>\n</ol>\n<blockquote><a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/11/19/OMFPlayer.jpg\"><img style=\"padding-top: 0px; padding-left: 0px; padding-right: 0px; border-width: 0px;\" title=\"OMFPlayer\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/OMFPlayer_thumb.jpg\" alt=\"OMFPlayer\" width=\"631\" height=\"341\" border=\"0\"></a></blockquote>\n&nbsp;\n<h1>実装</h1>\n実装には、次のものが含まれます。\n<ol>\n <li>.NET API を使用してスムーズ ストリーミング資産用に動的 AES-128 暗号化Azure Media Services構成する。\n<ul>\n <li>コンテンツ キー ID とコンテンツ キーを生成する。</li>\n <li>暗号化解除キー配信サービスを構成する。</li>\n <li>資産配信ポリシーを使用して動的 AES 暗号化を構成する。</li>\n <li>資産を発行します。</li>\n</ul>\n</li>\n <li>プレイヤー クライアントを認証し、承認トークンを発行するように Azure ACS 2.0 名前空間を設定します。</li>\n <li>ACS 認証、承認トークン要求、復号化キー要求、ビデオ再生を処理する OSMF プレーヤーを開発します。</li>\n</ol>\nMICROSOFT <a href=\"https://azure.microsoft.com/blog/2014/10/27/microsoft-adaptive-streaming-plugin-for-osmf-update/\">Adaptive Streaming Plugin for OSMF</a> ではオンデマンドとライブの両方でスムーズ ストリーミング コンテンツの AES 暗号化がサポートされているため、このプロトタイプには OSMF プレーヤーを使用することを選択しました。\n\n&nbsp;\n<h2>動的 AES 暗号化の構成</h2>\n最初の手順では、封筒の種類のコンテンツ キーを作成します。 コードは次のとおりです。\n<div align=\"left\">\n<pre class=\"prettyprint\">static public IContentKey CreateEnvelopeTypeContentKey(CloudMediaContext objCloudMediaContext)\n{\n    // Create envelope encryption content key\n    Guid keyId = Guid.NewGuid();\n    byte[] contentKey = CryptoUtils.GenerateCryptographicallyStrongRandomBytes(16);\n\n    IContentKey objIContentKey = objCloudMediaContext.ContentKeys.Create(keyId, contentKey, \"myContentKey\", ContentKeyType.EnvelopeEncryption);\n\n    return objIContentKey;\n}</pre>\n</div>\n次に、承認ポリシーを作成し、上記で作成したコンテンツ キーに追加します。 <a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2331/8475.Blog_5F00_Secure_5F00_Delivery_5F00_API.jpg\" target=\"_blank\">この図</a>に示すように、各 IContentKey には IContentKeyAuthorizationPolicy の 1 つのインスタンスがあります。 次のコードでは、IContentKeyAuthorizationPolicy を作成し、IContentKey にアタッチします。\n<pre class=\"prettyprint\">public static IContentKey AddAuthorizationPolicyToContentKey(CloudMediaContext objCloudMediaContext, IContentKey objIContentKey)\n{\n    // Create ContentKeyAuthorizationPolicy with restrictions and create authorization policy             \n    IContentKeyAuthorizationPolicy policy = objCloudMediaContext.ContentKeyAuthorizationPolicies.CreateAsync(\"Open Authorization Policy\").Result;\n\n    List&lt;ContentKeyAuthorizationPolicyRestriction&gt; restrictions = new List&lt;ContentKeyAuthorizationPolicyRestriction&gt;();\n\n    ContentKeyAuthorizationPolicyRestriction restriction = new ContentKeyAuthorizationPolicyRestriction\n    {\n        Name = \"Authorization Policy with Token Restriction\",\n        KeyRestrictionType = (int)ContentKeyRestrictionType.TokenRestricted,\n        Requirements = ContentKeyAuthorizationHelper.CreateRestrictionRequirements()\n    };\n\n    restrictions.Add(restriction);\n\n    IContentKeyAuthorizationPolicyOption policyOption = objCloudMediaContext.ContentKeyAuthorizationPolicyOptions.Create(\"myDynamicEncryptionPolicy\", ContentKeyDeliveryType.BaselineHttp, restrictions, \"\");\n\n    policy.Options.Add(policyOption);\n\n    // Add ContentKeyAutorizationPolicy to ContentKey\n    objIContentKey.AuthorizationPolicyId = policy.Id;\n    IContentKey IContentKeyUpdated = objIContentKey.UpdateAsync().Result;\n\n    return IContentKeyUpdated;\n}</pre>\n&nbsp;\n\n上記では、ContentKeyAuthorizationHelper.CreateRestrictionRequirements() メソッドは次のように定義されています。\n<pre class=\"prettyprint\">public static string CreateRestrictionRequirements()\n{\n    string primarySymmetricKey   = System.Configuration.ConfigurationManager.AppSettings[\"PrimarySymmetricKey\"];\n    string secondarySymmetricKey = System.Configuration.ConfigurationManager.AppSettings[\"SecondarySymmetricKey\"];\n    string scope                 = System.Configuration.ConfigurationManager.AppSettings[\"AcsScope\"];\n    string issuer                = System.Configuration.ConfigurationManager.AppSettings[\"AcsIssuer\"];\n\n    TokenRestrictionTemplate objTokenRestrictionTemplate = new TokenRestrictionTemplate();\n\n    objTokenRestrictionTemplate.PrimaryVerificationKey = new SymmetricVerificationKey(Convert.FromBase64String(primarySymmetricKey));\n    objTokenRestrictionTemplate.AlternateVerificationKeys.Add(new SymmetricVerificationKey(Convert.FromBase64String(secondarySymmetricKey)));\n    objTokenRestrictionTemplate.Audience               = new Uri(scope);\n    objTokenRestrictionTemplate.Issuer                 = new Uri(issuer);\n\n    return TokenRestrictionTemplateSerializer.Serialize(objTokenRestrictionTemplate);\n}</pre>\n&nbsp;\n\n<strong>メモ：</strong> ACS 2.0 名前空間で使用されている <strong>のと同じ</strong> (プライマリ) 対称ハッシュ キーが、(動的な) AES 暗号化承認ポリシーの構成にも使用されていることを確認してください。\n\n次に、資産の配信に使用される IAssetDeliveryPolicy を作成する必要があります。\n<pre class=\"prettyprint\">public static IAssetDeliveryPolicy CreateAssetDeliveryPolicy(CloudMediaContext objCloudMediaContext, IContentKey objIContentKey)\n{\n    Uri keyAcquisitionUri = objIContentKey.GetKeyDeliveryUrl(ContentKeyDeliveryType.BaselineHttp);\n\n    string envelopeEncryptionIV = Convert.ToBase64String(CryptoUtils.GenerateCryptographicallyStrongRandomBytes(16));\n\n    // The following policy configuration specifies: \n    //   key url that will have KID=&lt;Guid&gt; appended to the envelope and\n    //   the Initialization Vector (IV) to use for the envelope encryption.\n    Dictionary&lt;AssetDeliveryPolicyConfigurationKey, string&gt; assetDeliveryPolicyConfiguration = new Dictionary&lt;AssetDeliveryPolicyConfigurationKey, string&gt; \n            {\n                {AssetDeliveryPolicyConfigurationKey.EnvelopeKeyAcquisitionUrl, keyAcquisitionUri.ToString()},\n                {AssetDeliveryPolicyConfigurationKey.EnvelopeEncryptionIVAsBase64, envelopeEncryptionIV}\n            };\n\n    IAssetDeliveryPolicy objIAssetDeliveryPolicy = objCloudMediaContext.AssetDeliveryPolicies.Create(\n                \"SmoothHLSDynamicEncryptionAssetDeliveryPolicy\",\n                AssetDeliveryPolicyType.DynamicEnvelopeEncryption,\n                AssetDeliveryProtocol.SmoothStreaming | AssetDeliveryProtocol.HLS,\n                assetDeliveryPolicyConfiguration);\n\n    Console.WriteLine();\n    Console.WriteLine(\"Adding Asset Delivery Policy: \" + objIAssetDeliveryPolicy.AssetDeliveryPolicyType);\n    Console.WriteLine(\"Key Delivery URL = {0}\", keyAcquisitionUri.ToString());\n\n    return objIAssetDeliveryPolicy;\n}</pre>\n&nbsp;\n\n最後に、上記のすべてを組み合わせて、資産の AES 動的暗号化を追加する全体的なフローを次のように形成します。\n<pre class=\"prettyprint\">public static void DynamicAesEncryptionFlow(CloudMediaContext objCloudMediaContext, IAsset objIAsset)\n{\n    //Create IContentKey\n    IContentKey objIContentKey = CreateEnvelopeTypeContentKey(objCloudMediaContext);\n\n    //add AuthorizationPolicy to IContentKey\n    objIContentKey = AddAuthorizationPolicyToContentKey(objCloudMediaContext, objIContentKey);\n\n    //create asset delivery policy\n    IAssetDeliveryPolicy objIAssetDeliveryPolicy = CreateAssetDeliveryPolicy(objCloudMediaContext, objIContentKey);\n\n    //Associate IContentKey with IAsset\n    objIAsset.ContentKeys.Add(objIContentKey);\n\n    // Add AssetDelivery Policy to the asset\n    objIAsset.DeliveryPolicies.Add(objIAssetDeliveryPolicy);\n}</pre>\nこれを実行した後、API を使用するか、Azure portalを使用して、資産を発行する必要があります。\n\n&nbsp;\n<h2>ACS セットアップ</h2>\n同じ対称検証キー、同じサービス ID、同じ発行者とスコープなど、ACS <a href=\"https://azure.microsoft.com/blog/2014/11/17/an-end-to-end-prototype-of-playready-protection-with-acs-authentication-and-acs-token-authorization/\" target=\"_blank\">認証と ACS トークン承認を使用した PlayReady Protection のエンド ツー エンド プロトタイプ</a>のブログで設定したのと同じ ACS 2.0 名前空間を使用できます。\n\nACS サービス ID を設定するときに、パスワードまたは対称キーの資格情報の種類を選択できます。 どちらの場合もプロトタイプでサポートされています (以下のトークン要求コード)。\n\n&nbsp;\n<h2>プレイヤー コード</h2>\n<a href=\"https://azure.microsoft.com/blog/2014/10/27/microsoft-adaptive-streaming-plugin-for-osmf-update/\" target=\"_blank\">OSMF 用 Microsoft アダプティブ ストリーミング プラグイン</a> は、AES-128 暗号化されたスムーズ ストリーミングのオンデマンド再生とライブ再生の両方をサポートしています。 そのため、目的に OSMF プレーヤーを使用します。 OSMF プレーヤーのフローは次のとおりです。\n<ol>\n <li>テスト資産のクライアント マニフェストに示すように、AES-128 暗号化されたコンテンツを示し、キー配信 URL を含むスムーズ ストリーミング マニフェストをダウンロードします。</li>\n <li>承認トークンの要求。</li>\n <li>承認トークンを使用して暗号化解除キーを要求します。</li>\n <li>復号化と再生。</li>\n</ol>\nまず、ACS 名前空間から承認トークンを要求するコードは次のとおりです。\n<pre class=\"prettyprint\">public string GetAcsToken()\n{\n    string issuer   = System.Configuration.ConfigurationManager.AppSettings[\"AcsIssuer\"];\n    string scope    = System.Configuration.ConfigurationManager.AppSettings[\"AcsScope\"];\n    string username = System.Configuration.ConfigurationManager.AppSettings[\"Username\"];\n    string password = System.Configuration.ConfigurationManager.AppSettings[\"Password\"];\n\n    string tokenToReturn = null;\n\n    using (WebClient client = new WebClient())\n    {\n        //  Create the authentication request to get a token\n        client.BaseAddress = (new Uri(issuer)).AbsoluteUri;\n\n        NameValueCollection objNameValueCollection = null;\n        switch (System.Configuration.ConfigurationManager.AppSettings[\"CredentialType\"].ToLower())\n        {\n            case \"password\":\n                objNameValueCollection = new NameValueCollection\n                {\n                    {\"grant_type\",    \"client_credentials\"},\n                    {\"client_id\",     username},\n                    {\"client_secret\", password},\n                    {\"scope\",         scope}\n                };\n                break;\n            case \"symmetrickey\":\n                objNameValueCollection = new NameValueCollection\n                {\n                    {\"grant_type\",    \"\"},\n                    {\"assertion\",     this.CreateToken(username, password)},\n                    {\"scope\",         scope}\n                };\n                break;\n            default:\n                break;\n        }\n\n        byte[] responseBytes = null;\n\n        try\n        {\n            responseBytes = client.UploadValues(new Uri(issuer + \"/v2/OAuth2-13/\"), \"POST\", objNameValueCollection);\n        }\n        catch (WebException we)\n        {\n            Stream stream = we.Response.GetResponseStream();\n            StreamReader reader = new StreamReader(stream);\n\n            throw;\n        }\n\n        using (var responseStream = new MemoryStream(responseBytes))\n        {\n            OAuth2TokenResponse tokenResponse = (OAuth2TokenResponse)new DataContractJsonSerializer(typeof(OAuth2TokenResponse)).ReadObject(responseStream);\n            tokenToReturn = tokenResponse.AccessToken;\n        }\n    }\n\n    return tokenToReturn;\n}\n\npublic string CreateToken(string issuer, string signingKey)\n{\n    System.Text.StringBuilder sb = new System.Text.StringBuilder();\n    // add the issuer name \n    sb.AppendFormat(\"Issuer={0}\", System.Web.HttpUtility.UrlEncode(issuer));\n    string signature = this.GenerateSignature(sb.ToString(), signingKey);\n    sb.AppendFormat(\"&amp;HMACSHA256={0}\", signature);\n    return sb.ToString();\n} \n\nprivate string GenerateSignature(string unsignedToken, string signingKey)\n{\n    System.Security.Cryptography.HMACSHA256 hmac = new System.Security.Cryptography.HMACSHA256(Convert.FromBase64String(signingKey));\n    byte[] locallyGeneratedSignatureInBytes = hmac.ComputeHash(System.Text.Encoding.ASCII.GetBytes(unsignedToken));\n    string locallyGeneratedSignature = System.Web.HttpUtility.UrlEncode(Convert.ToBase64String(locallyGeneratedSignatureInBytes));\n    return locallyGeneratedSignature;\n}</pre>\n&nbsp;\n\nOAuth2TokenResponse 型は次のように定義されます。\n<pre class=\"prettyprint\">[DataContract]\npublic class OAuth2TokenResponse\n{\n    [DataMember(Name = \"access_token\")]\n    public string AccessToken { get; set; }\n\n    [DataMember(Name = \"expires_in\")]\n    public int ExpirationInSeconds { get; set; }\n}</pre>\n&nbsp;\n\nプレーヤーをホストする ASP.NET Web ページは次のとおりです。\n<pre class=\"prettyprint\">&lt;%@ Page Language=\"C#\" AutoEventWireup=\"true\" CodeBehind=\"Aes128OSMFPlayer.aspx.cs\" Inherits=\"SilverlightApplication.Web.OSMF.Aes128OSMFPlayer\" %&gt;\n\n&lt;!DOCTYPE html&gt;\n\n&lt;html xmlns=\"https://www.w3.org/1999/xhtml\"&gt;\n&lt;head runat=\"server\"&gt;\n    &lt;title&gt;AES Encryption | OSMF Player&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        .auto-style1 {\n            height: 17px;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body style=\"font-family:Verdana;font-size:11px\"&gt;\n    &lt;form id=\"form1\" runat=\"server\"&gt;\n        &lt;div&gt;\n            &lt;h3&gt;End-to-End Prototype of AES Encryption with ACS Authorization Token for Smooth Streaming&lt;/h3&gt;\n            &lt;table&gt;&lt;tr&gt;&lt;td&gt;Source URL: &lt;/td&gt;&lt;td&gt;\n                &lt;asp:TextBox ID=\"txtSrcUrl\" runat=\"server\" Width=\"913px\"&gt;https://willzhanmediaservice.origin.mediaservices.windows.net/474c4840-4753-48ec-b3aa-9d05daef612a/LyncSkypeSizzleVideo750k.ism/manifest&lt;/asp:TextBox&gt;\n            &lt;/td&gt;&lt;/tr&gt;\n            &lt;tr&gt;&lt;td&gt;Key Delivery URL:&lt;/td&gt;&lt;td&gt;&lt;a href=\"https://willzhanmediaservice.keydelivery.mediaservices.windows.net/?KID=1814f449-0550-4977-abd5-fe3efeaf6086\" target=\"_blank\"&gt;https://willzhanmediaservice.keydelivery.mediaservices.windows.net/?KID=1814f449-0550-4977-abd5-fe3efeaf6086&lt;/a&gt;\n            &lt;/td&gt;&lt;/tr&gt;\n                &lt;tr&gt;&lt;td class=\"auto-style1\"&gt;Authorization Token:&lt;/td&gt;&lt;td class=\"auto-style1\"&gt;&lt;%=authorizationToken %&gt;&lt;/td&gt;&lt;/tr&gt;\n            &lt;tr&gt;&lt;td&gt;Token Issuer: &lt;/td&gt;&lt;td&gt;&lt;a href=\"https://willzhanacs.accesscontrol.windows.net\" target=\"_blank\"&gt;https://willzhanacs.accesscontrol.windows.net&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;\n            &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;\n                &lt;asp:Button ID=\"cmdPlay\" runat=\"server\" OnClick=\"cmdPlay_Click\" Text=\"Play\" /&gt;\n            &lt;/td&gt;&lt;/tr&gt;\n            &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;\n                    &lt;object width=\"920\" height=\"640\"&gt;\n                        &lt;param name=\"movie\" value=\"StrobeMediaPlayback.2.0.swf\"&gt;&lt;/param&gt;\n                        &lt;param name=\"flashvars\" value=\"src=&lt;%=srcUrl %&gt;&amp;autoPlay=&lt;%=autoPlay %&gt;&amp;plugin_AdaptiveStreamingPlugin=MSAdaptiveStreamingPlugin-v1.0.12-osmf2.0.swf&amp;AdaptiveStreamingPlugin_retryLive=true&amp;AdaptiveStreamingPlugin_retryInterval=10&amp;AdaptiveStreamingPlugin_encryptionKeyToken=&lt;%=authorizationToken %&gt;\"&gt;&lt;/param&gt;\n                        &lt;param name=\"allowFullScreen\" value=\"true\"&gt;&lt;/param&gt;\n                        &lt;param name=\"allowscriptaccess\" value=\"always\"&gt;&lt;/param&gt;\n                        &lt;param name=\"wmode\" value=\"direct\"&gt;&lt;/param&gt;\n                        &lt;embed src=\"StrobeMediaPlayback.2.0.swf\"\n                            type=\"application/x-shockwave-flash\"\n                            allowscriptaccess=\"always\"\n                            allowfullscreen=\"true\"\n                            wmode=\"direct\"\n                            width=\"920\"\n                            height=\"640\"\n                            flashvars=\"src=&lt;%=srcUrl %&gt;&amp;autoPlay=&lt;%=autoPlay %&gt;&amp;plugin_AdaptiveStreamingPlugin=MSAdaptiveStreamingPlugin-v1.0.12-osmf2.0.swf&amp;AdaptiveStreamingPlugin_retryLive=true&amp;AdaptiveStreamingPlugin_retryInterval=10&amp;AdaptiveStreamingPlugin_encryptionKeyToken=&lt;%=authorizationToken %&gt;\"&gt;\n                        &lt;/embed&gt;\n                    &lt;/object&gt;\n                &lt;/td&gt;&lt;/tr&gt;\n                &lt;/table&gt;\n        &lt;/div&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;</pre>\n&nbsp;\n\n対応する分離コードは次のとおりです。\n<pre class=\"prettyprint\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Web;\nusing System.Web.UI;\nusing System.Web.UI.WebControls;\n\nnamespace SilverlightApplication.Web.OSMF\n{\n    public partial class Aes128OSMFPlayer : System.Web.UI.Page\n    {\n        protected string authorizationToken;\n        protected string autoPlay;\n        protected string srcUrl;\n        protected void Page_Load(object sender, EventArgs e)\n        {\n            if (!Page.IsPostBack)\n            {\n                this.Play();\n            }\n        }\n\n        protected void cmdPlay_Click(object sender, EventArgs e)\n        {\n            this.Play();\n        }\n\n        protected void Play()\n        {\n            //Request authorization token from ACS 2.0 namespace\n            WCFService objWCFService = new WCFService();\n            string token = objWCFService.GetAcsToken();\n            token = string.Format(\"Bearer={0}\", token);\n\n            //URL-encode the token before using it\n            authorizationToken = System.Web.HttpUtility.UrlEncode(token);\n\n            srcUrl = txtSrcUrl.Text;\n            autoPlay = true.ToString();\n        }\n    }\n}</pre>\n&nbsp;\n<h1>まとめ</h1>\nすべての主要コンポーネントを含む AES 暗号化ソリューションAzure Media Servicesエンド ツー エンドのプロトタイプを紹介しました。\n<ol>\n <li>コンテンツ キー ID とコンテンツ キーの生成。</li>\n <li>Azure Media Servicesのストリーミング配信元。</li>\n <li>Azure Media Servicesコンテンツ保護による AES 暗号化。</li>\n <li>Azure Media Servicesコンテンツ保護を介した AES キーの配信。</li>\n <li>プレイヤー クライアントを認証し、承認トークンを発行するための、Azure ACS 2.0 経由の STS (Secure Token Service)。</li>\n <li>Azure IaaS VM でホストされているビデオ プレーヤー アプリケーション。ACS 認証、ACS 承認、復号化キーの取得、ビデオ再生を処理します。</li>\n</ol>\n&nbsp;\n\n<strong>更新：</strong>\n\n2015 年 1 月 6 日: OSMF プラグイン プレーヤーは、より一般的なシナリオで AES 暗号化をテストするために強化されました。このブログで説明するエンド ツー エンドの実装に使用される ACS 名前空間だけでなく、任意の Azure ACS 名前空間で動作するようになりました。 ACS 名前空間パラメーター/シークレットは、テストするユーザーによって置き換えることができます。\n\n2015/1/23: AMS Content Protection での JWT サポートのリリースにより、このプロトタイプは、STS と IdP の両方として Azure Active Directory (AAD) を使用して JWT のトークン制限を含むように拡張されました。 AMS バッチ ジョブ (動的 PlayReady 保護または AES 暗号化を設定する場合): AADテナントを認識していますが、プレイヤー アプリについては何も認識しません (どのプレイヤーでも問題ありません)。 AAD テナント: プレイヤー アプリは認識されますが、AMS バッチ ジョブについては何も知りません。 プレイヤー アプリ: テナントAAD認識されますが、AMS または AMS バッチ ジョブについては何も認識しません。 順番の言葉で言えば、AADテナントとプレイヤー アプリは互いを認識しています。 AMS バッチ ジョブはテナントAAD認識しますが、プレイヤーがコンテンツを使用しても問題ありません。\n\n&nbsp;\n\n<b>承認： </b>クインティン・バーンズ、ジョージ・トリフォノフ、Microsoft Azure Media Servicesチームのミンフェイ・ヤンに感謝します。"
}