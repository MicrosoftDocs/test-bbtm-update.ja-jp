{
    "Slug": "an-end-to-end-prototype-of-playready-protection-with-acs-authentication-and-acs-token-authorization",
    "Title": "ACS 認証と ACS トークン承認を使用した PlayReady Protection のエンド ツー エンド プロトタイプ",
    "Summary": "The dynamic PlayReady protection feature in Azure Media Services, makes “one-click DRM” a reality.",
    "Content": "&nbsp;\n<h1>はじめに</h1>\nこのエンドツーエンドのプロトタイプは、アジアとヨーロッパのお客様からの要求に応えるものでした。\n\n<a href=\"https://azure.microsoft.com/blog/2014/09/10/announcing-public-availability-of-azure-media-services-content-protection-services/\">Azure Media Services コンテンツ保護</a>には、次のものが含まれます。\n<ul>\n <li>PlayReady ライセンス配信サービス。</li>\n <li>AES 128クリアキー配信サービス;</li>\n <li>配信時間中の動的 PlayReady 保護または AES 暗号化。</li>\n <li>メディア処理ワークフローでの静的 PlayReady 保護または AES 暗号化。</li>\n</ul>\nAzure Media Servicesの動的 PlayReady 保護機能によって \"ワンクリック DRM\" が現実のものになるのは注目に値します。顧客またはパートナーは、\"従来の DRM\" で必要な次の手順を実行する必要はありません。\n<ol>\n <li>PlayReady サーバー ライセンスのセキュリティ保護、</li>\n <li>PlayReady ライセンス サーバー ファームの立ち上がり、</li>\n <li>PlayReady パッケージ化ワークフローを実行して資産を保護します。</li>\n</ol>\n\"シングル クリック\" で資産を保護または保護解除することができ、Web ページの更新の速度で行われます。\n\n通常、DRM ソリューションには複数の移動パーツが含まれます。次のブログでは、DRM ソリューションの構成要素の概要を示します。<a href=\"https://blogs.msdn.com/b/playready4/archive/2014/08/18/solution-design-considerations-in-using-playready-license-delivery-service-of-azure-media-services.aspx\">Azure Media Servicesの PlayReady ライセンス配信サービスを使用する場合のソリューション設計に関する考慮事項</a>です。 完全なエンドツーエンドのプロトタイプが望ましいでしょう。これがこの取り組みの目標です。\n\n&nbsp;\n<h2><span style=\"font-size: xx-large\">エンドツーエンドのプロトタイプ</span></h2>\n<h2>設計と機能</h2>\nこの取り組みの目的は、以下をカバーするエンドツーエンドのプロトタイプを提供することにある。\n<ul>\n <li>AMS の資産に対するトークン制限を使用した PlayReady 動的保護 (または静的保護)。</li>\n <li>PlayReady ライセンスを配信するためのライセンス配信サービスをAzure Media Servicesします。</li>\n <li>SWT 承認トークンを発行するための STS としての <a href=\"https://msdn.microsoft.com/en-us/library/azure/hh147631.aspx\">Azure ACS</a> (Microsoft Azure Active Directory Access Control)。</li>\n <li>Silverlight プレイヤー\n<ol>\n <li>ACS サービス ID によって認証されます。</li>\n <li>ACS から承認トークンを取得します。</li>\n <li>は、ACS トークンを使用して AMS ライセンス配信サービスから PlayReady ライセンスを取得し、</li>\n <li>は、スムーズ ストリーミングまたは MPEG-DASH アセットをダウンロードして、後続のビデオ再生を行います。</li>\n</ol>\n</li>\n</ul>\n次の理由だけで Silverlight プレーヤーを使用することを選択しました。\n<ol>\n <li>IE、Chrome、Firefox などの一般的なブラウザーからプレイヤーにアクセスできるようにするには、</li>\n <li><a href=\"https://www.microsoft.com/en-us/download/details.aspx?id=42080\" target=\"_blank\">Smooth Streaming Client v2.5</a> には、PlayReady クライアント ライセンスを必要としない PlayReady クライアント サポートが付属しています。</li>\n <li><a href=\"https://www.microsoft.com/en-us/download/details.aspx?id=42080\" target=\"_blank\">Smooth Streaming Client v2.5</a> では、MPEG-DASH もサポートされています。 このエンドツーエンドのプロトタイプでは、スムーズ ストリーミングに加えて MPEG-DASH も対象とします。</li>\n</ol>\n&nbsp;\n\nこのエンドツーエンドのプロトタイプの設計を次の図に示します。 これは、Azure Media Servicesの <a href=\"https://blogs.msdn.com/b/playready4/archive/2014/08/18/solution-design-considerations-in-using-playready-license-delivery-service-of-azure-media-services.aspx\">PlayReady ライセンス配信サービスの使用に関する著者のブログのソリューション設計に関する考慮事項で</a>説明されている一般的な DRM ソリューション図の特殊化です。\n\n&nbsp;\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/11/14/Blog_Secure_Delivery_Prototype.jpg\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"Blog_Secure_Delivery_Prototype\" alt=\"Blog_Secure_Delivery_Prototype\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/Blog_Secure_Delivery_Prototype_thumb.jpg\" width=\"636\" height=\"473\" border=\"0\" /></a>\n\n&nbsp;\n\nエンド ツー エンドのプロトタイプは、Azure とAzure Media Servicesでホストされます。 プロトタイプに関連する情報を次に示します。\n<ul>\n <li>PlayReady 動的保護下のスムーズ ストリーミング資産の URL。</li>\n <li>PlayReady 動的保護下の MPEG-DASH 資産の URL。</li>\n <li><a href=\"https://willzhanmediaservice.keydelivery.mediaservices.windows.net/PlayReady/\" target=\"_blank\">PlayReady ライセンス取得の URL</a>。</li>\n <li>PlayReady ライセンスの種類: 非永続的 (テストを任意の期間に何度でも繰り返すことができるように)</li>\n <li><a href=\"https://willzhanacs.accesscontrol.windows.net\" target=\"_blank\">SWT 承認トークンを発行する Azure ACS 名前空間の URL</a>。</li>\n <li>Silverlight プレーヤーの URL。</li>\n <li>承認ポリシーの制限:</li>\n</ul>\n<blockquote>\n<pre class=\"prettyprint\">&lt;TokenRestrictionTemplate xmlns:i=\"https://www.w3.org/2001/XMLSchema-instance\" xmlns=\"\"&gt;\n  &lt;AlternateVerificationKeys&gt;\n    &lt;TokenVerificationKey i:type=\"SymmetricVerificationKey\"&gt;\n      &lt;KeyValue&gt;(portion deleted) Yw1z2wxh6ZkX4tRl/WVhBTvM6T/vUo=&lt;/KeyValue&gt;\n    &lt;/TokenVerificationKey&gt;\n  &lt;/AlternateVerificationKeys&gt;\n  &lt;Audience&gt;urn:test&lt;/Audience&gt;\n  &lt;Issuer&gt;https://willzhanacs.accesscontrol.windows.net/&lt;/Issuer&gt;\n  &lt;PrimaryVerificationKey i:type=\"SymmetricVerificationKey\"&gt;\n    &lt;KeyValue&gt;(portion deleted) A8RlVMrPNhukYBF2sW04UMpuD8bw=&lt;/KeyValue&gt;\n  &lt;/PrimaryVerificationKey&gt;\n  &lt;RequiredClaims /&gt;\n&lt;/TokenRestrictionTemplate&gt;</pre>\n</blockquote>\n&nbsp;\n<h2></h2>\n<h2>実行方法</h2>\nテスト プレーヤーを使用してこのプロトタイプを実行する簡単な手順を次に示します。\n<ol>\n <li>プレイヤーを参照する</li>\n <li>URL を入力できるように、[URL の追加] チェック マークをオンにします。</li>\n <li>[Add AuthN ACS Token]\\(AuthN ACS トークンの追加\\) チェック マークをオンにして、ACS 承認トークンが最初に要求され、LA_URL テキスト ボックスに指定されたライセンス取得 URL から PlayReady ライセンス取得で使用されるようにします。</li>\n <li>スムーズ ストリーミング アセット URL または MPEG-DASH アセット URL をコピーし、SRC_URL テキスト ボックスに貼り付けます。 次に、[プレイリストに追加]ボタンを押して再生します。</li>\n</ol>\n&nbsp;\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/11/15/Player.jpg\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"プレーヤー\" alt=\"Player\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/Player_thumb.jpg\" width=\"636\" height=\"249\" border=\"0\" /></a>\n\nボタンをクリックすると、プレイヤーは次の手順を実行します。\n<ol>\n <li>PlayReady 動的保護の下にある資産のクライアント マニフェストをダウンロードします。</li>\n <li>サービス ID を使用して ACS 2.0 名前空間によって認証されます。</li>\n <li>ACS に承認トークンを要求する。</li>\n <li>ACS トークンを使用してLA_URLから PlayReady ライセンスを要求します。</li>\n <li>復号化し、PlayReady の制限と右を確認してから、ビデオを再生します。</li>\n</ol>\nもちろん、[Add AuthN ACS Token]\\(認証 ACS トークンの追加\\) チェック ボックスをオフにしてボタンをクリックすると、ACS 名前空間からの承認トークンがないため、PlayReady ライセンスの取得時に失敗します。\n\n&nbsp;\n<h1></h1>\n<h1>実装</h1>\n実装には、次のものが含まれます。\n<ol>\n <li>.NET API を使用してスムーズ ストリーミング資産の PlayReady 動的保護Azure Media Services構成する。\n<ul>\n <li>コンテンツ キー ID とコンテンツ キーを生成する。</li>\n <li>キー配信サービスを構成する。</li>\n <li>資産配信ポリシーを使用して動的 PlayReady 保護を構成する。</li>\n <li>資産を発行します。</li>\n</ul>\n</li>\n <li>プレイヤー クライアントを認証し、承認トークンを発行するように Azure ACS 2.0 名前空間を設定します。</li>\n <li>認証、承認、ライセンス取得、ビデオ再生を処理する Silverlight プレーヤーを開発します。</li>\n</ol>\n<h2></h2>\n&nbsp;\n<h2>コンテンツ キーの生成</h2>\nコンテンツ キー ID とコンテンツ キーを生成するには、さまざまな方法があります。 詳細については、 <a href=\"https://blogs.msdn.com/b/playready4/archive/2014/08/18/solution-design-considerations-in-using-playready-license-delivery-service-of-azure-media-services.aspx\" target=\"_blank\">作成者のブログ</a> (キーの生成と管理のセクション) を参照してください。 たとえば、次の方法があります。\n<blockquote>\n<pre class=\"prettyprint\">string keySeedB64, contentKeyB64;\nGuid keyId = Guid.NewGuid();\n//Guid keyId = new Guid(\"09a2212a-a803-4989-9a6e-6cd2e69500e7\");</pre>\n&nbsp;\n<pre class=\"prettyprint\">   \n//Method 1: Without using key seed, generete content key directly\n//contentKeyB64 = GeneratePlayReadyContentKey();</pre>\n&nbsp;\n<pre class=\"prettyprint\">//Method 2: With a given key seed and generated key ID (Key Identifiers are unique in the system and there can only be one key with a given Guid within a cluster (even across accounts for now although that may change to be account scoped in the future).  If you try to submit a protection job with a keyId that already exists but a different key value that will cause the PlayReady protection job to fail (the same keyId and keyValue is okay). \nkeySeedB64 = \"XVBovsmzhP9gRIZxWfFta3VVRPzVEWmJsazEJ46I\";\ncontentKeyB64 = GetPlayReadyContentKeyFromKeyIdKeySeed(keyId.ToString(), keySeedB64);</pre>\n&nbsp;\n<pre class=\"prettyprint\">//Method 3: With a randomly generated key seed, create content key from the key ID and key seed\n//keySeedB64 = GeneratePlayReadyKeySeed();\n//contentKeyB64 = GetPlayReadyContentKeyFromKeyIdKeySeed(keyId.ToString(), keySeedB64);</pre>\n&nbsp;\n<pre class=\"prettyprint\">//Method 4: Reuse an existing key ID (only once, for test)\n//keyId = new Guid(\"a7586184-40ff-4047-9edd-6a8273ac50fc\");\n//keySeedB64 = \"XVBovsmzhP9gRIZxWfFta3VVRPzVEWmJsazEJ46I\";\n//contentKeyB64 = GetPlayReadyContentKeyFromKeyIdKeySeed(keyId.ToString(), keySeedB64);\nConsole.WriteLine(string.Format(\"STEP 1: Key ID = {0}, Content Key = {1}, Key Seed = {2}\", contentKeyB64, keyId.ToString(), keySeedB64));</pre>\n</blockquote>\nキー ID とキー シードの生成には、次のユーティリティ メソッドが使用されます。\n<blockquote>\n<pre class=\"prettyprint\">public static byte[] GenerateCryptographicallyStrongRandomBytes(int length)\n{\n    byte[] bytes = new byte[length];\n    //This type implements the IDisposable interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its Dispose method in a try/catch block. To dispose of it indirectly, use a language construct such as using (in C#) \n    using (var rng = new System.Security.Cryptography.RNGCryptoServiceProvider())\n    {\n        rng.GetBytes(bytes);\n    }\n    return bytes;\n}</pre>\n&nbsp;\n<pre class=\"prettyprint\">//generate a PlayReady content key: cryptographically strong random byte[16]\npublic static string GeneratePlayReadyContentKey()\n{\n    byte[] bytes = GenerateCryptographicallyStrongRandomBytes(16);\n    return Convert.ToBase64String(bytes);\n}</pre>\n&nbsp;\n<pre class=\"prettyprint\">public static string GeneratePlayReadyKeySeed()\n{\n    byte[] bytes = GenerateCryptographicallyStrongRandomBytes(30);   //30 for key seed: https://msdn.microsoft.com/en-us/library/hh973610.aspx\n    return Convert.ToBase64String(bytes);\n}</pre>\n&nbsp;\n<pre class=\"prettyprint\">public static string GenerateSymmetricHashKey()\n{\n    byte[] bytes = GenerateCryptographicallyStrongRandomBytes(32);  \n    return Convert.ToBase64String(bytes);\n}</pre>\n&nbsp;\n<pre class=\"prettyprint\">//This API works the same as AESContentKey constructor in PlayReady Server SDK \npublic static string GetPlayReadyContentKeyFromKeyIdKeySeed(string keyIdString, string keySeedB64)\n{\n    Guid keyId = new Guid(keyIdString);\n    byte[] keySeed = Convert.FromBase64String(keySeedB64);\n\n    byte[] contentKey = CommonEncryption.GeneratePlayReadyContentKey(keySeed, keyId);\n\n    string contentKeyB64 = Convert.ToBase64String(contentKey);\n\n    return contentKeyB64;\n}</pre>\n</blockquote>\n&nbsp;\n<h2>Azure Media Servicesのコード</h2>\nAzure Media Services側で、保護されていないスムーズ ストリーミング資産があるとします。 手順は次のとおりです。\n<ol>\n <li>この資産に含める可能性があるロケーターをすべて削除します。 ロケーターが存在する場合は、次の手順を続行できないため、これは重要です。</li>\n <li>資産配信ポリシーを削除します。</li>\n <li>ライセンス配信サービスを構成する。</li>\n <li>トークン制限を使用して動的 PlayReady 保護を構成する。</li>\n <li>資産を発行します。</li>\n</ol>\nPlayReady キー配信サービスを設定し、入力資産を動的に保護するためのコードは、<a href=\"https://github.com/Azure/azure-media-services-samples/blob/master/PlayReadyACSE2E/PlayReadyACSE2E_AMS_Code\" target=\"_blank\">Azure/azure-media-services-samples/ GitHub</a>にあります。\n\n&nbsp;\n<h2>ACS セットアップ</h2>\nAzure ACS v 2.0 名前空間を構成する手順については、Mingfei のブログ<a title=\"「Permalink to configure ACS with Media Services key servicesHow\" href=\"https://mingfeiy.com/acs-with-key-services\"> to configure ACS with Media Services key services</a>」を参照してください。\n\n一般に、次の 2 つの認証があります。\n<ol>\n <li>エンド ユーザーは、プレイヤーをホストする Web アプリケーション (いわゆる証明書利用者) にアクセスするために ID プロバイダーによって認証されます。 このプロトタイプでは、ユーザー認証を必要とせずに Web アプリケーションを開いたままにすることを選択しました。 そのため、Web アプリケーションの ID プロバイダーは必要ありません。</li>\n <li>クライアント/自律アプリケーションは、ACS 2.0 名前空間によって認証され、アクセス権を取得し、トークンを取得します。 この目的のために、ID プロバイダーを使用するのではなく、ACS で直接認証する <a href=\"https://msdn.microsoft.com/en-us/library/gg185945.aspx\" target=\"_blank\">サービス</a> ID を指定します。 このサービス ID は、ACS 名前空間から承認トークンを要求するために、クライアントが ACS によって認証するために使用されます。</li>\n</ol>\n&nbsp;\n\nこの ACS 2.0 名前空間によって発行されたトークンの例を次に示します。\n<pre class=\"prettyprint\">http%3a%2f%2fschemas.xmlsoap.org%2fws%2f2005%2f05%2fidentity%2fclaims%2fnameidentifier=willzhan&amp;http%3a%2f%2fschemas.microsoft.com%2faccesscontrolservice%2f2010%2f07%2fclaims%2fidentityprovider=https%3a%2f%2fwillzhanacs.accesscontrol.windows.net%2f&amp;Audience=urn%3atest&amp;ExpiresOn=1415800463&amp;Issuer=https%3a%2f%2fwillzhanacs.accesscontrol.windows.net%2f&amp;HMACSHA256=ylYe9U18Ea1OfGJ%2fn2hzYfsm3XcM9X1HI2pBgUk54Eo%3d</pre>\n&nbsp;\n\n<strong>メモ：</strong> PlayReady 動的保護の構成では、ACS 2.0 名前空間で使用されている <strong>のと同じ</strong> (プライマリ) 対称ハッシュ キーも使用されていることを確認してください。 具体的には、PlayReady 動的保護をプログラムで設定する場合は、次に示すように、IContentKeyAuthorizationPolicy で使用される制限要件を作成する必要があります。\n<blockquote>\n<pre class=\"prettyprint\">public static string CreateRestrictionRequirements()\n{\n    string primarySymmetricKey   = System.Configuration.ConfigurationManager.AppSettings[\"PrimarySymmetricKey\"];\n    string secondarySymmetricKey = System.Configuration.ConfigurationManager.AppSettings[\"SecondarySymmetricKey\"];\n    string scope                 = System.Configuration.ConfigurationManager.AppSettings[\"AcsScope\"];\n    string issuer                = System.Configuration.ConfigurationManager.AppSettings[\"AcsIssuer\"];\n\n    TokenRestrictionTemplate objTokenRestrictionTemplate = new TokenRestrictionTemplate();\n\n    objTokenRestrictionTemplate.PrimaryVerificationKey = new SymmetricVerificationKey(Convert.FromBase64String(primarySymmetricKey));\n    objTokenRestrictionTemplate.AlternateVerificationKeys.Add(new SymmetricVerificationKey(Convert.FromBase64String(secondarySymmetricKey)));\n    objTokenRestrictionTemplate.Audience               = new Uri(scope);\n    objTokenRestrictionTemplate.Issuer                 = new Uri(issuer);\n\n    return TokenRestrictionTemplateSerializer.Serialize(objTokenRestrictionTemplate);\n}</pre>\n</blockquote>\n&nbsp;\n\nprimarySymmetricKey 変数には、次に示すように ACS 2.0 管理ポータルから取得したのと同じ対称ハッシュ キー文字列が含まれている必要があります。\n\n&nbsp;\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/11/14/SymmetricHashKey.jpg\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"SymmetricHashKey\" alt=\"SymmetricHashKey\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/SymmetricHashKey_thumb.jpg\" width=\"632\" height=\"371\" border=\"0\" /></a>\n\nACS 名前空間でサービス ID を作成する場合は、パスワードまたは対称キーの資格情報の種類を選択できます。 トークン要求コードは、両方のケースをサポートするように拡張されました。\n\n&nbsp;\n<h2>クライアント側のコード</h2>\nACS と Silverlight 内のカスタム ライセンス取得者に認証トークンを要求するためのクライアント側コードは、<a href=\"https://github.com/Azure/azure-media-services-samples/blob/master/PlayReadyACSE2E/PlayReadyACSE2E_Client_Code\" target=\"_blank\">azure/azure-media-services-samples GitHub</a>にあります。\n\nプレーヤー アプリケーションでは、次の処理が実行されます。\n<ol>\n <li>まず、PlayReady 保護の下でスムーズ ストリーミング資産のマニフェストを要求し、マニフェストに保護ヘッダーを表示します。</li>\n <li>PlayReady ライセンスを要求するには、プレイヤーは最後のセクションで作成した ACS 名前空間から承認トークンを取得する必要があります。 Silverlight 固有のコードを記述しすぎないように、このコードを (WCF または REST) サービスに配置し、Silverlight アプリでサービスを呼び出して ACS トークンを取得することを検討してください。 ACS トークンを取得したら、そのトークンをプロパティ (Constants.AcsToken) に格納して、ライセンス取得者が直後に使用できます。</li>\n <li>ACS トークンは、前のセクションで構成された AMS ライセンス配信サービスから PlayReady ライセンスを取得するために、カスタム ライセンス取得者によって使用されます。</li>\n</ol>\n&nbsp;\n<h2>デプロイ</h2>\n上のシステム図と <a href=\"https://blogs.msdn.com/b/playready4/archive/2014/08/18/solution-design-considerations-in-using-playready-license-delivery-service-of-azure-media-services.aspx\" target=\"_blank\">作成者のブログ</a>で説明したように、このエンドツーエンドのプロトタイプには次の物理コンポーネントが含まれています。\n<ol>\n <li>コンテンツ キーとコンテンツ キー ID。</li>\n <li>Azure Media Servicesのビデオアセット(保護されていない)とAzure Media Servicesのストリーミング配信元。</li>\n <li>Azure Media Servicesの資産に対して構成された PlayReady 動的保護。</li>\n <li>Azure Media Servicesで構成された PlayReady ライセンス配信サービス。</li>\n <li>Azure ACS 2.0 名前空間で構成された STS。</li>\n <li>ASP.NET アプリケーションの Silverlight ビデオ プレーヤー。</li>\n</ol>\nソリューションはAzure Media Services上に構築されているため、展開する必要があるのは、ビデオ プレーヤーをホストする ASP.NET Web アプリケーションだけです。 デプロイするオプションは次のとおりです。\n<ul>\n <li>Azure Web サイト、</li>\n <li>Azure IaaS VM、または</li>\n <li>オンプレミス のサーバー。</li>\n</ul>\nHTTP プロセスのアクティブ化がサーバーにインストールされていることを確認してください。そうしないと、WCF サービスが正常に動作しません。 また、ストリーミング配信元が PlayReady 動的保護を使用するように、少なくとも 1 RU を構成してください。\n\n&nbsp;\n<h1>ライブ ストリーミングの場合</h1>\n良いニュースは、プログラムに関連付けられている資産を \"VOD 資産\" として扱うことで、Azure Media Servicesのライブ ストリーミングを保護するためにまったく同じ設計と実装を使用できることです。\n\n具体的には、Azure Media Services でライブ ストリーミングを行うには、チャネルを作成した後、チャネルの下にプログラムを作成する必要があることはよく知られています。 プログラムを作成するには、プログラムのライブ アーカイブを含む資産を作成する必要があります。 あなたがする必要があるのは、プログラムを開始する前に「VOD資産」であるかのように資産に同じセットアップ/処理を適用することです。 次のコードは、正確なフローを示しています。\n\n<a href=\"https://github.com/Azure/azure-media-services-samples/blob/master/PlayReadyACSE2E/PlayReadyACSE2E_AMS_Code\" target=\"_blank\">Azure Media Servicesのコード</a>に示すように、VOD 資産の動的 PlayReady 保護を設定するには、次のメソッドを使用します。\n<pre class=\"prettyprint\">public static void SetupDynamicPlayReadyProtection(CloudMediaContext objCloudMediaContext, IAsset objIAsset)</pre>\nライブ ストリーミングの動的 PlayReady 保護を設定するには、通常どおりチャネル、プログラム、およびその資産を作成できますが、プログラムを開始する前に、次に示すように、資産に対して上記の方法を実行します。\n<pre class=\"prettyprint\">public static void SetupLiveDynamicPlayReadyProtection(CloudMediaContext objCloudMediaContext, string channelName, string programName, string manifestFileName)\n        {\n            //get channel\n            IChannel objIChannel = objCloudMediaContext.Channels.Where(c =&gt; c.Name == channelName).FirstOrDefault();\n            Console.WriteLine(string.Format(\"IChannel.IngestUrl = {0}\",  objIChannel.Input.Endpoints.FirstOrDefault().Url.ToString()));\n            Console.WriteLine(string.Format(\"IChannel.PreviewUrl = {0}\", objIChannel.Preview.Endpoints.FirstOrDefault().Url.ToString()));\n\n            //create program asset\n            IAsset objIAsset = objCloudMediaContext.Assets.Create(string.Format(\"{0}_Program_Asset_PR\", channelName), AssetCreationOptions.None);\n\n            //set up dynamic PlayReady protection for the asset exactly as VOD\n            SetupDynamicPlayReadyProtection(objCloudMediaContext, objIAsset);\n\n            //create a program using this asset \n            ProgramCreationOptions options = new ProgramCreationOptions()\n            {\n                Name                = programName,\n                Description         = \"Dynamic PlayReady protection for live\",\n                ArchiveWindowLength = TimeSpan.FromMinutes(120.0),\n                ManifestName        = manifestFileName, //manifest file name to be duplicated (without .ism suffix)\n                AssetId             = objIAsset.Id\n            };\n            IProgram objIProgram = objIChannel.Programs.Create(options);\n\n            //publish the asset\n            Program.GetStreamingOriginLocator(objIAsset.Id, Program.MediaContentType.SmoothStreaming, true);\n\n            //start the program\n            objIProgram.Start();\n            Console.WriteLine(\"Program {0} has started\", programName);\n        }</pre>\n&nbsp;\n\nもちろん、これはいわゆる\"スケーラブルなライブテレビ\"PlayReady保護ではありません。リーフライセンスとルートライセンスのいわゆるキーローテーションなしで単一のコンテンツキーが保護に使用されるためです。\n<h1>まとめ</h1>\nDRM ソリューションのすべての主要コンポーネントを含む、Azure Media Services PlayReady ソリューションのエンド ツー エンドのプロトタイプを紹介しました。\n<ol>\n <li>コンテンツ キー ID とコンテンツ キーの生成。</li>\n <li>Azure Media Servicesのストリーミング配信元。</li>\n <li>Azure Media Services PlayReady 動的保護機能による PlayReady 保護。</li>\n <li>PlayReady ライセンス配信サービスAzure Media Services経由での PlayReady ライセンス配信。</li>\n <li>プレイヤー クライアントを認証し、承認トークンを発行するための Azure ACS 2.0 経由の STS (Secure Token Service)。</li>\n <li>Azure IaaS VM でホストされているビデオ プレーヤー アプリケーション。ACS 認証、ACS 承認、PlayReady ライセンス取得、ビデオ再生を処理します。</li>\n</ol>\n&nbsp;\n\n<strong>更新：</strong>\n\n2015 年 1 月 6 日: スムーズ ストリーミングと MPEG-DASH プレーヤーは、より一般的なシナリオで PlayReady 保護をテストするために強化されました。\n<ol>\n <li>これで、このブログで説明するエンドツーエンドの実装に使用される ACS 名前空間だけでなく、任意の Azure ACS 名前空間で動作するようになりました。</li>\n <li>これは、任意のスムーズストリーミングまたはMPEG-DASHアセットで動作します, トークン制限の有無にかかわらず、オープンまたは動的PlayReady保護の下で;</li>\n <li>これは、Azure Media Servicesまたはオンプレミスの PlayReady ライセンス サーバーのキー配信サービスである PlayReady ライセンス サーバーで動作します。</li>\n</ol>\n&nbsp;\n\n2015 年 1 月 23 日: AMS Content Protection での JWT サポートのリリースにより、このプロトタイプは、STS と IdP の両方として Azure Active Directory (AAD) を使用して JWT のトークン制限を含むように拡張されました。 AMS バッチ ジョブ (動的 PlayReady 保護または AES 暗号化を設定する場合): テナントAAD認識しますが、プレイヤー アプリについては何も認識しません (どのプレイヤーでも問題ありません)。 AADテナント: プレイヤー アプリを認識しますが、AMS バッチ ジョブについては何も認識しません。 プレイヤー アプリ: テナントAAD認識しますが、AMS または AMS バッチ ジョブについては何も認識しません。 順番に言えば、AADテナントアプリとプレイヤーアプリは互いを知っている。 AMS バッチ ジョブはテナントAAD認識しますが、どのプレイヤーがコンテンツを使用するかは気にしません。\n\n&nbsp;\n\n<b><span style=\"font-size: large\">承認：</span> </b>クインティン・バーンズ、ジョージ・トリフォノフ、Microsoft Azure Media Servicesチームのミンフェイ・ヤンに感謝します。"
}