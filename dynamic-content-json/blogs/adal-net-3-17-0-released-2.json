{
    "Slug": "adal-net-3-17-0-released-2",
    "Title": "ADAL.NET 3.17.0 リリース",
    "Summary": "ADAL.NET (Microsoft.IdentityModel.Clients.ActiveDirectory) is an authentication library which enables developers to acquire tokens from Azure AD and ADFS, to be used to access Microsoft APIs or applications registered with Azure Active Directory. ADAL.NET is available on several .NET platforms (Desktop, Universal Windows Platform, Xamarin / Android, Xamarin iOS, Portable Class Libraries, and .NET Core).",
    "Content": "<p>ADAL.NET (<a href=\"https://www.nuget.org/packages/Microsoft.IdentityModel.Clients.ActiveDirectory/\">Microsoft.IdentityModel.Clients.ActiveDirectory</a>) は、開発者がAzure ADおよび ADFS からトークンを取得して、Azure Active Directoryに登録されている Microsoft API またはアプリケーションにアクセスできるようにする認証ライブラリです。 ADAL.NET は、デスクトップ、ユニバーサル Windows プラットフォーム、Xamarin/Android、Xamarin iOS、ポータブル クラス ライブラリ、.NET Core など、いくつかの .NET プラットフォームで使用できます。 ADAL.NET 3.17.0 をリリースしました。これにより、新機能が有効になり、使いやすさ、プライバシー、パフォーマンスが向上します。</p>\n\n<h2>新機能の有効化</h2>\n\n<p>ADAL.Net 3.17.0 を使用すると、次のことが可能になります。</p>\n\n<ul>\n    <li>より効率的なアプリケーションを作成し、Azure AD調整に耐えます。</li>\n    <li>ログインしている場合でも、アプリのエンド ユーザーに ID の選択を強制します。</li>\n    <li>より効果的な条件付きアクセスを処理します。</li>\n</ul>\n\n<h3>より効率的なアプリケーションの有効化 (例: Retry-After)</h3>\n\n<p>ErrorCode <em>&quot;temporarily_unavailable&quot;</em>を使用して <em>AdalException</em> を処理、取得、およびキャッチするサンプルをいくつか見たことがあるかもしれません。 要求&rdquo;の数が多すぎるために&ldquo;サービス トークン サーバー (STS) がビジー状態になると、HTTP エラー 429 が返され、再試行できるタイミング (Retry-After 応答フィールド) が秒単位または日付としてヒントとして返されます。</p>\n\n<p>以前は、ADAL.NET はこの情報を表示しませんでした。 したがって、エラーを処理するために、ハードコーディングされた任意の遅延を待機した後、任意の回数再試行することをお勧めします。 コンソール アプリケーションの場合、コードは次のようになります。</p>\n\n<pre class=\"prettyprint\">\ndo\n{\n    retry = false;\n    try\n    {\n        result = await authContext.AcquireTokenAsync(resource, certCred);\n    }\n    catch (AdalException ex)\n    {\n        if (ex.ErrorCode == &quot;temporarily_unavailable&quot;)\n        {\n            retry = true;\n            retryCount++;\n            Thread.Sleep(3000);\n        }\n      &hellip;\n    }\n     &hellip;\n} while ((retry == true) &amp;&amp; (retryCount &lt; 2)); \n</pre>\n\n<p>ADAL.NET 3.17.0 以降では、System.Net.Http.Headers が表示されるようになりました<em>。</em><em>AdalServiceException</em> の Headers という名前の新しいプロパティとして HttpResponseHeaders。 そのため、追加情報を活用して、アプリケーションの信頼性を向上させることができます。 先ほど説明した場合は、RetryAfter プロパティ ( <em>RetryConditionHeaderValue</em> 型) を使用し、再試行するタイミングを計算できます。</p>\n\n<p>機密クライアント <a href=\"https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-authentication-scenarios#application-types-and-scenarios\">アプリケーション</a>またはパブリック クライアント アプリケーションに ADAL.Net を使用しているかどうかに応じて、<em>AdalServiceException </em>を直接キャッチするか<em>、AdalException の InnerException</em> としてキャッチする必要があることに<strong>注意</strong>してください。</p>\n\n<p>次のコード スニペットは、ケースに応じて続行する方法を示す必要があります。</p>\n\n<pre class=\"prettyprint\">\ndo\n{\n    retry = false;\n    TimeSpan ?delay;\n    try\n    {\n        result = await authContext.AcquireTokenAsync(resource, certCred);\n    }\n\n    // Case of a Confidential client flow \n    // (for instance auth code redemption in a Web App)\n    catch (AdalServiceException serviceException)\n    {\n     if (ex.ErrorCode == &quot;temporarily_unavailable&quot;)\n        {\n        RetryConditionHeaderValue retry= serviceException.Headers.RetryAfter;\n        if (retry.Delta.HasValue)\n              {\n            delay = retry.Delta;\n              }\n        else if (retry.Date.HasValue)\n              {\n            delay = retry.Date.Value.Offset;\n              }\n        }\n\n    }\n    \n    // Case of a client side exception\n    catch (AdalException ex)\n    {\n        if (ex.ErrorCode == &quot;temporarily_unavailable&quot;)\n        {\n     var serviceEx = ex.InnerException as AdalServiceException;\n    // Same kind of processing as above\n        }\n    &hellip;\n    }\n    &hellip;\n   if (delay.HasValue)\n   {\n    Thread.Sleep((int)delay.Value.TotalSeconds); // sleep or other\nretry = true;\n   }\n\n} while (retry); \n</pre>\n\n<h3>ユーザーにアカウントの選択を強制する</h3>\n\n<p>複数の個人 ID、プロフェッショナル ID、および組織 ID を使用するユーザーが増えています。 アプリケーションで、使用する ID をユーザーが選択するユース ケースがある場合があります。 このようなユース ケースを有効にするために、相互作用をサポートするプラットフォーム (デスクトップ、WinRT、Xamarin iOS、Xamarin Android) の <em>PromptBehavior</em> 列挙に新しい値 <em>SelectAccount</em> を追加しました。 これを使用すると、既にログインしている場合でも、キャッシュ参照をバイパスし、UI を直接表示する場合でも、アプリ&rsquo; ユーザーにアカウントの選択を強制します。</p>\n\n<p><em>PromptBehavior</em> を使用している可能性があります。<em>常</em>に過去に、トークン キャッシュをバイパスし、ユーザー インターフェイスを表示します。 <em>PromptBehavior</em>。<em>SelectAccount</em> は、使用可能なユーザーをタイルとして表示するようにAzure ADに指示し、ユーザーに再度サインインを強制しないためです (Cookie が使用可能であると仮定すると、ユーザーとAzure ADの間の相互作用がブラウザーで発生することを覚えておいてください)。 タイルが存在しても、シングル サインオン エクスペリエンスは保証されません。動作は、ライブラリ&rsquo;の purview の外部で完全に管理された Cookie の有効期間によって決まります。</p>\n\n<h3>アプリケーションで条件付きアクセス (およびその他の要求の課題) を処理できるようにする</h3>\n\n<p>ほとんどの <a href=\"https://github.com/Azure-Samples?utf8=%E2%9C%93&amp;q=azure-active-directory\">サンプル</a> をシンプルに保つように努めますが、エンタープライズ対応アプリケーションを作成する場合は、エラー処理にもう少し労力を加える必要があります。 そのため、ADAL.NET 3.16.0 では、アプリケーションが追加のリソースにアクセスすることをユーザーに受け入れるか、多要素認証を実行できるようにする必要がある場合に、Azure ADから送信された要求チャレンジを処理できます。 ADAL.NET 3.17.0 では、不足している要求を取得できるように、API 呼び出し元 <em>HttpRequestWrapperException</em> を <em>AdalClaimChallengeException</em> の内部例外として渡すことで、この機能を有効にしました。 その後、これらの追加の要求を、新しい要求メンバーを持つ acquireToken オーバーライドに渡すことができます。</p>\n\n<p>次のコード スニペットは、 <a href=\"https://github.com/Azure-Samples/active-directory-dotnet-webapi-onbehalfof-ca/blob/master/TodoListService/Controllers/AccessCaApiController.cs#L88-L98\">active-directory-dotnet-webapi-onbehalfof-ca</a> サンプルから抽出されています。 これは、TodoList サービス (機密クライアント) がAzure ADから受け取った要求チャレンジと、そのチャレンジがクライアントに伝達され、必要なユーザー操作 (たとえば、2 要素認証) を行えるようにする方法を示しています。</p>\n\n<pre class=\"prettyprint\">\ntry\n{\n    result = await authContext.AcquireTokenAsync(caResourceId, clientCred,\n                                                 userAssertion);\n}\ncatch (AdalClaimChallengeException ex)\n{\n    HttpResponseMessage myMessage = new HttpResponseMessage \n    { StatusCode = HttpStatusCode.Forbidden, ReasonPhrase = INTERACTION_REQUIRED,\n      Content = new StringContent(ex.Claims) };\n    throw new HttpResponseException(myMessage);\n}\ncatch (AdalServiceException ex)\n{\n  &hellip;\n</pre>\n\n<p>クライアント側 (TodoListClient) では、TodoList サービスを呼び出し、さらに多くの要求でトークンを要求するときにこのチャレンジを受け取るコードは次のとおりです。</p>\n\n<pre class=\"prettyprint\">\n// We successfully got a token.\nhttpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(&quot;Bearer&quot;, result.AccessToken);\n\n// while calling the API.\nHttpResponseMessage response = await httpClient.GetAsync(todoListBaseAddress \n                                                         + &quot;/api/AccessCaApi&quot;);\n\nif (response.StatusCode == System.Net.HttpStatusCode.Forbidden \n    &amp;&amp; response.ReasonPhrase == INTERACTION_REQUIRED)\n {\n     // We need to re-request the token to account for a Conditional Access Policy\n     String claimsParam = await response.Content.ReadAsStringAsync();\n\n    try\n    {\n     result = await authContext.AcquireTokenAsync(todoListResourceId, clientId,\n                     redirectUri, new PlatformParameters(PromptBehavior.Always), \n                     new UserIdentifier(displayName,\n                                        UserIdentifierType.OptionalDisplayableId),\n                     extraQueryParameters:null, \n                     claims: claimsParam);\n     &hellip;\n</pre>\n\n<p>詳細については、<a href=\"https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-conditional-access-developer\">Azure Active Directory条件付きアクセスの開発者ガイダンス</a>と、この記事からリンクされているサンプルを参照してください。</p>\n\n<h2>操作性の向上</h2>\n\n<h3>ADAL.NET NuGet パッケージにプラットフォームごとに 1 つの DLL が含まれるようになりました</h3>\n\n<p>ADAL.NET 依存関係挿入を使用して別のプラットフォーム固有のアセンブリを動的に読み込む 1 つの共通アセンブリとしてパッケージ化されました。 これが原因で問題が発生していました (#511 など)。 ポータブル ライブラリから NuGet パッケージを参照する場合は、メイン アセンブリからプラットフォーム固有のアセンブリを参照する必要がありましたが、これはあまり直感的ではありません。</p>\n\n<p>ADAL.NET 3.17.0 以降、NuGet パッケージにはプラットフォームごとに 1 つの DLL が含まれるようになりました。</p>\n\n<p>実装の詳細に関心がある場合は、GitHubの ADAL.NET&rsquo; ソース コードを確認すると&rsquo;、ADAL.NET の<a href=\"https://github.com/AzureAD/azure-activedirectory-library-for-dotnet/blob/dev/src/Microsoft.IdentityModel.Clients.ActiveDirectory/Microsoft.IdentityModel.Clients.ActiveDirectory.csproj#L11\">マルチターゲット プロジェクト</a>に移動した&rsquo;ことがわかります。</p>\n\n<h3>一部のプラットフォームでは意味のない API を非表示にして混乱を取り除く</h3>\n\n<p><strong>WinRT Apps で使用できる ClientCredential コンストラクターは 1 つだけになりました</strong></p>\n\n<p>WinRT アプリケーションが一般にパブリック クライアント アプリケーションである場合でも、クライアント資格情報フローを使用して、ユーザーがログインしていないキオスク モードのシナリオを有効にすることもできます。 これまで、機密クライアント シナリオで使用 <em>される ClientCredential</em> クラスには、次の 2 つのオーバーライドがありました。</p>\n\n<ul>\n    <li>1 つはアプリケーション シークレット、 <em>public ClientCredential(string clientId、string clientSecret) です。</em></li>\n    <li><em>承認コード</em>を引き換えるか、ユーザー アサーションを渡すコード。</li>\n</ul>\n\n<p>WinRT アプリケーションでは、後で意味がありませんでした。 &rsquo;デスクトップ アプリケーションでのみ使用できるようになりました。</p>\n\n<p><strong>デバイス プロファイル API は、デスクトップ、.NET コア、UWP アプリでのみ使用できるようになりました</strong></p>\n\n<p>Device Profile API <em>AcquireTokenByDeviceCodeAsync(DeviceCodeResult deviceCodeResult)</em> は、<em>AcquireDeviceCodeAsync</em> のオーバーライドのいずれかを使用して以前に要求されたデバイス コードを使用して STS からセキュリティ トークンを取得します (<a href=\"https://azure.microsoft.com/en-us/resources/samples/active-directory-dotnet-deviceprofile\">テキストのみのデバイスからAzure ADによって保護されている API の呼び出し</a>を参照してください)。 <em>AcquireTokenByDeviceCodeAsync</em> は、テキストのみのデバイスではない Xamarin iOS および Xamarin Android では使用できなくなりました。 デスクトップ、.Net Core、UWP (IoT 用) アプリでのみ使用する必要があります。 これにより、 <em>AcquireDeviceCodeAsync</em> が Android と iOS でまだ使用できなかったため、一貫性が高くなります。</p>\n\n<h3>改善されたドキュメント</h3>\n\n<p>リファレンス ドキュメントで、UserPasswordCredential と AcquireToken の混乱を招くいくつかの問題を修正しました (<a href=\"https://github.com/AzureAD/azure-activedirectory-library-for-dotnet/issues/654\">654 を参照#</a>)。 また、<em>IAdalLogCallback</em> インターフェイスを実装してログ記録を有効にする方法と、外部ブローカー (Xamarin iOS/Xamarin Android の場合) と対話する方法に関する手順を使用して、readme.md ライブラリ&rsquo;を更新しました。</p>\n\n<h2>プライバシーとパフォーマンスの向上</h2>\n\n<p>ご存知のように、 <em>LoggerCallbackHandler</em> に割り当てることで、ロガー ADAL.NET ログ記録をアクティブ化できます。 コールバックは、 <em>IAdalLogCallback </em>インターフェイスを実装するクラスのインスタンスです。 これを行い、詳細情報を表示することを選択すると、ADAL.Net がAzure ADに要求を送信しているときに、2 つのメッセージが表示されます。</p>\n\n<ul>\n    <li><em>&ldquo;完全な URL への &lsquo;移動&rsquo;&rdquo;</em></li>\n    <li><em>&ldquo;完全な URL に &lsquo;移動しました&rsquo;&rdquo;</em></li>\n</ul>\n\n<p><em>完全&lsquo;な URL&rsquo;</em> は、Azure ADに送信された完全な URL です。 プロンプトの動作によっては、ユーザーのユーザー プリンシパル名 (UPN) などの個人情報も含まれます。</p>\n\n<p>完全な URL をログに記録しなくなったので、プライバシーが向上しました。</p>\n\n<p>Xamarin iOS プラットフォームに固有のメモリ リークを修正することで、パフォーマンスも向上しました。</p>\n\n<h2>最後に</h2>\n\n<p>いつも通り、&rsquo;あなたのフィードバックを聞くのが大好きです。 どうぞ：</p>\n\n<ul>\n    <li>ADAL タグを使用して <a href=\"https://stackoverflow.com/questions/tagged/adal\">Stack Overflow</a> について&nbsp;質問します。</li>\n    <li><a href=\"https://github.com/AzureAD/azure-activedirectory-library-for-dotnet/issues\">ADAL.Net オープンソース リポジトリのGitHubの問題</a>を使用してバグを報告したり、機能を要求したりします</li>\n    <li><a href=\"https://feedback.azure.com/forums/169401-azure-active-directory\">[ユーザー音声] ページ</a>を使用して推奨事項やフィードバックを提供する</li>\n</ul>\n"
}