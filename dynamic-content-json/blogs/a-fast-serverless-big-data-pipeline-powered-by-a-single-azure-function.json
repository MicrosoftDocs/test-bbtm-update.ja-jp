{
    "Slug": "a-fast-serverless-big-data-pipeline-powered-by-a-single-azure-function",
    "Title": "単一の Azure 関数を利用した高速、サーバーレス、ビッグ データ パイプライン",
    "Summary": "A single Azure function is all it took to fully implement an end-to-end, real-time, mission critical data pipeline. And it was done with a serverless architecture. Serverless architectures simplify the building, deployment, and management of cloud scale applications.",
    "Content": "<p>単一の Azure 関数は、エンドツーエンドのリアルタイムのミッション クリティカルなデータ パイプラインを完全に実装するために必要なすべてです。 そして、 <a href=\"https://azure.microsoft.com/en-us/overview/serverless-computing/?WT.mc_id=ms-docs-kbaroni\" target=\"_blank\">それはサーバーレス</a> アーキテクチャで行われました。 サーバーレス アーキテクチャにより、クラウド スケール アプリケーションの構築、デプロイ、管理が簡素化されます。 サーバーの調達、構成、管理などのデータ インフラストラクチャを心配する代わりに、データ エンジニアはエンド ツー エンドで高度に機能するデータ パイプラインを確保するために必要なタスクに集中できます。</p>\n\n<p>このブログでは、Azure 関数と、1 日あたり 800 万件を超えるトランザクションを処理するデータ インジェスト パイプラインを効率的に調整する方法について説明します。</p>\n\n<h2>シナリオ</h2>\n\n<p>ある大手銀行は、携帯電話の銀行アプリケーションを通じて送信された不正な取引を検出するソリューションを構築したいと考えていました。 このソリューションには、ビッグ データ パイプラインアプローチが必要です。 大量のリアルタイム データがクラウド サービスに取り込まれます。クラウド サービスでは、一連のデータ変換と抽出アクティビティが発生します。 これにより、 <a href=\"https://docs.microsoft.com/en-us/azure/machine-learning/team-data-science-process/create-features/?WT.mc_id=ms-docs-kbaroni\" target=\"_blank\">特徴</a> データ セットが作成され、高度な分析が使用されます。 銀行にとって、パイプラインは非常に高速でスケーラブルで、各トランザクションのエンドツーエンドの評価を 2 秒未満で完了する必要がありました。</p>\n\n<p>銀行&rsquo;の複数のアプリケーション ゲートウェイからのテレメトリ。複雑な JSON ファイルに埋め込みイベントとしてストリームインします。 インジェスト テクノロジはAzure Event Hubs。 各イベントはイベント ハブに取り込み、複数の個々のトランザクションに解析されます。 各トランザクションから属性が抽出され、不正行為が評価されます。 サーバーレス アーキテクチャは、次の Azure サービスから構築されています。</p>\n\n<ul>\n <li><a href=\"https://azure.microsoft.com/en-us/services/event-hubs/?WT.mc_id=ms-docs-kbaroni\" target=\"_blank\">Azure Event Hubs</a></li>\n <li><a href=\"https://azure.microsoft.com/en-us/services/functions/?WT.mc_id=ms-docs-kbaroni\" target=\"_blank\">Azure Functions</a></li>\n <li><a href=\"https://studio.azureml.net/?WT.mc_id=ms-docs-kbaroni\" target=\"_blank\">Azure Machine Learning Studio</a></li>\n <li><a href=\"https://azure.microsoft.com/en-us/services/sql-database/?WT.mc_id=ms-docs-kbaroni\" target=\"_blank\">Azure SQL Database</a></li>\n <li><a href=\"https://azure.microsoft.com/en-us/services/cosmos-db/?WT.mc_id=ms-docs-kbaroni\" target=\"_blank\">CosmosDB</a></li>\n</ul>\n\n<h2>パイプライン アーキテクチャ</h2>\n\n<p>1 つの Azure 関数を使用して、アクティビティのパイプライン全体を調整および管理しました。 次の図は、Azure Functions パイプライン アーキテクチャを示しています。</p>\n\n<ul>\n <li>エンタープライズ システム バスは、Event Hub に到着した JSON ファイルで銀行トランザクションを送信します。 到着すると、取り込まれたファイルを検証して解析するための応答がトリガーされます。</li>\n <li>SQL ストアド プロシージャが呼び出されます。 この手順では、JSON メッセージからデータ要素を抽出し、顧客プロファイルとアカウント プロファイルで集計して特徴セット (機械学習モデルの入力) を生成します。 集計されたメッセージは JSON ファイルとして書式設定されます。</li>\n <li>検証された JSON メッセージは、Cosmos DB に書き込まれます。</li>\n <li>機械学習モデルが呼び出され、トランザクションの評価とスコア付けを行います。</li>\n <li>不正スコアは、ケース管理ソリューションに統合するためにオンプレミス API にポストバックされます。</li>\n</ul>\n\n<p>&nbsp;<a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/416c10f2-3876-48da-bba3-f3f6d993a334.png\"><img alt=\"image\" border=\"0\" height=\"226\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/78320868-0fa7-4f1c-b0eb-3d3a68ef52bc.png\" style=\"border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;\" title=\"イメージ\" width=\"377\"></a></p>\n\n<p align=\"center\"><em>図 1: Azure 関数パイプラインのアーキテクチャ</em>&nbsp;</p>\n\n<h2>10 ステップのパイプライン</h2>\n\n<p>Azure 関数は C# で記述されており、次の図に示す 10 個のメソッドで構成されています。&nbsp; メソッドには、次のものが含まれます。</p>\n\n<p>1. イベント ハブがイベントを受信すると、メソッドがトリガーされます。</p>\n\n<pre>\npublic static void Run(string myEventHubMessage, ICollector&lt;string&gt; resultsCollection, TraceWriter log)</pre>\n\n<p>2. メッセージが処理され、JSON が検証されます。</p>\n\n<pre>\nprivate static void ProcessInitialMessageFromEventHub(List&lt;string&gt; jsonResults, string cnnString, TelemetryClient appInsights, dynamic d)</pre>\n\n<p>3.SQL コマンドを実行してメッセージ イベントを挿入&nbsp;するコードを呼び出します。</p>\n\n<pre>\nprivate static bool CheckRequestTypeForValidMessage(dynamic d)</pre>\n\n<p>4.JSON メッセージが有効な場合は、後でクエリを実行するために、それを DB Cosmosに保存します。</p>\n\n<pre>\nprivate static void SaveDocDb(string json, TraceWriter log)</pre>\n\n<p>5. JSON が解析されたら、関連する属性を抽出します。</p>\n\n<pre>\nprivate static string ProcessSQLReturnedFeaturesForAML(TraceWriter log, List&lt;string&gt;, jsonResults, TelemetryClient appInsights)</pre>\n\n<p>6. ストアド プロシージャを実行して、機械学習モデルへの入力となる機能を作成します。</p>\n\n<pre>\nprivate static string SendDataToStoredProc(dynamic d, SqlCommand spCommand, dynamic t, TelemetryClient appInsights, TransactionType transactionTypeEnum = TransactionType.Other, dynamic responseData = null)</pre>\n\n<p>7.Azure ML サービス エンドポイントへの呼び出しを呼び出します。 Azure MLからスコアを取得します。 入力パラメーターを渡します。</p>\n\n<pre>\nprivate static string CallAzureMl(dynamic d, TraceWriter log, HttpClient client)</pre>\n\n<p>8.ML サービスはスコアを返し、その後処理されます。</p>\n\n<pre>\npublic static List&lt;string&gt; GetScoresFromAzureMl(string myEventHubMessage, TraceWriter log, TelemetryClient appInsights, HttpClient client)</pre>\n\n<p>9. オンプレミス システムを呼び出し、メッセージを引数として渡します。</p>\n\n<pre>\npublic static List&lt;string&gt; ProcessMessagesIntoEsb(TraceWriter log, string cnnString, TelemetryClient appInsights, string cardNumber, string accountNumber, List&lt;string&gt;esbReturnMessages)</pre>\n\n<p>10. スコアはしきい値に対して評価され、オンプレミスのケース管理システムに渡す必要があるかどうかを決定します。</p>\n\n<pre>\npublic static string CheckScoreAndProcessEsbMessages(string&gt; myEventHubMessage, TraceWriter log, SqlCommand spCommand, TelemetryClient appInsights, string cardNumber, string accountNumber)</pre>\n\n<p>次の図は&nbsp; 、コード内のタスクごとに 1 つずつ、10 ブロックの垂直セットとしてのロジックを示しています。</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2bbd46f9-71cb-4671-a788-3ea5bbda15ae.png\"><img alt=\"image\" border=\"0\" height=\"367\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/03699ea0-5c37-41df-8044-277cf135ed41.png\" style=\"border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;\" title=\"イメージ\" width=\"322\"></a></p>\n\n<p align=\"center\"><em>図 2: Azure 関数パイプライン フロー</em>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<h2>パイプラインのスケーラビリティ</h2>\n\n<p>パイプラインは、受信 JSON ファイルの極端なバーストに対応する必要があります。 各ファイルを個別のトランザクションに解析し、各トランザクションを処理して不正行為を評価する必要があります。 さまざまな構成パラメーターを試した後、Azure 関数を必要に応じてスケーリングし、必要な時間内にメッセージとトランザクションの量を処理できるようにするために役立ついくつかの設定がありました。&nbsp;</p>\n\n<ul>\n <li><a href=\"https://docs.microsoft.com/en-us/azure/monitoring-and-diagnostics/monitoring-autoscale-get-started?toc=%2fazure%2fapp-service%2ftoc.json/?WT.mc_id=ms-docs-kbaroni\" target=\"_blank\">Azure Autoscale</a> は、Azure Functionsなどのクラウド サービスに組み込まれた機能です。 これはルールベースであり、定義されたしきい値に基づいてAzure Functionsのようなサービスをスケールアップまたはスケールダウンする機能を提供します。 既定では、Event Hubs に取り込まれるデータの量のため、Azure Functions サービスのスケーリングが速すぎて、それ自体のインスタンスが多すぎます。 その結果、Event Hub パーティションのロックの問題が発生し、スループットに大きな影響を与えました。 自動スケール機能を試した後、Functions サービスの設定は少なくとも 1 つと最大 4 つのインスタンスに設定されました。</li>\n <li>Azure 関数のパフォーマンスとスループットを確保するには、次の 2 つの Event Hubs 設定が重要でした。<br>\n <strong>maxBatchSize</strong>: ユーザーが受信ループごとの処理を受け入れる最大イベント数を取得または設定します。 この数は、イベント ハブごとのパーティション レベルにあります。<br>\n <strong>prefetchCount</strong>: 現在所有しているパーティション内のレシーバーがアクティブにキャッシュするイベントの数を取得または設定します。 このプロパティの既定値は 300 です。</li>\n</ul>\n\n<p>さまざまな設定を試した後、このソリューションの最適な構成は次のようになります。</p>\n\n<pre>\n// Configuration settings for &#39;eventHub&#39; triggers. (Optional)\n   &quot;eventHub&quot;: {\n    // The maximum event count received per receive loop. The default is 64.\n    &quot;maxBatchSize&quot;: 10,\n    // The default PrefetchCount that will be used by the underlying EventProcessorHost.\n    &quot;prefetchCount&quot;: 40,\n    // The number of event batches to process before creating an EventHub cursor   checkpoint.\n    &quot;batchCheckpointFrequency&quot;: 1\n   },</pre>\n\n<h2>推奨される次の手順</h2>\n\n<p>サーバーレス アーキテクチャでは、データ エンジニアリング チームはデータ フロー、アプリケーション ロジック、およびサービス統合に集中できます。&nbsp;リアルタイムのサーバーレス データ パイプラインを設計していて、他のサービスとの統合または継続的インテグレーションを通じてデプロイするための独自の方法を柔軟にコーディングする場合は、Azure Functionsを使用してパイプラインを調整および管理することを検討してください。 Azure 関数の詳細については、次のリソースを参照してください。</p>\n\n<ul>\n <li><a href=\"https://docs.microsoft.com/en-us/azure/azure-functions/functions-best-practices/?WT.mc_id=ms-docs-kbaroni\" target=\"_blank\">Azure 関数のパフォーマンスと信頼性を最適化します</a>。</li>\n <li><a href=\"https://docs.microsoft.com/en-us/azure/monitoring-and-diagnostics/monitoring-autoscale-get-started?toc=%2fazure%2fapp-service%2ftoc.json/?WT.mc_id=ms-docs-kbaroni\" target=\"_blank\">Azure で自動スケーリングを使用して概要</a>します。</li>\n <li>このブログで参照されている銀行詐欺ソリューションの完全なアーキテクチャについては、 <a href=\"https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fdownload.microsoft.com%2Fdownload%2F0%2F1%2F5%2F0150425C-14C7-41F4-97EA-3DE57B678C51%2FIndSG_FraudDetection.pdf&amp;data=02%7C01%7C%7Cdb1f75f50e814905327b08d60c53078e%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C636709948072813252&amp;sdata=sVMHwEWyZ%2FkpPWgNkfgmXk5TfB0tzOvkMabszoZVuH8%3D&amp;reserved=0\" target=\"_blank\">モバイル 銀行詐欺ソリューション ガイド</a>を参照してください。</li>\n</ul>\n\n<p>このブログでのコラボレーション <a href=\"https://www.linkedin.com/in/cedza/\" target=\"_blank\">のために、セドリック・ラブシャーニュ</a>、 <a href=\"https://www.linkedin.com/in/chris-cook-49b88457/\" target=\"_blank\">クリス・クック</a>、 <a href=\"https://www.linkedin.com/in/eujon-sellers/\" target=\"_blank\">ユージョン・セラー</a> に感謝します。</p>\n"
}