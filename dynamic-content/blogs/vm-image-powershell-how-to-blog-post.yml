### YamlMime:Yaml
ms.openlocfilehash: 5d0db355477fe76d7908e0ece35b6fe6e3026de9
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139893786"
Slug: vm-image-powershell-how-to-blog-post
Title: VM イメージ PowerShell の 「方法」ブログ投稿
Summary: >-
  エディター注: この投稿は、Kay Singh、Program Manager、Microsoft Azure Engineering を使用して作成されています


  最初のブログ記事で説明した通り、 で VM イメージを使用する方法について説明しました。
Content: "エディター注: この投稿は、Kay Singh、Program Manager、Microsoft Azure Engineering を使用して作成されています\n\n最初のブログ記事で約束した通り、PowerShell で VM イメージを使用する方法について説明します。コンピューティング コマンドレットを担当する同僚の Kay(PowerShell PM) に、いくつかの詳細の説明に参加して欲しいと言いました。VM イメージを少し使い回す機会を得て、数日間、このブログ投稿を予想していただけたと思います。わかったわかった。。。 私はここで自分の仕事を気に入っている可能性があります。\n\n前に触れたので、VM イメージは OS イメージの後継であり、2 つのエンティティには多くの類似点があります。VM イメージ機能の開発に合って、OS イメージをカプセル化すると考える可能性があります。VM イメージと OS イメージは 2 つの独立したエンティティとして説明しますが、PowerShell は単一の \"über\" イメージ エンティティで動作します。そのため、OS イメージを使用する際に使い慣れた PowerShell コマンドレットの多くは、VM イメージに適用されます。\n\n開始するには、OS イメージ PowerShell の知識を簡単に確認しましょう。ご覧のように、OS イメージを作成、一覧表示、削除するには、次の PowerShell スニペットを使用できます。\n<pre class=\"prettyprint\">Save-AzureVMImage –ServiceName \"myServiceName\" –Name \"myVMtoCapture\" –ImageName \"myAwesomeOSImage\" –ImageLabel \"This is my OS Image\"\n\nGet-AzureVMImage\n\nRemove-AzureVMImage –ImageName \"myAwesomeOSImage\"</pre>\n新しく作成した OS イメージから VM をデプロイするには、次の PowerShell スニペットを使用します。\n<pre class=\"prettyprint\">New-AzureQuickVM –Windows –Location \"West US\" –ServiceName \"MySvc1\" –Name \"myVM1\" –InstanceSize \"Medium\" –ImageName \"myAwesomeOSImage\" –AdminUsername \"admin\"–Password \"adminPassword123\" -WaitForBoot</pre>\nまたは、\n<pre class=\"prettyprint\">New-AzureVMConfig -Name \"myVM1\" -InstanceSize \"Medium\" -ImageName \"myAwesomeOSImage\" |\n\nAdd-AzureProvisioningConfig -Windows -AdminUsername \"admin\" -Password \"adminPassword123\" |\n\nNew-AzureVM –ServiceName \"MySvc1\" -WaitForBoot</pre>\nここまでのすべてが最新の情報に更新され、VM イメージの使用を開始できます。\n<h4>キャプチャする VM の作成</h4>\nVM イメージ固有の部分を開始する前に、仮想マシンを使用する必要があります。2 つのデータ ディスクを使用して 2014 年 2 月に実行されているSQL Serverをデプロイします。2014 年 4 月のリリースの SQL Server RTM DataWarehousing で仮想マシンを作成するためのスクリプトは次のとおりです。\n<pre class=\"prettyprint\">$img = Get-AzureVMImage -ImageName \"fb83b3509582419d99629ce476bcb5c8__SQL-Server-2014RTM-12.0.2000.8-DataWarehousing-ENU-WS2012R2-AprilGA\"\n\n$user = \"admin\"\n$pass = \"adminPassword123\"\n\n$myVM = New-AzureVMConfig -Name \"myVMToCapture2\" -InstanceSize \"Large\" -ImageName $img.ImageName `\n        | Add-AzureProvisioningConfig -Windows -AdminUsername $user -Password $pass `\n        | Add-AzureDataDisk -CreateNew -DiskSizeInGB 10 -DiskLabel \"DataDisk1\" -LUN 0 `\n        | Add-AzureDataDisk -CreateNew -DiskSizeInGB 10 -DiskLabel \"DataDisk2\" -LUN 1\n\nNew-AzureVM -ServiceName \"MySvc2\" -VMs $myVM -Location \"West US\" -WaitForBoot</pre>\n<h4>一般化または特殊化された VM イメージとしての VM のキャプチャ</h4>\n仮想マシンをキャプチャする前に、一般化されたキャプチャと特殊化されたキャプチャの 2 つを決定する必要があります。前のブログ記事で説明したように、一般化された VM イメージは、同様の仮想マシンをすばやくスタンプアウトする \"モデル\" として使用することを意図しています。OS イメージでも同様の機能を使用できます。特殊化された VM イメージは新しいイメージであり、問題が発生して仮想マシンを使用しない可能性があるタスクを実行する前に、既知の適切な時点に VM をデプロイするための \"スナップショット\" として使用することを意図しています。\n\nキャプチャ用に仮想マシンを準備するには、いくつかの追加の手順を実行する必要があります。一般化された Windows Server VM イメージをキャプチャするには、「Microsoft Azure Server を実行している仮想マシンのイメージをキャプチャする方法」に記載されている手順に<a href=\"https://azure.microsoft.com/en-us/documentation/articles/virtual-machines-capture-image-windows-server/\">従Windowsできます</a>。Linux VM イメージをキャプチャするには、「Linux を実行している仮想マシンのイメージをキャプチャする方法」という記事 <a href=\"https://azure.microsoft.com/en-us/documentation/articles/virtual-machines-linux-capture-image/\">に従います</a>。\n\n次に、仮想マシンを VM イメージとして実際にキャプチャします。 キャプチャ プロセスは、OS イメージのプロセスと似ています。 既存の Save-AzureVMImage コマンドレットを使用する必要がありますが、OS イメージと VM イメージのどちらをキャプチャするか決定する新しいパラメーターを含める必要があります。\n\nまず、一般化された VM イメージを myFirstVMImage と呼んでキャプチャしましょう。\n<pre class=\"prettyprint\">Save-AzureVMImage –ServiceName \"mySvc2\" –Name \"MyVMToCapture2\" –ImageName \"myFirstVMImage\" –OSState \"Generalized\" -Verbose</pre>\n代わりに特殊化された VM イメージをキャプチャする場合は、次のスニペットを使用できます。\n<pre class=\"prettyprint\">Save-AzureVMImage –ServiceName \"mySvc2\" –Name \"MyVMToCapture2\" –ImageName \"myFirstVMImageSP\" –OSState \"Specialized\" -Verbose</pre>\nOSState パラメーターを使用すると、VM イメージをキャプチャする意図が指定されます。このパラメーターを使用しない場合、このコマンドレットは OS イメージをキャプチャします。OS イメージは常に \"一般化\" と見なされます。OSState パラメーターは必要ではありません。\n\n1 つのヒントとして、同じ名前の 2 つのイメージ (VM イメージと OS イメージ) を作成したことがないことを強くお勧めします。これは、Microsoft Azure プラットフォームで許可されますが、プラットフォームで意図を特定できないので、問題が発生する可能性があります。\n\n重複がどのように発生する可能性があるのか疑問に思うかもしれません。あるクライアント (PowerShell など) から VM イメージを作成し、別のクライアント (ポータルなど) から OS イメージを作成すると、重複する名前が発生する可能性があります。OS イメージと VM イメージの作成専用に PowerShell を使用する場合、Save-AzureVMImage コマンドレットは名前付けについて検証し、同じ名前の VM イメージと OS イメージを作成するとエラーをスローします。\n<h4>List VM Images</h4>\n前に再適用した場合と同様に、Get-AzureVMImageコマンドレットを使用すると、ユーザーと公開された OS イメージの両方が一覧表示されます。でもちょっと待ってください。ここでコマンドレットを実行すると、キャプチャした VM イメージが実際に表示されます。信じられない場合は、次の PowerShell スニペットをお試しください。\n<pre class=\"prettyprint\">Get-AzureVMImage | Select -Property Label, ImageName | Format-Table -Wrap</pre>\n既存の Get-AzureVMImageは、OS イメージだけでなく、ユーザーと公開された VM イメージも返します。VM イメージのみを一覧表示するには、DataDiskConfiguration など、VM イメージにのみ適用されるプロパティでフィルター処理できます。\n<pre class=\"prettyprint\">Get-AzureVMImage | where {(gm –InputObject $_ -Name DataDiskConfigurations) -ne $null} | Select -Property Label, ImageName</pre>\n<h4>VM イメージの削除</h4>\nVM イメージの削除は、OS イメージの削除と同じです。\n<pre class=\"prettyprint\">Remove-AzureVMImage –ImageName $img –DeleteVHD;</pre>\n同じ名前のイメージが 2 つある場合、プラットフォームで意図を判断できないという言及を覚えていますか?この状況では、間違ったイメージを削除しないように、上記のコマンドレットでエラーが発生します。OS イメージを削除する場合は、ポータルまたは PowerShell から Invoke-Rest URI メソッドを使用して、アプリを直接呼び出REST APIがあります。VM イメージを削除するには、PowerShell から Invoke-Rest URI メソッドを使用することもできます。イメージの 1 つが削除された後、もう一度 Remove-AzureVMImage使用できます。この状況に入った場合に備え、次の PowerShell スニペットを使用して VM イメージを削除し、次Invoke-RestMethodします。\n<pre class=\"prettyprint\"># Delete VM Image API Documentation - https://msdn.microsoft.com/en-us/library/azure/dn499769.aspx \n#-------------------------------------------------------------------------------------#\n# Method | Request URI \n#-------------------------------------------------------------------------------------#\n# DELETE | https://management.core.windows.net/&lt;subscription-id&gt;/services/vmimages/&lt;image-name&gt;?comp=media \n#-------------------------------------------------------------------------------------# \n\n$cert = (Get-AzureSubscription).Certificate.Thumbprint \n$subid =  (Get-AzureSubscription).SubscriptionId \n$vmimgname = ‘myFirstVMImage’\n$uri = \"https://management.core.windows.net/$subid/services/vmimages/$vmimgname\" + \"?comp=media\" \n\n$header = @{\"x-ms-version\" = \"2014-02-01\";}\n\nInvoke-RestMethod -Uri $uri -Method Delete -ContentType \"application/xml\" -Headers $header -CertificateThumbprint $cert</pre>\n<h4>一般化または特殊化された VM イメージからの VM のデプロイ</h4>\n一般化された VM イメージからのデプロイは、両方のイメージが一般化されるのと同じ OS イメージからのデプロイに似ています。主な違いは、VM イメージからデプロイするときにデータ ディスクを追加できないことです。VM イメージには、最初に仮想マシンに追加するデータ ディスクが既に含まれる必要があります。仮想マシンがデプロイされた後は、任意の VM と同様にディスクを接続またはデタッチできます。\n\nRemove-AzureVMImage と同様に、同じ名前の 2 つのイメージがある場合、プラットフォームはイメージの解決を試みています。参照先のイメージが OS イメージか VM イメージかを一意に判断できない場合は、エラーになります。\n\n次の PowerShell スニペットは、前に作成した VM イメージを使用して、myFirstVMImage と呼ばれる大規模な仮想マシン インスタンスをデプロイします。\n<pre class=\"prettyprint\">$img = Get-AzureVMImage -ImageName \"myFirstVMImage\"\n\n$user = \"admin\"\n$pass = \"adminPassword123\"\n\n$myVM = New-AzureVMConfig -Name \"VMImageVM\" -InstanceSize \"Large\" -ImageName $img.ImageName `\n       | Add-AzureProvisioningConfig -Windows -AdminUsername $user -Password $pass\n\nNew-AzureVM -ServiceName \"VMImageCloudService\" -VMs $myVM -Location \"West US\" -WaitForBoot</pre>\nここでは、特殊化された VM イメージからデプロイする方法を見てみしましょう。これは少し異なっています。この場合、イメージは一般化されていないので、プロビジョニング構成は必要ではありません。特殊化された VM イメージの使用は、ディスクの使用と似ています。ユーザー名とパスワードは、元の (キャプチャされた) 仮想マシンと同じになります。 スクリプト スニペットを次に示します。\n<pre class=\"prettyprint\">$img = Get-AzureVMImage -ImageName \"myFirstVMImageSP\"\n\n$myVM = New-AzureVMConfig -Name \"VMImageVMSP\" -InstanceSize \"Large\" -ImageName $img.ImageName `\n| Add-AzureProvisioningConfig -Windows\n\nNew-AzureVM -ServiceName \"VMImageCloudService\" -VMs $myVM -Location \"West US\" -WaitForBoot</pre>\n長すぎますか? 読み取りを行ってない場合 主なポイントをまとめ、次に示します。<em></em>\n<ul>\n <li>VM イメージは 'Generalized' または 'Specialized' にできます。OS イメージは \"Generalized\" のみです</li>\n <li>省略可能な –OSState パラメーターを使用すると、 コマンドレットを使用して OS イメージではなく VM イメージを保存Save-AzureVMImageされます</li>\n <li>Save-AzureVMImageでは、同じ名前の VM イメージまたは OS イメージのキャプチャは許可されませんが、複数のクライアントを使用している場合は注意が必要です。</li>\n <li>Get-AzureVMImage、OS イメージと VM イメージが返されます。</li>\n <li>Remove-AzureVMImageはユーザーの意図を判断できないので、名前が OS イメージと VM イメージの両方を参照している場合、このコマンドレットは削除をブロックします</li>\n</ul>\nPowerShell チュートリアルが役に立つ場合があります。ご質問やご意見がある場合は、お問い合わせください。\n\nすぐにもう一度ご連絡ください。...\n\nクリストインと Kay\n\n2014 年 6 月 16 日の更新: PowerShell スニペットを使用して OS イメージをフィルター処理Get-AzureVMImage変更されました。"
