### YamlMime:Yaml
ms.openlocfilehash: 9f145675df4b73688be73e746dd0b06c9df8c785
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139896259"
Slug: automating-sql-server-vm-configuration-using-custom-script-extension
Title: カスタム スクリプトSQL Serverを使用した VM 構成の自動化
Summary: Azure VM カスタム スクリプト拡張機能を使用すると、PowerShell の機能を活用して、さまざまな構成自動化シナリオを実装できます。 この記事では、カスタム スクリプト拡張機能を使用して 2014 SQL Serverを構成するサンプル シナリオを示します。
Content: "Azure <a href=\"https://azure.microsoft.com/blog/2014/04/24/automating-vm-customization-tasks-using-custom-script-extension/\">VM カスタム スクリプト拡張機能</a> を使用すると、ストレージ アカウントから (サポート ファイルと共に) PowerShell スクリプトをダウンロードして実行できます。 この機能は単純に聞こえますが、PowerShell の機能により、さまざまな VM カスタマイズ シナリオを実現するための柔軟な方法で VM 構成を自動化できます。 このブログでは、カスタム スクリプト拡張機能を使用して、Azure VM イメージ ギャラリーから作成された SQL Server 2014 VM をカスタマイズする手順について説明します。 SQL PowerShell スクリプトを使用して <a href=\"https://msdn.microsoft.com/en-us/library/dn449496.aspx\">SQL Server Managed Backup を Windows Azure</a> に有効にし、SQL Server 2014 データベースを <a href=\"https://azure.microsoft.com/en-us/documentation/articles/storage-dotnet-how-to-use-blobs/#what-is\">Azure Blob Storage</a> サービスにバックアップできます。\n\n&nbsp;\n<h3>SQL Server構成スクリプト</h3>\n次のコードリストに示すように、構成スクリプトは簡単です。 [Azure ストレージ アカウント] <b><i>と [Azure</i></b> ストレージ アカウント キー] を <b><i>Azure</i></b> ストレージ資格情報に置き換える必要があります。 このスクリプトを [CustomScriptSQLPS.ps1 <strong> ] として保存します。</strong>\n<pre class=\"prettyprint\">#import SQL Server powershell module\nimport-module  sqlps -DisableNameChecking\n\n#global variables - replace storage account name and key\n$credentialName = \"AzureStorageCredential_\"+(RANDOM)\n$storageAccountName = \"[your Azure storage account]\"\n$storageAccountKey = \"[your Azure storage account key]\"\n\n# start SQL Agent Service                                                                \nwrite-host \"Starting SQL Server Agent service ...\"\nStart-Service  sqlserveragent -verbose\n\nCD SQLSERVER:SQL\\$env:COMPUTERNAME\\DEFAULT\n\nwrite-host \"Creating SQL credential ...\"\n$secureString = convertto-securestring $storageAccountKey  -asplaintext -force    \n\n# Create Credential\nNew-SqlCredential –name $credentialName –Identity $storageAccountName –secret $secureString \n\n$encryptionOption = New-SqlBackupEncryptionOption -NoEncryption\n\nwrite-host \"Enabling Managed SQL Server Backup...\"\n\nget-sqlsmartadmin | set-sqlsmartadmin -BackupEnabled $True -BackupRetentionPeriodInDays 7 -SqlCredential $credentialName -EncryptionOption $encryptionOption \n\nwrite-host \"Managed SQL Server backup current configuration:\"\nget-sqlsmartadmin | fl</pre>\nただし、このスクリプトをカスタム スクリプト拡張機能に直接渡す方法はまだありません。 カスタム スクリプト拡張機能は <b>NTAUTHORITY\\SYSTEM</b> アカウントを使用してスクリプトを実行しますが、このアカウントには、スクリプト構成コマンドを実行するために必要SQLはありません。 これを回避するには、スクリプトを呼び出す前に管理者アカウントを偽装する個別のブートストラップ スクリプトを作成します。\n\n&nbsp;\n<h3>別の資格情報を使用してスクリプトを呼び出す</h3>\n次の内容を含むstart.ps1という名前 <b> の </b> 別のスクリプトを作成します。 説明を簡単にするために、各行に行番号を追加しました。\n<pre class=\"prettyprint\">1: $password =  ConvertTo-SecureString \"[your admin account user password]\" -AsPlainText -Force\n2: $credential = New-Object System.Management.Automation.PSCredential(\"$env:COMPUTERNAME\\[your admin account]\", $password)\n3: $command = $file = $PSScriptRoot + \"\\CustomScriptSQLPS.ps1\"\n4: Enable-PSRemoting –force\n5: Invoke-Command -FilePath $command -Credential $credential -ComputerName $env:COMPUTERNAME\n6: Disable-PSRemoting -Force</pre>\n最初の行は、管理者のパスワードをプレーン テキストからセキュリティで保護された文字列に偽装するために変換します。 もちろん、スクリプトでプレーンテキストでパスワードを使用するのもベスト プラクティスではありません。後で戻ってきます。 2 行目では、メイン スクリプトの実行に使用する資格情報が作成されます。 VM をプロビジョニングするときに選択したのと同じアカウントを使用できます。 3 行目は、メイン スクリプトへの絶対パスを取得します。 偽装された資格情報でメイン スクリプトを実行するには、リモート管理 <a href=\"https://msdn.microsoft.com/en-us/library/aa384426(v=vs.85).aspx\">(WinRM) Windows使用する必要があります</a>。 このスクリプトは、4 行目で WinRM をオンにし、使用後に WinRM をオフにします (6 行目)。 最後に、5 行目では、Credential パラメーターを受け取る <b><i>Invoke-Command</i></b> コマンドレットを使用してメイン スクリプトを <b><i>呼び出</i></b> します。\n\n&nbsp;\n<h3>カスタム スクリプト拡張機能を使用する</h3>\nこれで、両方のスクリプトをカスタム スクリプト拡張機能に渡す準備ができました。 アップロードアカウントのスクリプト コンテナー<b>に</b>両方のスクリプトを追加します。 カスタム スクリプト拡張機能<a href=\"https://azure.microsoft.com/blog/2014/04/24/automating-vm-customization-tasks-using-custom-script-extension/\"></a>の動作の詳細については、最初に参照するリンクを参照してください。特に、既定のストレージ アカウント以外の別のストレージ アカウントと、スクリプト以外の別のコンテナーを<b><i></i></b>使用する場合は、こちらをご覧ください。 次に、ワークステーションから、次のようなスクリプトを実行できます (ここでも行番号を使用)。\n<pre class=\"prettyprint\">1: $servicename = \"[cloud service that hosts the VM]\"\n2: $vmname = \"[name of the VM]\"\n3: $vm = Get-AzureVM -ServiceName $servicename -Name $vmname\n4: Set-AzureVMCustomScriptExtension -ContainerName scripts -StorageAccountName '[your storage account name]' -VM $vm -FileName 'start.ps1', 'CustomScriptSQLPS.ps1' -Run 'start.ps1' | Update-AzureVM -Verbose\n5: $status = Get-AzureVM -ServiceName $servicename -Name $vmname\n6: $result = $status.ResourceExtensionStatusList.ExtensionSettingStatus.SubStatusList | Select Name, @{\"Label\"=\"Message\";Expression = {$_.FormattedMessage.Message }} \n7: $result |fl</pre>\n上のスクリプトのキー行は 4 行目です。 これにより、カスタム スクリプト拡張機能が VM に確実にインストールされ、start.ps1と <b>CustomScriptSQLPS.ps1 </b> の両方をダウンロードし、 を実行するように拡張機能に<b> </b><b> 指示start.ps1</b>。\n<h3></h3>\n&nbsp;\n<h3>外部ファイルからパスワードを読み取る</h3>\nスクリプトを記述する場合の 1 つの良い方法は、プレーン テキストにパスワードを含めない方が良い方法です。 ここでは、パスワードの暗号化/暗号化解除に証明書を使用します。 ユーザー (または IT) がターゲット仮想マシンにプライベート キーを持つ証明書を既にデプロイし、同じ証明書の公開キーを使用して、パスワードを base-64 形式の <b>password.txt</b> ファイルに暗号化したとします。\n<pre class=\"prettyprint\">$cert = Get-ChildItem Cert:\\LocalMachine\\My\\[certificate thumbprint]\n$bytes = [Text.Encoding]::UTF8.GetBytes(\"abcdefg\")\n$encrypted = $cert.PublicKey.Key.Encrypt($bytes, $true)\n$base64 = [Convert]::ToBase64String($encrypted)\nSet-Content .\\password.txt $base64</pre>\nmakecert <a href=\"https://msdn.microsoft.com/en-us/library/azure/gg551722.aspx\">を使用して</a> 新しい管理証明書を作成する際にヘルプが必要な場合は、この <b><i>リンクを参照してください</i></b>。 このブログ記事では、Azure VM を使用して証明書をデプロイする方法について説明します。\n\nこの <b>start.ps1</b> 変更し、最初の行を次の行に置き換える必要があります。\n<pre class=\"prettyprint\">$cert = Get-ChildItem Cert:\\LocalMachine\\My\\[certificate thumbprint]\n$base64 = Get-Content .\\password.txt\n$encrypted = [Convert]::FromBase64String($base64)\n$bytes = $cert.PrivateKey.Decrypt($encrypted,$true)\n$password = [Text.Encoding]::UTF8.GetString($bytes)</pre>\n最後に、ファイル名をファイルの一覧に追加password.txtファイルがカスタム スクリプト拡張機能に配信されます。\n<pre class=\"prettyprint\">Set-AzureVMCustomScriptExtension -ContainerName scripts -StorageAccountName '[your storage account name]' -VM $vm -FileName 'start.ps1', 'CustomScriptSQLPS.ps1', 'password.txt' -Run 'start.ps1' | Update-AzureVM -Verbose</pre>\n<h3></h3>\n&nbsp;\n<h3>まとめ</h3>\nこのブログ記事では、カスタム スクリプト拡張機能を使用して 2014 年の VM をカスタマイズするSQL Serverについて説明しました。 この記事では、実際のシナリオでのカスタム スクリプト拡張機能の動作を示します。 また、この記事では、偽装やパスワード暗号化など、いくつかの一般的なスクリプトタスクについて説明します。\n<h3>謝辞</h3>\nこのブログ記事は、複数のユーザーのコラボレーションです。 マッドハン・アルムガムと Sethu Srinivasan の貢献に感謝します。"
