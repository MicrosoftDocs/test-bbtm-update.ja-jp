### YamlMime:Yaml
ms.openlocfilehash: 92271c31f73fd3a57c4de8284f5df07aa3ac213e
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139909028"
Slug: creating-a-data-stream-from-nist-manufacturing-lab-data-part-1
Title: NIST 製造ラボ データからデータ ストリームを作成する – パート 1
Summary: 業界エクスペリエンス チームは最近、既存の IoT データから分析情報を抽出するためのソリューション ガイドを公開しました。 このソリューションは、次の高レベルコンポーネントで構成されます。
Content: >-
  <p>業界エクスペリエンス チームは最近、既存 <a href="https://docs.microsoft.com/azure/industry/manufacturing/extracting-insights-from-iot-data?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">の</a> IoT データから分析情報を抽出するためのソリューション ガイドを公開しました。 このソリューションは、次の高レベルコンポーネントで構成されます。</p>


  <ul>
   <li>データの取り込み</li>
   <li>ホット パスの処理</li>
   <li>コールド パスの処理</li>
   <li>分析クライアント</li>
  </ul>


  <p>これは、これらのコンポーネントを詳しく説明する一連のブログの最初の記事です。 まず、ソリューションにデータを取り込み、データ ストリームを作成します。</p>


  <h2>NIST データ</h2>


  <p>このソリューションでは、製造ラボ データを公開する米国国立標準技術技術研究所のスマート製造システムテスト 用の実験台によって公開されたデータを&rsquo;使用します。 ラボのデータを使用して、&#39;( <a href="https://smstestbed.nist.gov/vds" target="_blank">VDS) を取得します</a>。</p>


  <p>VDS は MTConnect 標準を使用して実装されます。 標準では、製造機器のセマンティック ボキャブラリが提供されます。 MTConnect エージェントと通信するプロトコルと、返されるデータのスキーマを定義します。</p>


  <h2>エージェントとそのメソッド</h2>


  <p>エージェントは、次の API 操作をサポートする HTTP エンドポイントを公開します。</p>


  <ul>
   <li><a href="https://smstestbed.nist.gov/vds/probe" target="_blank">probe</a>: デバイス、コンポーネント、サブコンポーネント、およびデータ項目の一覧を返します。</li>
   <li><a href="https://smstestbed.nist.gov/vds/current" target="_blank">current</a>: データ項目のスナップショットを返&#39;の値、またはデバイスの状態を指定します。</li>
   <li><a href="https://smstestbed.nist.gov/vds/sample" target="_blank">sample</a>: 時系列のサンプル、イベント、条件を返します。</li>
   <li><a href="https://smstestbed.nist.gov/vds/asset" target="_blank">asset</a>: このデバイスに既知の資産の最新の状態。</li>
  </ul>


  <p>このソリューションのプロトコル フローの例を次に示します。</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/3c44cc84-b7e3-4b46-b5ab-bc08c512f67b.jpg"><img alt="Extracting Insights from IoT Data - Solution Guide Figures" border="0" height="457" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/32b7cfd4-42bc-493c-a282-4a21d326031c.jpg" style="border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="IoT インサイトからのデータの抽出 - ソリューション ガイドの図" width="517"></a></p>


  <p>このソリューションでは、VDS エンドポイントをポーリングする必要があります。 データ ストリームを受け取った後、データ ストリームのデータ レコードを名前と値のペアでAzure Event Hubs。 その後、もう一方の端でストリーム処理テクノロジを使用してストリームを処理できます。</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/b9d1e1ff-5b8c-4dd7-ba1a-799387b8df1d.jpg"><img alt="Extracting Insights from IoT Data - Solution Guide Figures 2" border="0" height="305" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/efbe2f85-6e89-4d11-87ea-30276ad4133f.jpg" style="border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="IoT インサイトデータからのデータの抽出 - ソリューション ガイド図 2" width="703"></a></p>


  <h2>インジェスト コンポーネント</h2>


  <p>インジェスト コンポーネントは、次のタスクを実行します。</p>


  <ul>
   <li>VDS エンドポイントをポーリングします。</li>
   <li>生の応答を XML として Azure BLOB ストレージに保存します。</li>
   <li>名前と値のペアとタイム スタンプを使用して、階層 XML の結果をフラット データ レコード構造に変換します。</li>
   <li>各レコードを Azure Event Hub に投稿します。 メッセージの種類ごとに異なるイベント ハブが使用されます。</li>
  </ul>


  <p>インジェスト コンポーネントを実装するための多くの Azure サービス オプションがあります。 次のサービスはすべて、HTTP エンド ポイントをポーリングし、生データを中間ストレージ ソリューションに保存し、変換されたデータを Azure Event Hubs にポストできます。</p>


  <ul>
   <li><a href="https://docs.microsoft.com/azure/logic-apps/?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">Azure Logic Apps</a></li>
   <li>で実行されているカスタム コード <ul>
    <li><a href="https://docs.microsoft.com/azure/aks/?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">Azure Kubernetes Service</a></li>
    <li><a href="https://docs.microsoft.com/azure/app-service/?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">App Service</a></li>
    <li><a href="https://docs.microsoft.com/azure/container-instances/?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">Container Instances</a></li>
    <li><a href="https://docs.microsoft.com/azure/virtual-machines/windows/?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">Virtual Machines</a></li>
    <li><a href="https://docs.microsoft.com/azure/service-fabric/?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">Service Fabric</a></li>
    <li><a href="https://docs.microsoft.com/azure/azure-functions/?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">関数</a></li>
   </ul>
   </li>
  </ul>


  <p>非常に単純なワークフローを設定し、VDS エンドポイントに対していくつかの HTTP 呼び出しを行い、必要な REST 操作を呼び出して、スケジュールされた間隔でポーリングを続けるのは非常に簡単なので、<a href="https://docs.microsoft.com/azure/logic-apps/?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">Azure Logic Apps</a> を使用することを選択しました。 Azure Logic Apps、データを使用してタスク<a href="https://docs.microsoft.com/azure/connectors/apis-list?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">を実行するための</a> 200 を超えるコネクタが提供されています。 データ ストアに未加工の応答を格納する必要があるから、<a href="https://docs.microsoft.com/azure/connectors/connectors-create-api-azureblobstorage?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">Azure Blob Storageコネクタ</a>が最も簡単なソリューションです。</p>


  <p>2 つのタスクが残っています。 コンポーネントは、XML ペイロードをフラット データ レコード構造に変換し、結果をデータ レコードに<a href="https://docs.microsoft.com/azure/event-hubs/?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">Azure Event Hubs。</a></p>


  <p>応答データは、MTConnectStreams ドキュメントとして書式設定されます。 さまざまな <a href="https://github.com/mtconnect/schema" target="_blank">MTConnect ドキュメントの XSD スキーマを見つける</a>。 結果ドキュメント スキーマを詳しく見&rsquo;ると<a href="https://github.com/mtconnect/schema/blob/master/MTConnectStreams_1.3_1.0.xsd" target="_blank"></a>、ポリモーフィズムがドキュメントで広く使用されているのが明らかになります。 たとえば、temperature という名前の要素は、XML 機能の置換グループを使用して、ポリモーフィックな <a href="https://github.com/mtconnect/schema/blob/master/MTConnectStreams_1.3_1.0.xsd#L1437" target="_blank">TemperatureType</a> 型 <a href="https://www.w3.org/TR/xmlschema-0/#SubsGroups" target="_blank">です</a>。</p>


  <p>変換用 <a href="https://docs.microsoft.com/azure/logic-apps/logic-apps-enterprise-integration-transform?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">の XML 変換</a> コネクタLogic Apps。 このコネクタを簡単に確認すると、統合パックを使用してマップを開発<a href="https://docs.microsoft.com/en-us/azure/logic-apps/logic-apps-enterprise-integration-overview?WT.mc_id=iotinsightsblog2-blog-ercenk" target="_blank">Enterpriseが明らかです</a>。 マップを開発することができますが、カスタム コードで同じことを行うのと比較すると、そのアクティビティは多くの労力が必要になる可能性があります。</p>


  <p>楽しいコーディングの <a href="https://github.com/Ercenk/MTConnect.Client" target="_blank">週末の</a> 1 つで MTConnect クライアントを開発しました。 コンポーネントは、Plain Old CLR Object (POCO) クラスを使用します。 クラスは、 ツールの Visual Studio&rsquo;をxsd.exeしました。 生成されたコードはポリモーフィック XML を逆シリアル化する機能を持てないが、それを成功に変えやすい。 <a href="https://docs.microsoft.com/dotnet/api/system.xml.serialization.xmlincludeattribute?redirectedfrom=MSDN&amp;view=netframework-4.7.2" target="_blank">XmlIncludeAttribute</a> をポリモーフィックで生成されたクラスに<a href="https://github.com/Ercenk/MTConnect.Client/blob/master/src/MTConnect.Client/Client/Schemas/MTConnectStreams_1_3_1_0.cs#L385" target="_blank">適用します</a>。</p>


  <p>次の 2 つのタスクを切り離しました。 VDS エンドポイントをポーリングして生データを保存し、変換して結果をイベント ハブに投稿します。 このような設計により、結果の解析と変換のより複雑なタスクが、開発、デバッグ、保守に役立つ作業が容易な環境に移動します。 結果の設計は、2 つのマイクロサービスで構成されます。 1 つ目はロジック アプリとして開発され、Azure Logic Appsされます。 2 つ目のカスタム コードは、<a href="https://docs.microsoft.com/azure/container-instances/?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">Azure Container Instancesされます。</a> 2 つのマイクロサービスStorageするために、キューに対して 1 つのキューを使用します。</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/3e540a1c-23d9-4535-b7ca-e29b540fdcfa.jpg"><img alt="Extracting Insights from IoT Data - Solution Guide Figures 3" border="0" height="376" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/83c8fb7d-accd-4f9b-9cea-0e9cb52cb8e6.jpg" style="border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="IoT インサイトからのデータの抽出 - ソリューション ガイド図 3" width="919"></a></p>


  <h2>ロジック アプリの実装</h2>


  <p>コンポーネントのロジック アプリ部分を完全に実装すると、多くの領域と繰り返しが必要になる場合があります。 特に注意が必要な部分のみを強調表示します。 実装は、次のフローチャートに従います。 完全なソース コードは、<a href="https://github.com/MSIndustryExperiences/IoTInsights/blob/master/ingest/poll/src/logicapp.json" target="_blank">次のGitHub</a>。</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2d9e4625-f20a-46ad-8f83-a0ee674ac1c1.jpg"><img alt="Extracting Insights from IoT Data - Solution Guide Figures 4" border="0" height="529" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/dee33a69-1d49-459f-8fd1-cd76014d1b81.jpg" style="border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="IoT インサイトデータからのデータの抽出 - ソリューション ガイド図 4" width="443"></a></p>


  <p>Logic Apps組み込み関数を使用して、ワークフロー定義言語に含まれる JSON と XML を逆シリアル <a href="https://docs.microsoft.com/azure/logic-apps/logic-apps-workflow-definition-language?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">化およびシリアル化できます</a>。 生の結果は、ストレージ要件を最適化するための JSON として格納されます。 同じデータの JSON 表現では、より少ない領域が必要です。 XML タグの方が詳細です。 現在の要求とサンプル要求の結果は、次の式を使用して変数に保存されます。 ワークフローの編集に GUI を使用している場合は、最初の行を使用できます。 コード ビューで編集するには、インタープリターが機能するために、 関数が @ で始まる必要があります。</p>


  <pre>

  json(replace(string(json(xml(trim(body(&#39;Current&#39;))))), &#39;&quot;@&#39;, &#39;&quot;&#39;))


  &quot;value&quot;: &quot;@json(replace(string(json(xml(trim(body(&#39;Current&#39;))))), &#39;\&quot;@&#39;, &#39;\&quot;&#39;))&quot;</pre>


  <p>キーは、まず XML を逆シリアル化してから、結果を JSON にシリアル化します。 この操作では、属性名の前に 文字が付加された JSON 文字列が作成 &ldquo;@&rdquo; されます。 アクティビティは&nbsp; JSON を文字列に変換します。 を削除 &ldquo;@&rdquo; し、結果から新しい JSON を作成します。</p>


  <p>元の XML は次のようになります。</p>


  <pre>

  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

  &lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;/styles/Streams.xsl&quot;?&gt;

  &lt;MTConnectStreams xmlns:m=&quot;urn:mtconnect.org:MTConnectStreams:1.3&quot; xmlns=&quot;urn:mtconnect.org:MTConnectStreams:1.3&quot; xmlns:xsi=&quot;https://www.w3.org/2001/XMLSchema-instance&quot; xmlns:x=&quot;urn:nist.gov:NistStreams:1.3&quot; xsi:schemaLocation=&quot;urn:nist.gov:NistStreams:1.3 /schemas/NistStreams_1.3.xsd&quot;&gt;
     &lt;Header creationTime=&quot;2018-08-24T22:02:06Z&quot; sender=&quot;5c182aaf5077&quot; instanceId=&quot;1535115106&quot; version=&quot;1.3.0.18&quot; bufferSize=&quot;1048576&quot; nextSequence=&quot;438473124&quot; firstSequence=&quot;437424548&quot; lastSequence=&quot;438473123&quot;/&gt;
     &lt;Streams&gt;
       &lt;DeviceStream name=&quot;GFAgie01&quot; uuid=&quot;mtc_adapter001&quot;&gt;
         &lt;ComponentStream component=&quot;Device&quot; name=&quot;GFAgie01&quot; componentId=&quot;GFAgie01&quot;&gt;
           &lt;Events&gt;
             &lt;Availability dataItemId=&quot;GFAgie01-dtop_1&quot; timestamp=&quot;2018-08-24T22:02:06.397326&quot; name=&quot;avail&quot; sequence=&quot;438473077&quot;&gt;UNAVAILABLE&lt;/Availability&gt;
             &lt;EmergencyStop dataItemId=&quot;GFAgie01-dtop_2&quot; timestamp=&quot;2018-08-24T22:02:06.397970&quot; name=&quot;estop&quot; sequence=&quot;438473086&quot;&gt;UNAVAILABLE&lt;/EmergencyStop&gt;
             &lt;AssetChanged dataItemId=&quot;GFAgie01_asset_chg&quot; timestamp=&quot;2018-08-24T22:02:06.390521&quot; sequence=&quot;438472999&quot; assetType=&quot;&quot;&gt;UNAVAILABLE&lt;/AssetChanged&gt;</pre>

  <p>文字が削除 &ldquo;@&rdquo; されていない場合、JSON は次のようになります。</p>


  <pre>

  {
       &quot;?xml&quot;: {
           &quot;@version&quot;: &quot;1.0&quot;,
           &quot;@encoding&quot;: &quot;UTF-8&quot;
       },
       &quot;?xml-stylesheet&quot;: &quot;type=\&quot;text/xsl\&quot; href=\&quot;/styles/Streams.xsl\&quot;&quot;,
       &quot;MTConnectStreams&quot;: {
           &quot;@xmlns:m&quot;: &quot;urn:mtconnect.org:MTConnectStreams:1.3&quot;,
           &quot;@xmlns&quot;: &quot;urn:mtconnect.org:MTConnectStreams:1.3&quot;,
           &quot;@xmlns:xsi&quot;: &quot;https://www.w3.org/2001/XMLSchema-instance&quot;,
           &quot;@xmlns:x&quot;: &quot;urn:nist.gov:NistStreams:1.3&quot;,
           &quot;@xsi:schemaLocation&quot;: &quot;urn:nist.gov:NistStreams:1.3 /schemas/NistStreams_1.3.xsd&quot;,
           &quot;Header&quot;: {
               &quot;@creationTime&quot;: &quot;2018-08-24T22:02:06Z&quot;,
               &quot;@sender&quot;: &quot;5c182aaf5077&quot;,
               &quot;@instanceId&quot;: &quot;1535115106&quot;,</pre>

  <p>結果を JSON に変換すると、firstSequence と lastSequence の属性値にアクセスすることもできます。</p>


  <pre>

  &quot;value&quot;: &quot;@int(variables(&#39;CurrentResult&#39;).MTConnectStreams.Header.firstSequence)&quot;


  Then I can plug in the values to the query parameter of the sample request.


  &quot;Sample&quot;: {
     &quot;type&quot;: &quot;Http&quot;,
     &quot;inputs&quot;: {
       &quot;method&quot;: &quot;GET&quot;,
       &quot;uri&quot;: &quot;<a href="https://smstestbed.nist.gov/vds/sample?from=@{variables('NextSequence')}&quot;">https://smstestbed.nist.gov/vds/sample?from=@{variables(&#39;NextSequence&#39;)}&quot;</a>
     },
     &quot;runAfter&quot;: {
       &quot;Delay&quot;: [
         &quot;Succeeded&quot;
       ]
     }
  },</pre>


  <p>各プローブ要求が正常に受信された後、ワークフローは結果を Azure BLOB ストレージ上の BLOB に保存Storage。 次に、保存された BLOB の URL を含む Storage Queue にメッセージを格納します。これにより、他のマイクロサービスに対して、データ レコードを変換し、後続の Event Hubs に変換してポストします。</p>


  <h2>次の手順</h2>


  <ul>
   <li>詳細については<a href="https://docs.microsoft.com/en-us/azure/logic-apps/?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">Azure Logic Apps</a>ドキュメントを参照してください</li>
   <li>サンプル リポジトリ <a href="https://github.com/MSIndustryExperiences/IoTInsights" target="_blank">を複製する</a></li>
   <li><a href="https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fazure.microsoft.com%2Fblog%2Fingesting-a-data-stream-from-nist-manufacturing-lab-data-part-2%2F%3FWT.mc_id%3Diotinsightsblog2-acomblog-ercenk&amp;data=02%7C01%7Cv-cabas%40microsoft.com%7Ccfdc6e0fe56a45aebea408d6347d532f%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C636754110201149265&amp;sdata=zUuVx3845UgjkMamiH1MHxORcQkp24A8j9zPrrfdxsc%3D&amp;reserved=0" target="_blank">マイクロサービス間の通信</a>の実装と 2 番目のマイクロサービスの実装の詳細については、「NIST 製造ラボ データからのデータ ストリームの取り込み - パート 2」を参照してください</li>
  </ul>
