### YamlMime:Yaml
ms.openlocfilehash: 0ddb60e0dda8d6b8f46265d0d0946c7aae776ae1
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139891888"
Slug: working-with-dates-in-azure-documentdb-4
Title: Azure DocumentDB で日付を扱う
Summary: この投稿では、DateTime プロパティを効率的に処理する 2 つの方法を紹介しますが、Date と Times を効率的に処理する実装はさらに多く含まれています。
Content: "<div style=\"background:#eee;border:1px solid #ccc;padding:5px 10px;\"><strong>2016 年 12 月 27</strong> 日の更新:日付は、 <a href=\"https://docs.microsoft.com/azure/documentdb/documentdb-working-with-dates\">Azure DocumentDB </a>での日付の操作に関するドキュメント記事で文書化および更新されました。</div>\n\n<p>JSON (<a href=\"www.json.org\" target=\"_blank\">www.json.org</a>) は軽量なデータ交換形式であり、人間は読み書きが簡単ですが、マシンの解析と生成も簡単です。 JSON は <a href=\"https://azure.microsoft.com/en-us/services/documentdb/\" target=\"_blank\">DocumentDB の中心です</a>。 ネットワーク上で JSON を送信し、JSON を JSON として格納し、JSON ツリーにインデックスを付け、完全な JSON ドキュメントに対するクエリを許可します。 これは製品に取り込むものではなく、サービスの中核です。 したがって、DocumentDB が JSON と同じデータ型をネイティブでサポートしているのは驚きではありません。String、Number、Boolean、Array、Object、Null。 <a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/11/12/1.jpg\"><img alt=\"1\" border=\"0\" height=\"168\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/1_thumb.jpg\" style=\"float: none; padding-top: 0px; padding-left: 0px; padding-right: 0px; border-width: 0px;\" title=\"1\" width=\"480\"></a> .NET 開発者は、使用されている特定の型の省略に気付く場合があります。 最も重要なのは、おそらく .NET DateTime 型です。 では、データベースがこれらの型をネイティブでサポートしていない場合に、DateTime&rsquo; を使用して格納、取得、クエリを実行する方法を説明します。 この投稿の目的は&hellip;&rsquo;、引き続きお読みください。この投稿の目的のために、次のサンプル POCO オブジェクトを使用する必要があります。</p>\n\n<pre class=\"prettyprint\">\npublic class Order\n{\n    [JsonProperty(PropertyName=&quot;id&quot;)]\n    public string OrderNumber { get; set; }\n    public DateTime OrderDate { get; set; }      \n    public DateTime ShipDate { get; set; }                \n    public double Total { get; set; }\n}</pre>\n\n<p>これは、.NET で Order を表現する方法を示す簡単なデモです。 注文には、OrderDate と ShipDate という 2 つの DateTime プロパティがあります。 この投稿では、主にこれら 2 つのプロパティに焦点を当てる必要があります。 DocumentDB SDK で DateTime オブジェクトを処理するために使用される既定の形式は、 で ISO 8601 文字列形式に変換することです。 したがって、次のコード スニペットに示すように、Order オブジェクトを DocumentDB に渡す以外に何もしない場合は、</p>\n\n<pre class=\"prettyprint\">\nvar doc1 = client.CreateDocumentAsync(colLink, new Order { \n      OrderNumber = &quot;09152014101&quot;,\n      OrderDate = DateTime.UtcNow.AddDays(-30),\n      ShipDate = DateTime.UtcNow.AddDays(-14), \n      Total = 113.39\n});</pre>\n\n<p>2 つの .NET DateTime プロパティは、次のような文字列として格納されます。</p>\n\n<pre class=\"prettyprint\">\n{\n    &quot;OrderDate&quot;: &quot;2014-09-15T23:14:25.7251173Z&quot;,\n    &quot;ShipDate&quot;: &quot;2014-09-30T23:14:25.7251173Z&quot;\n}</pre>\n\n<p>その文字列は、このような見栄えの良い読み取り可能な文字列なので、なぜこれが問題なのでしょうか。 DocumentDB では、範囲クエリ ( &gt; フィールド 10 とフィールド 20 &lt; など) を実行できる数値フィールドに対する範囲ベースのインデックスがサポートされています。 日付に対して範囲クエリ (以前のレコード、先週の注文、または今日出荷された注文) を実行するときにコストの高いスキャンを実行しないようにするには、日付の文字列表現を数値に変換して、これらのフィールドで範囲インデックスを使用する必要があります。 DocumentDB と JSON は、DateTimes を表す方法に依存しません。この中立性を使用して、アプリケーションのニーズに最適な強力な効果を得&rsquo;ることができます。 この投稿では、DateTime プロパティを効率的に処理する 2 つの方法を紹介しますが、Date と Times を効率的に処理する実装はさらに多く含まれています。 &nbsp; 残りの投稿では、DateTimes をエポック値、または特定の日付から数秒として扱います。 この投稿では 1970 年 1 月 1 日 00:00 を使用しています。データに応じて、別の開始点を使用できます。 つまり、注文を行い、システムで今日からの注文のみを処理する必要がある場合は、開始点として今日を選択します。 架空のシステムには履歴注文が多数あるので、少し時間を戻す必要があります。 ここでは、この変換を実行する DateTime 用の単純な .NET 拡張メソッドを示します。</p>\n\n<pre class=\"prettyprint\">\npublic static class Extensions\n{\n    public static int ToEpoch(this DateTime date)\n    {\n        if (date == null) return int.MinValue;\n        DateTime epoch = new DateTime(1970, 1, 1);\n        TimeSpan epochTimeSpan = date - epoch;\n        return (int)epochTimeSpan.TotalSeconds;\n    }\n}</pre>\n\n<p>ここでは、アプリケーションでこれをどのように使用しますか? 続行するには 2 つの方法があります。また、アプリケーションのニーズに最適な方法を選択できます。 最初の方法は、 <b>DateTime 自体</b> ではなく DateTime を表す数値フィールドを格納する方法です。 これを行う最も簡単な方法は、JSON を処理するためのカスタム シリア &amp; ライザー逆シリアライザーを実装する方法です。 ここでは&rsquo;、DateTime プロパティの既定の動作を変更する顧客の JsonConverter を実装することで、JSON.NET を使用してこれを行う方法について説明します。 これを行うには、JsonConverter 抽象クラスを拡張し、ReadJson メソッドと WriteJson メソッドをオーバーライドするクラスを定義します。</p>\n\n<pre class=\"prettyprint\">\npublic class EpochDateTimeConverter : JsonConverter\n{\n    ...\n}</pre>\n\n<p>.NET DateTime を受け取り、上で作成したのと同じ ToEpoch() 拡張メソッドを使用して数値を出力する WriteJson&nbsp;&nbsp; 実装を次に示します。</p>\n\n<pre class=\"prettyprint\">\npublic override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)\n{\n    int seconds;\n    if (value is DateTime)\n    {\n        DateTime dt = (DateTime)value;\n        if (!dt.Equals(DateTime.MinValue))\n            seconds = dt.ToEpoch();\n        else\n            seconds = int.MinValue;\n    }\n    else\n    {\n        throw new Exception(&quot;Expected date object value.&quot;);\n    }\n\n    writer.WriteValue(seconds);\n}</pre>\n\n<p>逆の ReadJson メソッドも用意されています。これは、JSON から .NET にシリアル化する際に使用されます。 このメソッドは、1970 年 1 月 1 日 UTC からの秒の数を表す数値を受け取り、同等の .NET DateTime を返します。</p>\n\n<pre class=\"prettyprint\">\npublic override object ReadJson(JsonReader reader, Type type, object value, JsonSerializer serializer)\n{\n    if (reader.TokenType == JsonToken.None || reader.TokenType == JsonToken.Null) \n        return null;\n\n    if (reader.TokenType != JsonToken.Integer)\n    {\n        throw new Exception(\n            String.Format(&quot;Unexpected token parsing date. Expected Integer, got {0}.&quot;,\n            reader.TokenType));\n    }\n\n    int seconds = (int)reader.Value;\n    return new DateTime(1970, 1, 1).AddSeconds(seconds);\n}</pre>\n\n<p>アプリケーションでこれを使用するには、DateTime プロパティを JsonConverter 属性で装飾する必要があります。 現在、これらのプロパティがシリアル化または逆シリアル化されている場合、Json.NET 既定では動作するのではなく、カスタム コードを使用する必要があります。</p>\n\n<pre class=\"prettyprint\">\n    public class Order\n    {\n        [JsonProperty(PropertyName=&quot;id&quot;)]\n        public string OrderNumber { get; set; }\n\n        [JsonConverter(typeof(EpochDateTimeConverter))]\n        public DateTime OrderDate { get; set; }\n\n        [JsonConverter(typeof(EpochDateTimeConverter))]\n        public DateTime ShipDate { get; set; }\n\n        public double Total { get; set; }\n    }</pre>\n\n<p>シリアル化後の結果は、JSON の数値と DocumentDB に格納されている数値になります。</p>\n\n<pre class=\"prettyprint\">\n{\n    &quot;OrderDate&quot;: 1408318702,\n    &quot;ShipDate&quot;: 1408318702 \n}</pre>\n\n<p>DocumentDB の数値フィールドに対して効率的な範囲クエリを実行するには、DocumentCollection を作成するときに、数値フィールドを含むパスに範囲インデックスを定義する必要があります。 次の例は、カスタム IndexPolicy を使用して DocumentCollection を作成する方法を示しています。 数十億単位の数値を扱うので、この範囲インデックスには 7 バイトの数値有効桁数を使用します。 数値の範囲を小さくする場合は、小さな有効桁数レベルを使用すると十分です。</p>\n\n<pre class=\"prettyprint\">\nvar collection = new DocumentCollection\n{\n    Id = id\n};\n\n//set the default IncludePath to set all properties in the document to have a Hash index\ncollection.IndexingPolicy.IncludedPaths.Add(new IndexingPath\n{\n    IndexType = IndexType.Hash,\n    Path = &quot;/&quot;,\n});\n\n//now define two additional paths in Order that we know we want to do Range based queries on\ncollection.IndexingPolicy.IncludedPaths.Add(new IndexingPath\n{\n    IndexType = IndexType.Range,\n    Path = &quot;/\\&quot;OrderDate\\&quot;/?&quot;,\n    NumericPrecision = 7\n});\n\ncollection.IndexingPolicy.IncludedPaths.Add(new IndexingPath\n{\n    IndexType = IndexType.Range,\n    Path = &quot;/\\&quot;ShipDate\\&quot;/?&quot;,\n    NumericPrecision = 7\n});\n\ncollection = client.CreateDocumentCollectionAsync(dbLink, collection).Result;</pre>\n\n<p>この設定が完了すると、DateTime プロパティに対してクエリを実行するのと同じ方法で簡単に実行できます。</p>\n\n<pre class=\"prettyprint\">\n//convert &quot;7 days ago&quot; to epoch number using our ToEpoch extension method for DateTime\nint epocDateTime DateTime.UtcNow.AddDays(-7).ToEpoch();\n\n//build up the query string\nstring sql = string.Format(&quot;SELECT * FROM Collection c WHERE c.OrderDate &gt; {0}&quot;, epocDateTime);\n\n//execute the query and get the results in a List\nvar orders = client.CreateDocumentQuery&lt;Order&gt;(col.SelfLink, sql).ToList();</pre>\n\n<p>これは&rsquo; 1 つのアプローチであり、非常に効率的に機能します。 ただし、欠点は、データベース内の人間が読み取り可能な日付文字列が失われる点です。 &rsquo;別のアプリケーションがデータベースに接続しても、カスタムデシリアライザーは必ずしも実行されません。返される値は、多くの人間が自分の頭の中でエポック変換を行えるわけではないため、処理が困難になります (&rsquo;確かに、私はそうできません)。 これを実装する 2 番目の方法は、読み取り可能な DateTime フィールドを保持し、文字列表現に加えて DateTime の数値表現を格納する追加のフィールドをドキュメントに追加する方法です。 これを行うには、次のような新しいカスタム型を作成します。</p>\n\n<pre class=\"prettyprint\">\npublic class DateEpoch\n{\n   public DateTime Date { get; set; }\n   public int Epoch\n   {\n       get\n       {\n           return (this.Date.Equals(null) || this.Date.Equals(DateTime.MinValue))\n               ? int.MinValue\n               : this.Date.ToEpoch();\n        }\n    }\n}</pre>\n\n<p>次に、Order オブジェクトの 2 つの DateTime プロパティを、次のようにこの新しい型に変更します。</p>\n\n<pre class=\"prettyprint\">\npublic class Order\n{\n    [JsonProperty(PropertyName = &quot;id&quot;)]\n    public string OrderNumber { get; set; }\n\n    public DateEpoch OrderDate { get; set; }\n\n    public DateEpoch ShipDate { get; set; }\n\n    public double Total { get; set; }\n}</pre>\n\n<p>これで、オブジェクトを DocumentDB に渡す際に、次のような JSON が表示されます。</p>\n\n<pre class=\"prettyprint\">\n{\n    &quot;OrderDate&quot;: {\n        &quot;Date&quot;: &quot;2014-09-15T23: 14: 25.7251173Z&quot;,\n        &quot;Epoch&quot;: 1408318702\n    },\n    &quot;ShipDate&quot;: {\n        &quot;Date&quot;: &quot;2014-09-30T23: 14: 25.7251173Z&quot;,\n        &quot;Epoch&quot;: 1408318702\n    }\n}</pre>\n\n<p>最初の手法で行ったのと同様に、DocumentCollection でカスタム IndexPolicy を定義する必要があります。ただし、今回はエポック値にのみ範囲パスを追加します。 必要に合った場合は、インデックスから日付文字列パスを除外できますが、既定のハッシュ インデックスを保持すると、それを行う場合でも等値演算が可能になります。</p>\n\n<pre class=\"prettyprint\">\nvar collection = new DocumentCollection\n{\n    Id = id\n};\n\n//set the default IncludePath to set all properties in the document to have a Hash index\ncollection.IndexingPolicy.IncludedPaths.Add(new IndexingPath\n{\n    IndexType = IndexType.Hash,\n    Path = &quot;/&quot;,\n});\n\n//now define two additional paths in Order2 that we know we want to do Range based queries on\ncollection.IndexingPolicy.IncludedPaths.Add(new IndexingPath\n{\n    IndexType = IndexType.Range,\n    Path = &quot;/\\&quot;OrderDate\\&quot;/\\&quot;Epoch\\&quot;/?&quot;,\n    NumericPrecision = 7\n});\n\ncollection.IndexingPolicy.IncludedPaths.Add(new IndexingPath\n{\n    IndexType = IndexType.Range,\n    Path = &quot;/\\&quot;ShipDate\\&quot;/\\&quot;Epoch\\&quot;/?&quot;,\n    NumericPrecision = 7\n});\n\n//could also exclude the Date portion of the dates in Order2 as we&#39;re never going to \n//index on these, but will leave these there because they&#39;re still indexed with a hash \n//so you could do equality operations on them.\n\ncollection = client.CreateDocumentCollectionAsync(dbLink, collection).Result;</pre>\n\n<p>この方法でクエリを実行するには、次の LINQ クエリを実行します。これは、この方法のもう 1 つの利点なので、前の例のように SQL ではなく、ここで LINQ を示します。</p>\n\n<pre class=\"prettyprint\">\nvar orders = from o in client.CreateDocumentQuery&lt;Order2&gt;(col.SelfLink)\n    where o.OrderDate.Epoch &gt;= DateTime.Now.AddDays(-7).ToEpoch()\n    select o;</pre>\n\n<p>または、好みがある場合は、次の LINQ ラムダ構文を選択できます。</p>\n\n<pre class=\"prettyprint\">\nvar orders2 = client.CreateDocumentQuery&lt;Order2&gt;(col.SelfLink)\n    .Where(o =&gt; o.OrderDate.Epoch &gt;= DateTime.UtcNow.AddDays(-7).ToEpoch())\n    .ToList();</pre>\n\n<p>もちろん、前SQL使用した構文も有効であり、同じ結果が得られます。LINQ が使用できない場合に使用します。</p>\n\n<pre class=\"prettyprint\">\nstring sql = String.Format(&quot;SELECT * FROM c WHERE c.OrderDate.Epoch &gt;= {0}&quot;, \n                 DateTime.UtcNow.AddDays(-7).ToEpoch());</pre>\n\n<p>この 2 つ目のアプローチには、1 つ目の方法に対する主な利点が 2 つがあります。 まず、JSON.NET などの特定のツールのカスタム シリアル化手法に依存しないので、他の JSON シリアライザーまたは .NET 以外の他の言語で使用できます。 この手法は、Python や Python の場合Node.JS同様に機能します。 2 つ目は、別のアプリケーションがデータにクエリを実行する場合、人間が読み取り可能な DateTime 値を文字列として保持するために、人間は引き続き読み取り可能なバージョンの日付を使用できます。 この方法では、より多くのストレージが必要であり、結果としてドキュメントが少し大きくなりますが、ストレージ コストやドキュメントのサイズが大きすぎる場合は、上記の利点に対して最初の方法よりもこのアプローチが好ましいと思います。 つまり、&rsquo;DocumentDB の DateTime プロパティです。 完了 <a href=\"https://ryancrawcour.blob.core.windows.net/samples/DateTime%20and%20DocumentDB.zip\" target=\"_blank\"></a> このブログ =\">https://azure.microsoft.com/en-us/documentation/services/documentdb/&amp;&nbsp;</a>&gt;https://azure.microsoft.com/en-us/documentation/services/documentdb/<a href=\"https://azure.microsoft.com/en-us/documentation/services/documentdb/\" title=\"記事のサンプル コードが必要な場合は、こちらからダウンロードできます。Azure <a href=\"https://azure.microsoft.com/en-us/services/documentdb/\" target=\"_blank\">DocumentDB</a> の使用を開始するには、azure.com のサービス ドキュメント ページにアクセスしてください。このページでは、実行に必要なすべてを見つけることができます。</p>"
