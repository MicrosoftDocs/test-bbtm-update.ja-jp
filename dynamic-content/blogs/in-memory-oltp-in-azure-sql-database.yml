### YamlMime:Yaml
ms.openlocfilehash: b34d9af5c320bc9627f9e0315a622ae38be449f3
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139890748"
Slug: in-memory-oltp-in-azure-sql-database
Title: In-Memory OLTP in Azure SQL Database (Azure SQL Database のインメモリ OLTP)
Summary: Azure SQL Database で OLTP を In-Memory と、パフォーマンスが向上し、トランザクション処理、データインジェスト、および一時的なデータのシナリオのコストを節約できます。
Content: >-
  <p>最近、すべてのプレミアムデータベースの Azure SQL Database で In-Memory OLTP の<a href="https://azure.microsoft.com/en-us/blog/azure-sql-database-in-memory-performance">一般提供を発表</a>しました。 In-Memory OLTP は、現在、Standard または Basic の価格レベルのデータベースでは使用できません。</p>


  <p>In-Memory OLTP は、トランザクション処理、データインジェスト、および一時的なデータのシナリオにおいて、優れたパフォーマンス上の利点を提供できます。 また、コストの節約にも役立ちます。1秒あたりのトランザクション数を向上させることができます。また、データベースの価格レベルを上げることなく、将来の成長に備えてヘッドルームを増やすことができます。</p>


  <p><a href="https://github.com/Microsoft/sql-server-samples/tree/master/samples/features/in-memory/benchmark-order-processing">注文処理ワークロードのサンプル</a>では、1つのデータベースで<strong>75000 トランザクション/秒</strong>(TPS) を実現できます。これは、従来のテーブルやストアドプロシージャと比較して、In-Memory OLTP を使用した場合に比べて<strong>パフォーマンスが11倍向上</strong>することを Azure SQL Database します。 さまざまなワークロードに応じてマイレージが異なる場合があります。 次の表は、利用可能な最高の価格レベルでこのワークロードを実行した結果を示しています。また、より低い価格レベルの OLTP でも In-Memory OLTP と同様の利点を示しています。 *</p>


  <p>&nbsp;</p>


  <table border="0" cellpadding="2" cellspacing="0" width="401">
   <tbody>
    <tr>
     <td valign="top" width="59">価格レベル</td>
     <td valign="top" width="146">In-Memory OLTP の TP</td>
     <td valign="top" width="119">従来のテーブルの TP</td>
     <td valign="top" width="75">パフォーマンスの向上</td>
    </tr>
    <tr>
     <td valign="top" width="59">P15</td>
     <td valign="top" width="146">75,000</td>
     <td valign="top" width="119">6800</td>
     <td valign="top" width="75">11X</td>
    </tr>
    <tr>
     <td valign="top" width="59">P2</td>
     <td valign="top" width="146">8,900</td>
     <td valign="top" width="119">1,000</td>
     <td valign="top" width="75">9</td>
    </tr>
   </tbody>
  </table>


  <p><br>

  <em>表 1: 注文処理のサンプルワークロードのパフォーマンスを比較する</em></p>


  <blockquote>

  <p><em>*P15 での実行では、400クライアントを使用して100のスケールファクターを使用していました。P2 の実行では、200クライアントを使用してスケールファクター5を使用していました。Scale factor は、メモリ最適化テーブルを使用する場合に100が15GB データベースサイズに変換されるデータベースサイズの尺度です。ワークロードの詳細については、 <a href="https://github.com/Microsoft/sql-server-samples/tree/master/samples/features/in-memory/benchmark-order-processing">SQL Server のサンプル GitHub リポジトリ</a>を参照してください。</em></p>

  </blockquote>


  <p>このブログ投稿では、テクノロジのしくみ、パフォーマンス上の利点、およびアプリケーションのパフォーマンス向上を実現するためにテクノロジを最大限に活用する方法について詳しく見ていきます。</p>


  <p>In-Memory OLTP は、トランザクション処理、データインジェスト、データの読み込みと変換、および一時的なデータのシナリオを対象としています。 分析クエリのパフォーマンスを向上させるには、代わりに列ストアインデックスを使用します。 これらの詳細については、このブログの <a href="https://msdn.microsoft.com/library/gg492088.aspx">ドキュメント</a> と、今後数週間にわたってご覧ください。</p>


  <h1>In-Memory OLTP のしくみ</h1>


  <p>インメモリ OLTP は、適切なワークロードの場合にパフォーマンスが大きく向上します。 クォーラムビジネスソリューションの1つは、 <a href="https://customers.microsoft.com/en-US/story/quorum-doubles-key-databases-workload-while-lowering-dtu-with-sql-database">DTU を70% 削減しながら、データベース &rsquo; s のワークロードを倍増</a>させることです。 Azure SQL Database では、DTU は特定のデータベースで利用できるリソースの量を測定したものです。 リソース使用率を削減することで、クォーラムビジネスソリューションは、より大きなワークロードをサポートできるようになりました。さらに、将来の成長に備えてヘッドルームを増やすことができ、データベースの価格レベルを上げる必要もありません。</p>


  <p>ここで、パフォーマンスが向上し、リソースの効率がどのようになるでしょうか。 基本的に、In-Memory OLTP では、データアクセスとトランザクションの実行効率が向上し、同時に実行 <em>さ </em>れるトランザクション間でロックとラッチの競合が解消されるため、トランザクション処理のパフォーマンスが向上します。これは、メモリ内にあるため、高速ではありません。メモリ内のデータに対して <em>最適化</em> されているため、高速です。 メモリ内のコンカレンシー処理が多い計算に関する最新の機能強化を利用するように、データ ストレージ、アクセス、処理アルゴリズムはゼロから再設計されました。</p>


  <p>現在では、データがメモリ内にあるからというだけで、障害が発生したときにデータが失われることを意味しなくなりました。 既定では、すべてのトランザクションは完全に持続性があります。つまり、Azure SQL Database 内の他のテーブルに対しても同じ持続性が保証されます。トランザクションコミットの一部として、すべての変更がディスク上のトランザクションログに書き込まれます。 トランザクション コミット後のどこかの時点で障害が発生すると、データベースがオンラインに戻ったときに、コミットされたデータを利用できます。 Azure SQL Database では、高可用性を管理するため &rsquo; 、心配する必要はありません。データセンターで内部エラーが発生し、データベースが別の内部ノードにフェールオーバーした場合、コミットしたすべてのトランザクションのデータがそこに存在することになります。 さらに、In-Memory OLTP は、特定の時点への復元、geo リストア、アクティブ geo レプリケーションなど、Azure SQL Database の高可用性とディザスターリカバリーのすべての機能と連携します。</p>


  <p>データベースでインメモリ OLTP を利用するには、次に示すオブジェクトの種類から 1 つまたは複数使用します。</p>


  <ul>
   <li><em>メモリ最適化テーブル </em>は、ユーザーデータを格納するために使用されます。 テーブルは、作成時にメモリが最適化されるように宣言します。</li>
   <li><em>持続性のないテーブル </em>は、キャッシュまたは中間結果セット (従来の一時テーブルを置き換える) の一時的なデータに使用されます。 非持続的テーブルは、DURABILITY=SCHEMA_ONLY を使用して宣言されるメモリ最適化テーブルです。つまり、これらのテーブルを変更しても、IO は発生しません。 そのため、持続性が重要ではない場合、ログ IO リソースの消費を回避することができます。</li>
   <li><em>メモリ最適化テーブル型</em> は、テーブル値パラメーター (TVP) だけでなく、ストアド プロシージャの中間結果セットにも使用されます。 メモリ最適化テーブル型は、従来のテーブル型の代わりに使用できます。 メモリ最適化テーブル型を使用して宣言したテーブル変数と TVP は、非持続的メモリ最適化テーブルの利点 (効率的なデータ アクセス、IO なし) を継承します。</li>
   <li><em>ネイティブ コンパイル T-SQL モジュール</em> は、操作の処理に必要な CPU サイクルを減らして、個々のトランザクションにかかる時間をさらに短縮するために使用されます。 Transact-SQL モジュールは、作成時にネイティブでコンパイルするように宣言します。 このとき、ストアド プロシージャ、トリガー、スカラー ユーザー定義関数という T-SQL モジュールをネイティブでコンパイルできます。</li>
  </ul>


  <p>OLTP は Azure SQL Database に組み込まれており、すべてのプレミアムデータベースでこれらのオブジェクトをすべて使用できます。 In-Memory また、これらのオブジェクトは、従来の対応するオブジェクトにとても似た動作なので、多くの場合、データベースとアプリケーションの変更を最小限に抑えながら、パフォーマンスを向上できます。 この記事の最後に、これらの各種類のオブジェクトの例を示す transact-sql SQL スクリプトがあります。</p>


  <p>各データベースには、データベースまたはエラスティックプールの Dtu の数に関連付けられているメモリ最適化テーブルのサイズの上限があります。 この執筆時点では、125 Dtu または Edtu ごとに 1 gb のストレージが得られます。 OLTP 記憶域の使用率の In-Memory 監視と変更の詳細については、「 <a href="https://azure.microsoft.com/en-us/documentation/articles/sql-database-in-memory-oltp-monitoring/">Monitor In-Memory Storage</a>」を参照してください。</p>


  <h1>In-Memory OLTP をどこで使用するのでしょうか。</h1>


  <p>OLTP In-Memory Azure SQL Database が初めての場合もありますが、2014以降は SQL Server に含まれています。 Azure SQL Database と SQL Server は同じコードベースを共有するため、Azure SQL DB の In-Memory oltp は In-Memory の oltp と同じです。 テクノロジはしばらくの間に提供されているので、In-Memory OLTP の利点を実際に理解するための使用シナリオとアプリケーションパターンについても説明しました。</p>


  <h2>データベース内のリソース使用率</h2>


  <p>アプリケーションのユーザーのパフォーマンスを向上させることが目標である場合、1秒あたりの要求数 (つまり、ワークロードのスループット)、または1つの要求の処理にかかる時間 (トランザクション待機時間など) に関しては、パフォーマンスのボトルネックがどこにあるかを把握しておく必要があります。 OLTP がデータベース内にあるため、データベース内で発生する操作のパフォーマンスが向上します。 In-Memory ほとんどの時間がアプリケーションコードまたはアプリケーションとデータベース間のネットワーク通信で費やされている場合、データベースの最適化によって全体的なパフォーマンスに影響が及ぶことはありません。</p>


  <p>Azure SQL Database には、 <a href="https://msdn.microsoft.com/library/dn800981.aspx">sys.dm_db_resource_stats</a>などの Azure portal とシステムビューを通じて公開されるリソース監視機能が用意されています。 データベースが存在する価格レベルの上限に近づいているリソースがある場合、これはデータベースがボトルネックであることを示しています。 OLTP In-Memory リソースの主な種類は、CPU とログの IO 使用率です。</p>


  <p>合計100万センサーを含む<a href="https://github.com/Microsoft/sql-server-samples/tree/master/samples/applications/iot-smart-grid">サンプルの IoT ワークロード</a> * を見てみましょう &rsquo; 。すべてのセンサーが100秒ごとに新しい読み取りを出力します。 これは、1秒ごとにデータベースに取り込まれたする必要がある1万センサーの読み取りに変換されます。 次に実行するテストでは、P2 価格レベルのデータベースを使用しています。 最初のテストでは、従来のテーブルとストアドプロシージャを使用します。 次のグラフは、Azure portal のスクリーンショットであり、これら2つの主要なメトリックのリソース使用率を示しています。</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2f52fcce-dd59-4bc1-9c0e-1873025f1b7f.png"><img alt="image" border="0" height="386" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/9fad8231-9794-413b-aa9d-fdd31d6f50f5.png" style="border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px; display: inline; background-image: none;" title="絵" width="583"></a><br>

  <em>図 1: In-Memory OLTP を使用しない P2 データベースでの1秒あたりの10,000 センサーの読み取り数</em></p>


  <p>CPU が非常に高く、ログの IO 使用率が非常に高いことがわかります。 ここでの割合は、データベースの価格レベルの DTU 数に関連付けられているリソースキャップに対する相対値です。</p>


  <p>これらの数値は、データベースにパフォーマンス上のボトルネックがあることを示しています。 価格レベルを上げることで、データベースにより多くのリソースを割り当てることができますが、In-Memory OLTP を利用することもできます。 次のようにして、リソースの使用率を下げることができます。</p>


  <ul>
   <li>CPU:  <ul>
    <li>テーブルとテーブル変数をメモリ最適化テーブルとテーブル変数に置き換えて、より効率的なデータアクセスの恩恵を受けられるようにします。</li>
    <li>トランザクションの処理に使用される主要なパフォーマンスを重視するストアドプロシージャを、ネイティブコンパイルストアドプロシージャで置き換えることにより、トランザクションをより効率的に実行できるようになります。</li>
   </ul>
   </li>
   <li>ログ IO: <ul>
    <li>通常、メモリ最適化テーブルでは、インデックス操作がログに記録されないため、従来のテーブルよりもログ IO が少なくなります。</li>
    <li>持続性のないテーブルとメモリ最適化テーブルの変数と Tvp は、一時的なデータのシナリオでログ IO を完全に削除します。 従来の一時テーブルとテーブル変数には、ログ IO が関連付けられていることに注意してください。</li>
   </ul>
   </li>
  </ul>


  <h2>In-Memory OLTP を使用したリソース使用率</h2>


  <p>ここでは、上記と同じワークロードを見てみましょう &rsquo; 。取り込まれた OLTP を使用 In-Memory して、P2 データベースでの1秒あたりのセンサーの読み取り数を1万します。</p>


  <p>メモリ最適化テーブル、メモリ最適化テーブル型、およびネイティブコンパイルストアドプロシージャを実装すると、次のリソース使用プロファイルが表示されます。</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/aa9c9f65-9d39-432c-9f3e-5b583ba58161.png"><img alt="image" border="0" height="399" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/325961b7-2306-4233-b800-f1f3ce03ac67.png" style="border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px; display: inline; background-image: none;" title="絵" width="603"></a><br>

  <em>図 2: In-Memory OLTP を使用した P2 データベースでの1秒あたりの10K センサーの読み取り数</em></p>


  <p>ご覧のように、これらの最適化によって、このワークロードについて、ログ IO が2倍以上、CPU 使用率が8倍に減少しました。 このワークロードに In-Memory OLTP を実装すると、次のようないくつかの利点が得られます。</p>


  <ul>
   <li>将来の成長に備えてヘッドルームが増加しました。 このワークロード例では、P2 データベースは、各センサーが100秒ごとに新しい読み取りを出力する100万センサーに対応できます。 In-Memory OLTP では、同じ P2 データベースでセンサーの数が2倍以上になる可能性があります。また、センサーの測定値を出力する頻度を高くすることもできます。</li>
   <li>クエリを実行してセンサーの読み取りを分析したり、データベース内の他の作業を行ったりするために、大量のリソースが解放されます。 また、メモリ最適化テーブルはロックおよびラッチフリーであるため、書き込み操作とクエリの間に競合は発生しません。</li>
   <li>この例では、データベースを P1 にダウングレードし、同じワークロードを維持し、さらにヘッドルームを追加することもできます。 これは、データベースの運用コストを半分に削減する意味です。</li>
  </ul>


  <p>メモリ最適化テーブルのデータは、データベースの価格レベルに関連付けられている In-Memory OLTP ストレージ上限に収まる必要があります。 この&rsquo;ワークロードの OLTP In-Memory使用率の詳細を確認します。</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/ccc224f6-4f77-4640-87df-071ed02b2beb.png"><img alt="image" border="0" height="401" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/eb15cd17-cd17-49f2-886e-6c0b8eed3bd3.png" style="border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px; display: inline; background-image: none;" title="イメージ" width="602"></a><br>

  <em>図 3: In-Memory OLTP ストレージ使用率の確認</em></p>


  <p>OLTP ストレージIn-Memory使用率 (緑の線) は平均で約 7% であるのが分かっています。 これは純粋な &ldquo;データ インジェスト ワークロードで、センサーの読み取り値をデータベースに継続的に追加します。In-Memory OLTP ストレージの使用率が時間の経つ間に増加しないのは、どうしてでしょうか。&rdquo;</p>


  <p>メモリ最適化テンポラル <a href="https://msdn.microsoft.com/library/mt590207.aspx">テーブルを使用しています</a>。 つまり、テーブルは独自の履歴を&rsquo;保持し、履歴はディスク上に保存されます。 Azure SQL Databaseは、メモリとディスクの間の移動を行います。 一時的なデータ インジェスト ワークロードの場合、これはメモリ内のストレージ フットプリントを管理するための最適なソリューションです。</p>


  <blockquote>

  <p><em>*この実験をレプリケートするには、サンプル アプリapp.config次のように変更します<a href="https://github.com/Microsoft/sql-server-samples/tree/master/samples/applications/iot-smart-grid"></a>。commandDelay=1 と enableShock=0。さらに、&ldquo;&rdquo;前の画像を再作成するには、テーブルとテーブルの種類をディスク ベース (つまり、MEMORY_OPTIMIZED=OFF) に変更し、ストアド プロシージャから NATIVE_COMPILATION と ATOMIC を削除します</em></p>

  </blockquote>


  <h2>OLTP のIn-Memoryシナリオ</h2>


  <p>この投稿の上部で説明In-Memory OLTP はマジックの高速ボタンではなく、すべてのワークロードに適しているというのではありません。 たとえば、ほとんどのクエリで大量のデータに対して集計を実行している場合、メモリ最適化テーブルでは実際には CPU &ndash; 使用率が下がり、列ストアはこのようなシナリオに役立ちます。</p>


  <p>次に、お客様がインメモリ OLTP で成功したシナリオとアプリケーション パターンの一覧を紹介します。 基になるテクノロジは同じSQL Server、Azure SQL Databaseも同様に適用されます。</p>


  <h3><strong>高スループット、低遅延トランザクションの処理</strong></h3>


  <p>これはインメモリ OLTP を構築する中核となるシナリオです。個々のトランザクションの低遅延を保ちながら、大量のトランザクションに対応します。</p>


  <p>一般的なワークロード シナリオとして、金融商品の取引、スポーツくじ、モバイル ゲーム、広告配信などがあります。 目にしたもう 1&rsquo; つの&ldquo;&rdquo;一般的なパターンは、頻繁に読み取られるカタログや更新されるカタログです。 たとえば、大きなファイルが複数ある場合、各ファイルはクラスターの複数のノードに分散され、メモリ最適化テーブル内にある各ファイルの各シャードの場所を分類します。</p>


  <p><em>実装時の注意事項</em></p>


  <p>中核となるトランザクション テーブル (つまり、最もパフォーマンスが重要なトランザクションがあるテーブル) にメモリ最適化テーブルを使用します。 ネイティブでコンパイルされたストアド プロシージャを使用して、ビジネス トランザクションに関連付けられたロジックの実行を最適化します。 データベースのストアド プロシージャに組み込むことができるロジック数が多いほど、インメモリ OLTP の利点も大きくなります。</p>


  <p>既存のアプリケーションで作業を開始するには、トランザクション パフォーマンス分析レポートを使用して移行するオブジェクトを特定し、メモリ最適化およびネイティブ <a href="https://msdn.microsoft.com/en-us/library/dn284308.aspx"></a> コンパイル アドバイザーを使用<a href="https://msdn.microsoft.com/en-us/library/dn358355.aspx"></a>して移行を支援します。<a href="https://msdn.microsoft.com/en-us/library/dn205133.aspx"></a></p>


  <h3><strong>IoT (モノのインターネット) などのデータ統合</strong></h3>


  <p>インメモリ OLTP は、同時にさまざまなソースから大量のデータを取り込む処理が特に得意です。 また、SQL はデータに対するクエリの実行を非常に高速に行い、リアルタイムの分析情報を取得できるので、他の変換先と比較して、SQL データベースにデータを取り込むと便利な場合がよくあります。</p>


  <p>一般的なアプリケーションのパターンは、センサーの読み取りとイベントを取り込み、通知だけでなく履歴分析を可能にする方法です。 複数のソースからでも、一括更新を管理し、同時読み取りのワークロードに対する影響を最小限に抑えることができます。</p>


  <p><em>実装時の注意事項</em></p>


  <p>データの取り込みにメモリ最適化テーブルを使用します。 取り込みの大部分が (更新ではなく) 挿入で構成され、データのインメモリ OLTP ストレージの占有領域が重要な場合、次のいずれかを行います。</p>


  <ul>
   <li>ジョブを使用して、クラスター化列ストア インデックスを使用してディスク ベースのテーブルにデータを定期的 <a href="https://msdn.microsoft.com/library/gg492088.aspx">にバッチ オフロードします</a>。または</li>
   <li>テンポラル <a href="https://msdn.microsoft.com/library/mt590207.aspx">メモリ最適化テーブル</a>&ndash;を使用して、このモードで履歴データを管理し、履歴データはディスク上に保存され、データ移動はシステムによって管理されます。</li>
  </ul>


  <p>次のサンプルは、テンポラル メモリ最適化テーブル、メモリ最適化テーブル型、およびネイティブ コンパイル ストアド プロシージャを使用して、センサー データの In-Memory OLTP ストレージフットプリントを管理しながら、データ インジェストを高速化するスマート グリッド アプリケーションです。リリースとソース コード。 <a href="https://github.com/Microsoft/sql-server-samples/releases/tag/iot-smart-grid-v1.0"></a> <a href="https://github.com/Microsoft/sql-server-samples/tree/master/samples/applications/iot-smart-grid"></a></p>


  <h3><strong>キャッシュとセッションの状態</strong></h3>


  <p>インメモリ OLTP テクノロジは、SQL でセッションの状態 (ASP.NET アプリケーションの状態など) を維持する場合におよびキャッシュの場合に特に推奨されます。</p>


  <p>ASP.NET セッションの状態は、インメモリ OLTP で特に成功している使用事例です。 SQL Server では、あるお客様が毎秒約 120 万要求を達成しました。 その間、企業内のすべての中In-Memoryのキャッシュ ニーズに対応するために OLTP を使用し始めました。 詳細： <a href="https://blogs.msdn.microsoft.com/sqlcat/2016/10/26/how-bwin-is-using-sql-server-2016-in-memory-oltp-to-achieve-unprecedented-performance-and-scale/">https://blogs.msdn.microsoft.com/sqlcat/2016/10/26/how-bwin-is-using-sql-server-2016-in-memory-oltp-to-achieve-unprecedented-performance-and-scale/</a></p>


  <p><em>実装時の注意事項</em></p>


  <p>varbinary(max) 列に BLOB を格納することで、簡易なキーと値のストアとして非持続的メモリ最適化テーブルを使用できます。 または、JSON サポートを使用して半構造化キャッシュを実装Azure SQL Database<a href="https://azure.microsoft.com/blog/json-support-is-generally-available-in-azure-sql-database/"></a>。 最後に、多様なデータ型と制約を含み、完全なリレーショナル スキーマを使用する非持続的なテーブルで、完全なリレーショナル キャッシュを作成できます。</p>


  <p>概要 GitHub で公開されているスクリプトを利用して、<a href="https://github.com/Microsoft/sql-server-samples/tree/master/samples/applications/aspnet-session-state">組</a>み込みのセッション状態プロバイダーによって作成されたオブジェクトを置き換え、メモリ最適化 ASP.NET セッション状態を使用できます。</p>


  <h3>tempdb オブジェクトの置き換え</h3>


  <p>非永続的テーブルとメモリ最適化テーブル型を利用して、従来の tempdb ベースの #temp テーブル、テーブル変数、テーブル値パラメーターを置き換える。</p>


  <p>メモリ最適化テーブル変数と非持続的テーブルは、従来のテーブル変数と #temp テーブルと比較すると、一般的に CPU が減り、ログの IO が完全になくなります。</p>


  <p>メモリ最適化テーブル値パラメーターの利点を示すケース Azure SQL Database。<a href="https://blogs.msdn.microsoft.com/sqlserverstorageengine/2016/04/07/a-technical-case-study-high-speed-iot-data-ingestion-using-in-memory-oltp-in-azure/">https://blogs.msdn.microsoft.com/sqlserverstorageengine/2016/04/07/a-technical-case-study-high-speed-iot-data-ingestion-using-in-memory-oltp-in-azure/</a></p>


  <p><em>実装時の注意事項</em></p>


  <p>作業を開始するには、メモリ最適化を <a href="https://blogs.msdn.microsoft.com/sqlserverstorageengine/2016/03/21/improving-temp-table-and-table-variable-performance-using-memory-optimization/">使用した一時テーブルとテーブル変数のパフォーマンスの向上に関するページを参照してください</a>。</p>


  <h3><strong>ETL (抽出、変換、読み込み)</strong></h3>


  <p>多くの場合、ETL ワークフローには、データのステージング テーブルへの読み込み、データの変換、最終的なテーブルへの読み込みが含まれています。</p>


  <p><em>実装時の注意事項</em></p>


  <p>データのステージングには非持続的メモリ最適化テーブルを使用します。 すべての IO が完全になくなり、データ アクセスがより効率的になります。</p>


  <p>ワークフローの一部としてステージング テーブルで変換を実行する場合、ネイティブ コンパイル ストアド プロシージャを使用すると、変換を高速化できます。 このような変換を並列して実行できると、メモリ最適化からさらにスケール メリットが得られます。</p>


  <h1>作業の開始</h1>


  <p>次のスクリプトは、データベース内に OLTP In-Memoryを作成する方法を示しています。</p>


  <div style="background: rgb(238, 238, 238); padding: 5px 10px; border: 1px solid rgb(204, 204, 204); border-image: none;">-- メモリ最適化テーブル<br>

  CREATE TABLE dbo.table1<br>

  ( c1 INT IDENTITY PRIMARY KEY NONCLUSTERED,<br>

  &nbsp; c2 NVARCHAR(MAX))<br>

  WITH (MEMORY_OPTIMIZED=ON)<br>

  GO<br>

  -- 非永続的テーブル<br>

  CREATE TABLE dbo.temp_table1<br>

  ( c1 INT IDENTITY PRIMARY KEY NONCLUSTERED,<br>

  &nbsp; c2 NVARCHAR(MAX))<br>

  WITH (MEMORY_OPTIMIZED=ON、<br>

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DURABILITY=SCHEMA_ONLY)<br>

  GO<br>

  -- メモリ最適化テーブル型<br>

  CREATE TYPE dbo.tt_table1 AS TABLE<br>

  ( c1 INT IDENTITY,<br>

  &nbsp; c2 NVARCHAR(MAX)<br>

  &nbsp; is_transientビット NOT NULL DEFAULT (0)<br>

  &nbsp; INDEX ix_c1 HASH (c1) WITH (BUCKET_COUNT=1024))<br>

  WITH (MEMORY_OPTIMIZED=ON)<br>

  GO<br>

  -- ネイティブ コンパイル ストアド プロシージャ<br>

  CREATE PROCEDURE dbo.usp_ingest_table1<br>

  &nbsp;@table1 dbo.tt_table1 READONLY<br>

  WITH NATIVE_COMPILATION, SCHEMABINDING<br>

  AS<br>

  BEGIN ATOMIC<br>

  &nbsp;&nbsp;&nbsp; WITH (トランザクション分離レベル=スナップショット、<br>

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LANGUAGE=N&#39;us_english&#39;)<br>

  <br>

  &nbsp; DECLARE @i INT = 1<br>

  <br>

  &nbsp; WHILE @i &gt; 0<br>

  &nbsp; 開始<br>

  &nbsp;&nbsp;&nbsp; INSERT dbo.table1<br>

  &nbsp;&nbsp;&nbsp; SELECT c2<br>

  &nbsp;&nbsp;&nbsp; 差出人 @table1<br>

  &nbsp;&nbsp;&nbsp; WHERE c1 = @i AND is_transient=0<br>

  <br>

  &nbsp;&nbsp;&nbsp; IF @@ROWCOUNT &gt; 0<br>

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SET @i += 1<br>

  &nbsp;&nbsp;&nbsp; 他<br>

  &nbsp;&nbsp;&nbsp; 開始<br>

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INSERT dbo.temp_table1<br>

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT c2<br>

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 差出人 @table1<br>

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHERE c1 = @i AND is_transient=1<br>

  <br>

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF @@ROWCOUNT &gt; 0<br>

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SET @i += 1<br>

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 他<br>

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SET @i = 0<br>

  &nbsp;&nbsp;&nbsp; 終わり<br>

  &nbsp; 終わり<br>

  <br>

  End<br>

  GO<br>

  -- proc のサンプル実行<br>

  DECLARE @table1 dbo.tt_table1<br>

  INSERT @table1 (c2, is_transient) VALUES (N&#39;サンプルの durable&#39;、0)<br>

  INSERT @table1 (c2, is_transient) VALUES (N&#39;サンプルの非永続的&#39;、1)<br>

  EXECUTE dbo.usp_ingest_table1 @table1=@table1<br>

  select c1, c2 from dbo.table1<br>

  SELECT c1, c2 from dbo.temp_table1<br>

  GO</div>


  <p>OLTP の機能を活用しIn-Memoryパフォーマンス上の利点を示すより包括的なサンプルについては、OLTP サンプルのインストールに<a href="https://azure.microsoft.com/en-us/documentation/articles/sql-database-in-memory/#a-install-the-in-memory-oltp-sample" title="https://azure.microsoft.com/en-us/documentation/articles/sql-database-in-memory/#a-install-the-in-memory-oltp-sample">関するIn-Memoryを参照してください。</a></p>


  <p>olTP In-Memory のリソース使用率の利点の上の図に使用されるスマート グリッドのサンプル データベースとワークロードについては、リリースとソース コードに<a href="https://github.com/Microsoft/sql-server-samples/releases/tag/iot-smart-grid-v1.0"></a>関するページを<a href="https://github.com/Microsoft/sql-server-samples/tree/master/samples/applications/iot-smart-grid">参照してください</a>。</p>


  <p>&nbsp;</p>


  <p><em>今すぐIn-Memory OLTP をお試Azure SQL Databaseしてみてください。</em></p>


  <h4>開始するリソース:</h4>


  <ul>
   <li>
   <p><a href="https://azure.microsoft.com/documentation/articles/sql-database-in-memory/">SQL In-MemoryのSQL Database</a></p>
   </li>
   <li>
   <p><a href="https://msdn.microsoft.com/library/mt694156.aspx">クイック スタート 1: T-SQL のパフォーマンスの高速化のためのインメモリ OLTP テクノロジ</a></p>
   </li>
   <li>
   <p><a href="https://azure.microsoft.com/en-us/documentation/articles/sql-database-in-memory-oltp-migration/">既存In-Memory Azure SQL アプリケーションで OLTP を使用します。</a></p>
   </li>
   <li>
   <p><a href="https://blogs.msdn.microsoft.com/sqlserverstorageengine/2016/03/21/improving-temp-table-and-table-variable-performance-using-memory-optimization/">Improving temp table and table variable performance using memory optimization</a></p>
   </li>
   <li>
   <p><a href="https://msdn.microsoft.com/library/mt590207.aspx">メモリ最適化テーブルでのシステム バージョン管理されたテンポラル テーブル</a></p>
   </li>
  </ul>
