### YamlMime:Yaml
ms.openlocfilehash: abf873161eaa5966c99abce866474e2dd18e2aca
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139895240"
Slug: using-the-azure-webjobs-sdk-to-create-custom-slack-extensions
Title: Azure WebJobs SDK を使用してカスタム Slack 統合を作成する
Summary: このブログ記事では、WebJobs 拡張機能を使用して Slack と話をする方法について説明します。 Slack は、"リアルタイム メッセージング" API または送信 Webhook を使用した優&アプリです。
Content: "<p>現在、開発者や企業は、これまでよりも多くの SaaS エクスペリエンスを使用しています。 SaaS サービスの多くのユーザーは、これらの SaaS サービスの機能をカスタマイズし、そのビジネス アプリケーションに取り込む必要がある場所にすばやく身を引きます。 SaaS サービスの拡張を探す最初の場所は、SaaS サービスと同様の <a href=\"https://azure.microsoft.com/en-us/services/app-service/\">paaS Azure App Service</a>。 このAzure App Service、エンタープライズ グレードの認証やアジャイル開発操作開発サイクルなど、シンプルでありながら重要な機能が、一番早く動作します。 Azure と一般に Microsoft には、他のサービスと統合する方法が数多く用意されています。最も強力な方法の 1 つは、Web ジョブAzure App Serviceです。</p>\n\n<p>このブログ記事では、Web ジョブ拡張機能&#39;Slack と話す方法について説明 <a href=\"https://slack.com/\">します</a>。 Slack は、リアルタイム メッセージング <a href=\"https://api.slack.com/rtm\">&quot;&quot; API</a> <a href=\"https://api.slack.com/incoming-webhooks\"></a> &amp; または受信した<a href=\"https://api.slack.com/outgoing-webhooks\">送信 Webhook</a> を使用した優らしい統合ストーリーを持つチーム向けメッセージング アプリです。 WebJobs SDK を使用すると<a href=\"https://api.slack.com/slash-commands\">&quot;&quot;</a>、Slack から送信コマンドとスラッシュ コマンド Webhook をリッスンして、アプリケーション内のプロセスを開始できます。 SDK 内から、1 日以内に作成したカスタム WebJobs 拡張機能を使用して Slack に直接メッセージを送信することもできます。</p>\n\n<p>コード&#39;取得します。</p>\n\n<h2 id=\"get-the-code-for-the-sample\">サンプルのコードを取得する</h2>\n\n<p>ソース コードに従う<a href=\"https://github.com/christopheranderson/azure-webjobs-sdk-extensions-slack\"><code>azure-webjobs-sdk-extensions-slack</code>場合は、リポジトリをフォークして複製GitHub勧めしています</a>。 また、このサンプルのサンプルのNuGetを取得する方法については、GitHubできます。</p>\n\n<h2 id=\"using-webjobs-to-send-message-to-slack-webhooks\">WebJobs を使用して Slack WebHook にメッセージを送信する</h2>\n\n<p>Slack にメッセージを送信するには、&#39;受信 Webhook の Slack カスタム統合メニューからそのエンドポイントを設定した後、&#39;が受信 Webhook エンドポイントへの HTTP 呼び出しを実行します。 Slack の Azure WebJobs 拡張機能を使用すると、アプリケーションに対して行うさまざまな自動化されたタスク内から、それらのメッセージを簡単に書式設定して&#39;Slack に送信できます。 一部のチームでは、Slack&#39;を使用して、さまざまな Stack Overflow タグとフォーラムからの質問や、User Voice からの顧客フィードバックを監視しています。 IFTTT などのサービスから Slack にデータを送信する方法は多数ありますが、カスタム コードを記述する必要がある場合は常に、そのコードをホストする場所を見つけるのが非常に簡単です。 Web ジョブ&#39;Slack にメッセージを送信する簡単な方法について説明します。</p>\n\n<p>プロジェクトへの参照を追加した&#39;Azure WebJobs Extension for Slack の使用を開始するには、WebJobs JobHost 構成で有効にする必要があります。</p>\n\n<pre class=\"prettyprint\">\n<code>var config = new JobHostConfiguration();\nvar slackConfig = new SlackConfiguration();\n\n// These are optional and will be applied if no other value is specified.\nslackConfig.WebHookUrl = &quot;&quot;;\n// IT IS A BAD THING TO HARDCODE YOUR WEBHOOKURL, USE THE APP SETTING &quot;AzureWebJobsSlackWebHookKeyName&quot;\nslackConfig.IconEmoji = &quot;:taco:&quot;;\nslackConfig.Username = &quot;Destroy All Humans&quot;;\nslackConfig.Channel = &quot;#bots_only_no_hummies&quot;;\n\nconfig.UseSlack(slackConfig);\n\nvar host = new JobHost(config);\n// The following code ensures that the WebJob will be running continuously\nhost.RunAndBlock();\n</code></pre>\n\n<p>この機能&#39;したら、WebJobs 関数内で Slack バインドを使用できます。 関数で Slack バインディングを使用する方法は非常に簡単です。 必要なのは、Slack バインドを WebJob SDK 関数に追加する必要があります。</p>\n\n<pre class=\"prettyprint\">\n<code>public void SimpleSlackBinding([WebHookTrigger] Message m,\n            [Slack(Text = &quot;{Text}&quot;, IconEmoji = &quot;{IconEmoji}&quot;)] SlackMessage message)\n</code></pre>\n\n<p>上記のスニペットでは、Slack バインディングを追加しました。このバインドは、グローバルな既定の設定を使用して SlackMessage <code>text</code> <code>iconEmoji</code> を作成し、トリガーによって生成されるメッセージ POCO (この場合は Webhook ですが、任意のトリガーである可能性があります) からライトライトを使って過剰に書き込まれます。&#39;</p>\n\n<p>提供 <code>SlackMessage</code> されるオブジェクトは、Slack に送信されるオブジェクトです。 関数によって が完了すると、JSON 本文にコンテンツが解析され、前に指定した Slack Webhook URL に POST されます。</p>\n\n<p>完全&#39;公開されているサンプルを次に示します。</p>\n\n<pre class=\"prettyprint\">\n<code>public void FullSlackBinding([WebHookTrigger] Message m,\n    [Slack(Channel = &quot;{Channel}&quot;, \n            IconEmoji = &quot;{IconEmoji}&quot;, \n            IsMarkdown = false, \n            Text =&quot;{Text}&quot;, \n            Username = &quot;{Username}&quot;, \n            WebHookUrl = &quot;{WebHookUrl}&quot;)] SlackMessage message,\n    TextWriter log\n    )\n{\n    // Further customize Slack Message here. i.e. add attachments, etc.\n    // More info on the SlackMessage object on the GitHub project: https://github.com/nerdfury/Slack.Webhooks\n\n    // Continue to set/manipulate properties on the Slack Message, programatically\n    message.Text += &quot;WebJobs are Grrrreat!&quot;;\n    message.IconEmoji = &quot;:troll:&quot;;\n\n    // For example, add attachments. See the Slack API docs for more info: https://api.slack.com/docs/attachments\n    message.Attachments.Add(new SlackAttachment\n    {\n        Fallback = &quot;Required plain-text summary of the attachment.&quot;,\n        Color = &quot;#36a64f&quot;,\n        pre class=&quot;prettyprint&quot;text = &quot;Optional text that appears above the attachment block&quot;,\n        AuthorName = &quot;Bobby Tables&quot;,\n        AuthorLink = &quot;https://flickr.com/bobby/&quot;,\n        AuthorIcon = &quot;https://flickr.com/icons/bobby.jpg&quot;,\n        Title = &quot;Slack API Documentation&quot;,\n        TitleLink = &quot;https://api.slack.com/&quot;,\n        Text = &quot;Optional text that appears within the attachment&quot;,\n        Fields = new List&lt;SlackField&gt;\n        {\n            new SlackField\n            {\n                Title = &quot;Priority&quot;,\n                Value = &quot;High&quot;,\n                Short = true\n            },\n            new SlackField\n            {\n                Title = &quot;Assigned&quot;,\n                Value = &quot;Bobby&quot;,\n                Short = true\n            }\n        },\n        ImageUrl = &quot;https://my-website.com/path/to/image.jpg&quot;,\n        ThumbUrl = &quot;https://example.com/path/to/thumb.png&quot;\n    });\n}\n</code></pre>\n\n<h2 id=\"using-webjobs-to-listen-to-slack-webhooks\">WebJobs を使用して Slack Webhook をリッスンする</h2>\n\n<p>Slack にメッセージを送信する方法は最適ですが、最もクールなシナリオの 1 つは、Slack を使用してアプリケーション内の初期ワークフローを行う方法です。 これを WebJobs で実現するには、 バインディングを使用 <code>WebHookTrigger</code> します。 pre class=&quot;prettyprintvious&quot;<code>WebHookTrigger</code> の例で確認できるよう、サービスで使用する POCO オブジェクトを出力する をバインドできます。</p>\n\n<pre class=\"prettyprint\">\n<code>public async Task SlackIniatedWebHook([WebHookTrigger] WebHookContext context\n</code></pre>\n\n<p>上記のコード サンプルでは、 属性を追加&#39;簡単な方法で Webhook を作成できる必要があるのを確認 <code>WebHookTrigger</code> できます。 この Webhook にアクセスするパスのスタイルは、 です <code>https://{uid}:{pwd}@{site}/api/continuouswebjobs/{job}/passthrough/{*path}</code>。</p>\n\n<p>Webhook URL を手動で作成するには、次のトークンを置き換える必要があります。</p>\n\n<ul>\n <li><strong>uid</strong> : これは、発行資格情報からのユーザー ID です。 発行資格情報は、このブログ記事で詳しく説明されているポータル <a href=\"https://blog.davidebbo.com/2015/05/scheduled-webjob.html\">からダウンロードできます。</a></li>\n <li><strong>pwd</strong> : これは、お使いの publising 資格情報からのパスワードです</li>\n <li><strong>site</strong> : SCM サイト (例: myapp.scm.azurewebsites.net)</li>\n <li><strong>job</strong> : Continuous WebJob の名前</li>\n <li><strong>path</strong> : これは、呼び出す特定の Webhook 関数を識別するルートです。 規則により、これは {ClassName}/{MethodName} ですが、 属性を使用して明示的にオーバーライドまたは指定 <code>WebHookTrigger</code> できます。</li>\n</ul>\n\n<p>たとえば&#39;webhook をリッスンしたいとします <code>slack/webhook</code>。 これを行うには、 属性の一部としてパスを渡します。</p>\n\n<pre class=\"prettyprint\">\n<code>public async Task SlackIniatedWebHook([WebHookTrigger(&quot;slack/webhook&quot;)] WebHookContext context\n</code></pre>\n\n<p>の完全なドキュメント<code>WebHookTrigger</code>については、<a href=\"https://github.com/Azure/azure-webjobs-sdk-extensions#webhooks\">WebJobs SDK 拡張機能</a>に関するページGitHubしてください。 このGitHub、WebHooks トリガーのインとアウトを学習できます。 次&#39;セクションでこのサンプルを展開し、Slack の受信 Webhook と送信 Webhook をまとめます。</p>\n\n<h2 id=\"bringing-it-all-together-slack-slash-commands\">すべての機能を組み合わせて使用する: Slack スラッシュ コマンド</h2>\n\n<p>エンド to エンドの状況の詳細を見てみしましょう。 スラッシュ コマンドを使用して を介して WebJob <code>WebHooksTrigger</code> を呼び出し、キューを使用して管理するワークフロー Azure Storageできます。 その後、ワークフローは、スラッシュ コマンドによって提供される応答 URL に応答できます。 念頭に置く必要がある点は、現在、応答 URL は約 5 分間だけ有効なので、ジョブの実行時間がそれより長い場合は、従来の受信 Webhook のみを使用する必要があります。 この例では、2&#39;を受け取るスラッシュ コマンドを使用します。1 つは作業項目の数を指定し、もう 1 つは実行する作業量を指定します。</p>\n\n<p>で&#39;を開始します <code>WebHookTrigger</code>。 リッスンをオンに <code>WebHookTrigger</code> し、 <code>slack/webhook</code> attribtue を介して一連の新しい Queue <code>Queue</code> メッセージを出力する必要があります。</p>\n\n<pre class=\"prettyprint\">\n<code>public async Task SlackIniatedWebHook([WebHookTrigger(&quot;slack/webhook&quot;)] WebHookContext context,\n    [Queue(&quot;SlackWork&quot;)] ICollector&lt;SlackWork&gt; messages\n)\n</code></pre>\n\n<p>関数パラメーターと属性を設定して、関数&#39;中のブシネ ロジックについて考えてみます。 コマンド テキストから の 2 つの整数を読み取り、作成&#39;キュー作業項目の数を作成します。 実行&#39;class=&quot;prettyprintsents&quot; を再設定するヘルパー POCO クラスを作成します。</p>\n\n<pre class=\"prettyprint\">\n<code>public class SlackWork\n{\n    public int id { get; set; }\n    public string username { get; set; }\n    public int work { get; set; }\n    public string replyUrl { get; set; }\n}\n</code></pre>\n\n<p>また、 <code>x-url-form-urlencoded</code> Slack を解析するヘルパー関数も作成します。これは本文を使用し、WebJobs&#39;まだ POCO に自動解析しません。</p>\n\n<pre class=\"prettyprint\">\n<code>private bool TryParseSlackBody(string body, out NameValueCollection nvc)\n{\n    body = body.Replace(&#39;\\n&#39;, &#39;&amp;&#39;);\n    body = body.Replace(&quot;\\r&quot;, &quot;&quot;);\n    nvc = System.Web.HttpUtility.ParseQueryString(body);\n\n    return nvc.Count &gt; 0;\n}\n</code></pre>\n\n<p>これで、コマンド テキストを解析し、エラー ケースを処理し、キュー作業項目を作成する関数を作成できます。</p>\n\n<pre class=\"prettyprint\">\n<code>public async Task SlackIniatedWebHook([WebHookTrigger(&quot;slack/webhook&quot;)] WebHookContext context,\n    [Queue(&quot;SlackWork&quot;)] ICollector&lt;SlackWork&gt; messages\n)\n{\n    // Try and parse the Slack Message Body with simple helper method\n    NameValueCollection nvc;\n    if(TryParseSlackBody(await context.Request.Content.ReadAsStringAsync(), out nvc))\n    {\n        Regex rgx = new Regex(&quot;(\\\\d+) (\\\\d+)&quot;);\n        Match match = rgx.Match(nvc[&quot;text&quot;]);\n        int count;\n        int work;\n        if(int.TryParse(match.Groups[1].Value, out count) &amp;&amp; int.TryParse(match.Groups[2].Value, out work))\n        {\n            for (int i = 0; i &lt; count; i++)\n            {\n                messages.Add(new SlackWork { id = i, work = work, replyUrl = nvc[&quot;response_url&quot;], username = nvc[&quot;user_name&quot;] });\n            }\n\n            // All good, quickly send an affirmative response\n            context.Response = new Httpre class=&quot;prettyprint&quot;sponseMessage(HttpStatusCode.Accepted)\n            {\n                Content = new StringContent(&quot;Message received! Processing ...&quot;)\n            };\n        }\n        else\n        {\n            // Not good, quick send a negative response\n            context.Response = new Httpre class=&quot;prettyprint&quot;sponseMessage(HttpStatusCode.Accepted)\n            {\n                Content = new StringContent(&quot;Incorrect format - please pass two numbers along - i.e. /cmd 2 30&quot;)\n            };\n\n            // We can stop here for the failure case\n            return;\n        }\n    }\n    else\n    {\n        // Not good, quick send a negative response\n        context.Response = new Httpre class=&quot;prettyprint&quot;sponseMessage(HttpStatusCode.Accepted)\n        {\n            Content = new StringContent(&quot;Something went wrong. :(&quot;)\n        };\n\n        // We can stop here for the failure case\n        return;\n    }\n\n\n}\n</code></pre>\n\n<p>作業項目を処理するには、新しいキュー項目で <code>QueueTrigger</code> 起動する を作成する必要があります。 この関数&quot;&quot;は、渡された作業量に対してスリープ状態になります (さらに、追加するランダム性係数&#39;)、実行する作業が 10 より大きい場合は、Slack 絵文字を&#39;に変更します<code>:tada:</code>。 Slack メッセージのテキストは、関数パラメーターと attribtues を使用して作成できます。</p>\n\n<pre class=\"prettyprint\">\n<code>public void ProcessSlackWork([QueueTrigger(&quot;SlackWork&quot;)] SlackWork work, \n    [Slack(WebHookUrl = &quot;{replyUrl}&quot;, Text = &quot;Item: {id} finished processing {work} seconds of work.&quot;, IconEmoji = &quot;:sleepy:&quot;, Channel = &quot;@{username}&quot;)] SlackMessage slack,\n    TextWriter log\n)\n{\n    log.WriteLine($&quot;Processing id: {work.id} - working for {work.work} seconds&quot;);\n\n\n    if(work.work &gt; 10)\n    {\n        slack.IconEmoji = &quot;:tada:&quot;;\n    }\n\n    int sleepFor = (work.work + (int)(.2 * work.work * (new Random()).NextDouble())) * 1000;\n    log.WriteLine($&quot;Processing id: {work.id} - actually working for {sleepFor} seconds, because of some made up, factor of error&quot;);\n    Thread.Sleep(sleepFor);\n}\n</code></pre>\n\n<p>これをローカルでテストするには、WebJob を実行し、 を押します <code>localhost:3000/slack/webhook</code>。 次のようなサンプル本文を渡します。</p>\n\n<pre class=\"prettyprint\">\n<code>token=gIkuvaNzQIHg97ATvDxqgjtO\nteam_id=T0001\nteam_domain=example\nchannel_id=C2147483705\nchannel_name=test\nuser_id=U2147483697\nuser_name=Steve\ncommand=/cmd\ntext=3 30\nresponse_url=https://hooks.slack.com/commands/1234/5678\n</code></pre>\n\n<p>次に、Web ジョブをアプリケーションにデプロイAzure App Service。 これを行うには、Web ジョブを Azure にデプロイするための手順に従って、Visual Studio<a href=\"https://azure.microsoft.com/en-us/documentation/articles/websites-dotnet-deploy-webjobs/\">を Azure.com</a>。</p>\n\n<p>最後に、&#39;を追加します。 Slack アプリ <a href=\"https://slack.com/apps\">ディレクトリに移動し、</a> 上部の [ &quot;構成]&quot; をクリックします。 ここから、Slack チームを選択し、[カスタム &quot;統合] に移動する必要があります&quot;。 このメニューから[スラッシュ コマンド] に移動 &quot;し、[&quot; 構成の追加] を &quot;クリックします&quot;。 ページの手順に従い、上のセクションで説明したパターンで URL を追加します。 必要なキーワード <code>/command</code> を&#39;使用できます。</p>\n\n<p>これで、実行する作業の量と動作時間を表す 2 つの整数を使用してコマンドを呼び出すことによって、WebJob を呼び出す方法が可能になります <code>/cmd 3 30</code>。</p>\n\n<h2 id=\"learn-more\">詳細情報</h2>\n\n<p>詳細については、次のリンクを参照してください。</p>\n\n<ul>\n <li><a href=\"https://azure.microsoft.com/en-us/documentation/articles/websites-webjobs-resources/\">Azure WebJobsリソース</a></li>\n <li><a href=\"https://api.slack.com/\">Slack API のドキュメント</a></li>\n <li><a href=\"https://github.com/Azure/azure-webjobs-sdk-extensions\">Azure WebJobs拡張機能GitHub</a></li>\n</ul>"
