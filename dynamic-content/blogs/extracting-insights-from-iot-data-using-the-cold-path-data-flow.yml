### YamlMime:Yaml
ms.openlocfilehash: e76d4bbf3712a7fa71e6d650c3b3bc123c7f435a
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139895973"
Slug: extracting-insights-from-iot-data-using-the-cold-path-data-flow
Title: コールドパスデータフローを使用した IoT データからの洞察の抽出
Summary: >+
  このブログは、マイクロソフトの業界の経験チームによって発行されたソリューションガイドの対象範囲を続けます。 このガイドでは、取り込みデータ、ホットパス処理、コールドパス処理、および分析クライアントの各コンポーネントについて説明します。 このブログ投稿では、ソリューションガイドのコールドパス処理コンポーネントについて説明します。

Content: "<p>このブログは、Microsoft &rsquo; の業界エクスペリエンスチームによって発行された<a href=\"https://aka.ms/manufacturingsolutionguide\" target=\"_blank\">ソリューションガイド</a>の範囲を続けています。 このガイドでは、次のコンポーネントについて説明します。</p>\n\n<ul>\n <li>データの取り込み</li>\n <li>ホットパスの処理</li>\n <li>コールドパスの処理</li>\n <li>Analytics クライアント</li>\n</ul>\n\n<p>ソリューションガイドで IoT アプリケーションのデータを処理するための推奨事項について説明し、データフローにラムダアーキテクチャを使用することをお勧めします。 データパスを繰り返し実行するには、次のようにします。</p>\n\n<ul>\n <li>Batch レイヤー (コールドパス) は、すべての受信データを未加工の形式で格納し、データに対してバッチ処理を実行します。 この処理の結果は、バッチ ビューとして保存されます。 これは、処理速度が遅いパイプラインで、複雑な分析を実行したり、複数のソースからのデータを長期間にわたって結合したり、レポートや機械学習モデルなどの新しい情報を生成したりします。</li>\n <li>速度レイヤーとサービスレイヤー (ウォームパス) は、リアルタイムでデータを分析します。 このレイヤーは、精度と引き換えに待機時間が短くなるように設計されています。 これは、受信メッセージをアーカイブして表示し、これらのレコードを分析して、短い重要な情報やアラームなどのアクションを生成する、より高速な処理パイプラインです。</li>\n</ul>\n\n<p>このブログ投稿では、ソリューションガイドのコールドパス処理コンポーネントについて説明します。</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/9f225d45-dcbb-4fdc-a864-550fdc3d4200.png\"><img alt=\"Cold path processing components of the solution guide\" border=\"0\" height=\"383\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/13466cad-60c0-4649-a28b-66c99bca853b.png\" style=\"margin: 0px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;\" title=\"ソリューションガイドのコールドパス処理コンポーネント\" width=\"776\"></a></p>\n\n<p>ソリューションガイドでは、 <a href=\"https://docs.microsoft.com/en-us/azure/time-series-insights/?WT.mc_id=iotinsightsblog-blog-ercenk\" target=\"_blank\">Azure Time Series Insights</a> (tsi) を使用した timeseries 分析について詳しく説明しました。 これは、データを timeseries するための分析、ストレージ、および視覚化サービスです。 TSI の使用方法については、関連するセクションを参照してください。</p>\n\n<p>前のブログ記事で思い出したように、NIST SMS テストベッドエンドポイントによって発行されたサンプルデータを使用しています。 以前の投稿は、イベント &rdquo; と &ldquo; サンプル &rdquo; データレコード用に別の &ldquo; Azure Event Hubs にプッシュされたデータで終了しました。</p>\n\n<p>説明の残りの部分を始める前に、分析 &rdquo; の問題の &ldquo; 解決策が各プラント、ライン、コンピューターなどに依存していることを強調したいと考えています。 データが使用可能であり、ビジネスのニーズに対応している必要があります。 データを整理するための2つの異なるアプローチについて説明しますが、これらは包括的なものではなく、例としてのみ使用されます。</p>\n\n<h2>生データの格納</h2>\n\n<p>このサンプル実装には、生データがポストされた Event Hubs から受信データストリームを取得し Azure Storage blob とテーブルにコピーする<a href=\"https://docs.microsoft.com/en-us/azure/stream-analytics/?WT.mc_id=iotinsightsblog-blog-ercenk\" target=\"_blank\">Azure Stream Analytics</a>クエリの基本的なセットが含まれています。 たとえば、クエリは次のようになります。</p>\n\n<pre>\nSELECT\n     *\nINTO\n     [samplesTable]\nFROM\n     [EventHubIn]</pre>\n\n<p>1つのテーブルはサンプル用で、もう1つはイベント用です。 カスタムコンポーネントで受信データをフラット化したので、次の C# コードスニペットを使用して、受信データストリームが入っていた <a href=\"https://github.com/MSIndustryExperiences/IoTInsights/blob/master/ingest/flattenandpost/src/FlattenAndPost.cs#L235\" target=\"_blank\">時間枠のプロパティ</a> を追加しました。これにより、処理パイプラインのデータをより簡単に整理することができます。</p>\n\n<pre>\nHourWindow =\n\n   new DateTime(\n       sample.timestamp.Year,\n       sample.timestamp.Month,\n       sample.timestamp.Day,\n       sample.timestamp.Hour,\n       0,\n       0),</pre>\n\n<p>このデータレコードフィールドは、Azure Storage テーブルのレコードをパーティションキーとして使用するだけで整理する場合に特に便利です。 入力レコードのシーケンス番号を行キーとして使用しています。 ストレージテーブルのオブジェクトモデルについては、「<a href=\"https://docs.microsoft.com/rest/api/storageservices/Understanding-the-Table-Service-Data-Model?WT.mc_id=iotinsightsblog-blog-ercenk\" target=\"_blank\">テーブルサービスデータモデルについ</a>て」を &ldquo; 参照してください。 &rdquo;ストレージテーブルの設計に関する推奨事項については、「 <a href=\"https://docs.microsoft.com/rest/api/storageservices/designing-a-scalable-partitioning-strategy-for-azure-table-storage?WT.mc_id=iotinsightsblog-blog-ercenk\" target=\"_blank\">Azure Table Storage 用のスケーラブルなパーティション分割方法の設計</a>」も参照 &ldquo; してください。 &rdquo;</p>\n\n<p>ASA ジョブによって生成される Azure Blob Storage blob は、1時間ごとにコンテナーにまとめられ、その時間のデータの1つの Blob としてコンマ区切り値 (CSV) 形式で構成されます。 これらは、将来人工知能 (AI) のニーズに対応するために使用されます。</p>\n\n<h2>Azure SQL Database へのデータの読み込み</h2>\n\n<p>ここでは、 <a href=\"https://docs.microsoft.com/en-us/azure/sql-database/?WT.mc_id=iotinsightsblog-blog-ercenk\" target=\"_blank\">Azure SQL Database</a>にレコードを増分読み込みする基本的な方法について説明し、後で、新しい集計と集計データを作成するために、さらに処理する方法について説明します。</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/ce89cb16-8404-46ac-b93a-42c6ce00d3d3.png\"><img alt=\"Loading data into Azure SQL Database\" border=\"0\" height=\"315\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/20d64a10-91d4-4195-8041-814ca2d764f8.png\" style=\"margin: 0px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;\" title=\"Azure SQL Database へのデータの読み込み\" width=\"709\"></a></p>\n\n<p>私たちの目標は、データがデータストアにどのように流れるかを示す interpolated.csproj アプローチを提供し、そのために役立つテクノロジを紹介することです。 分析ソリューションはコンテキストと要件に大きく依存しますが、関連する Azure サービスを示す基本的なメカニズムを提供しようとします。</p>\n\n<p><a href=\"https://docs.microsoft.com/en-us/azure/data-factory/?WT.mc_id=iotinsightsblog-blog-ercenk\" target=\"_blank\">Azure Data Factory</a> (ADF) は、自動化されたデータパイプラインでデータストレージ、移動、処理のサービスを構成するためのクラウド統合サービスです。 ストレージテーブルをソースとして使用するテーブルの増分読み込みを示す単純な ADF パイプラインが用意されています。</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/c30c821e-0a86-4787-8591-807a9158da9f.png\"><img alt=\"Azure Data Factory\" border=\"0\" height=\"128\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/ea67bd9f-c961-4f44-b443-56b67dee68a9.png\" style=\"margin: 0px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;\" title=\"Azure Data Factory\" width=\"496\"></a></p>\n\n<p>パイプラインには、SQL Database に対して次のクエリを実行するルックアップアクティビティがあります。</p>\n\n<pre>\nselect\n     CONVERT(\n         char(30),\n         case when  max(SampleTimestamp) is null then &#39;1/1/2010 12:00:00 AM&#39;\n             else max(SampleTimestamp) end, 126) as LastLoad\nfrom [Samples]</pre>\n\n<p>CONVERT 関数126で使用されるスタイルは、タイムスタンプ値として &ldquo; 書式設定されるタイムスタンプ値を表します。 yyyy-mm-ddthh: mi は、 &rdquo; ストレージテーブルのパーティションキー値の文字列形式に一致します。 このクエリは、SQL データベースに転送された最後のレコードを返します。 その後、その値を次のアクティビティに渡して、テーブルストレージに対してクエリを実行し、新しいレコードを取得することができます。</p>\n\n<p>次はデータコピー &rdquo; アクティビティであり &ldquo; 、lookup アクティビティから返された値 (lastload &rdquo; の &ldquo; 値) を使用し、次のテーブルクエリをソースに対して行います。 ストレージテーブルのクエリの詳細については <a href=\"https://docs.microsoft.com/rest/api/storageservices/querying-tables-and-entities?WT.mc_id=iotinsightsblog-blog-ercenk\" target=\"_blank\">、「テーブルとエンティティのクエリ</a> 」を参照してください。</p>\n\n<pre>\nSampleTimestamp gt datetime&#39;@{formatDateTime(activity(&#39;LookupSamples&#39;).output.FirstRow.LastLoad, &#39;yyyy-MM-ddThh:mm:ss.fffZ&#39;)}&#39;</pre>\n\n<p>このアクティビティは、後でストレージテーブルの列 (プロパティ) を SQL Database テーブルの列にマップします。 このパイプラインは15分ごとに実行されるようにスケジュールされているので、変換先 SQL Database テーブルを増分読み込みします。</p>\n\n<h3>処理の例</h3>\n\n<p>生データをさらに処理することは、実際の要件によって異なります。 このセクションでは、データを処理して整理するための2つの方法について説明します。</p>\n\n<p>まず、収集したデータから詳細を確認してみましょう &rsquo; 。 サンプルテーブルの生データは、名前と値のペアの形式であることに注意してください。 最初のクエリでは、各コンピューターによって記録されたさまざまなサンプルの種類を指定します。</p>\n\n<pre>\nSELECT DeviceName, ComponentName, SampleName, COUNT(SampleSequence) AS SampleCount\nFROM Samples\nGROUP BY DeviceName, ComponentName, SampleName \nORDER BY DeviceName ASC, ComponentName ASC, SampleName ASC, SampleCount DESC</pre>\n\n<p>8台のマシンがあることを確認し、それぞれが異なるサンプルの種類のセットを送信しています。 上記のクエリの結果の一部を次に示します。 Microsoft Excel の結果をもう少し分析して、サンプルの相対カウントを把握しています。</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/fc87e5c4-5a4d-4a19-8f61-a9c76f4c2728.png\"><img alt=\"Analysis of results in Microsoft Excel to give an idea of the relative counts of the samples.\" border=\"0\" height=\"521\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/45436e58-6c7c-4983-91f3-4578df0bd2f8.png\" style=\"margin: 0px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;\" title=\"Microsoft Excel の結果を分析して、サンプルの相対カウントを把握します。\" width=\"471\"></a></p>\n\n<p>結果の集計と集計を行う最善の方法は、コンピューターごとの生データテーブルなど、結果をコンピューター &mdash; 別に整理することです。</p>\n\n<p>ここでは、概念を説明するための手順を順を追って説明します。 一部の読者は、クエリを実装するためにより最適化された方法を見つけることができますが、ここでの目標は、概念を示す明確な例を提供することです。</p>\n\n<p>データをさらに処理するには、最初に次のように、名前と値のペアにある生データを転置します。</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/bc6eca08-c921-4e63-afde-62a393dc0f1a.png\"><img alt=\"You may also process the data by first transposing the raw data, which is in name value pairs\" border=\"0\" height=\"490\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/f308259f-20f3-478b-b9bb-3a1e1b755950.png\" style=\"margin: 0px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;\" title=\"最初に生データを転置してデータを処理することもできます。これは、名前と値のペアになります。\" width=\"911\"></a></p>\n\n<p>次のクエリを使用して、新しいテーブルを作成し、行全体を入れ替えることができます。 このクエリでは、コンポーネントを区別せず、コンピューター全体を表示することを前提としています。</p>\n\n<pre>\n; WITH Machine08SamplesTransposed AS\n(\n     SELECT * FROM\n     (\n         SELECT  SampleTimestamp, sampleName, CAST(sampleValue AS NUMERIC(20,3)) AS sampleValueNumeric\n         FROM Samples\n         WHERE\n             DeviceName = &#39;Machine08&#39; and ISNUMERIC(sampleValue) != 0\n     ) AS S\n    \n     PIVOT(\n         MAX(sampleValueNumeric)\n         FOR SampleName IN ([S2temp],\n             [Stemp],\n             [Zabs],\n             [Zfrt],\n             [S2load],\n             [Cfrt],\n             [total_time],\n             [Xabs],\n             [Xload],\n             [Fact],\n             [Cload],\n             [cut_time],\n             [Zload],\n             [S2rpm],\n             [Srpm],\n             [auto_time],\n             [Cdeg],\n             [Xfrt],\n             [S1load])\n         ) AS PivotTable\n         )\n\nSELECT * INTO Machine08Samples \nFROM Machine08SamplesTransposed</pre>\n\n<p>このクエリを ADF パイプラインに取り込むには、パラメーターを指定してストアドプロシージャに移動し、最後に読み込まれた行のみが取り込まれるようにして、SELECT * INTO &hellip; &rdquo; &ldquo; を * into &rdquo; &hellip; に変更 &ldquo; します。 SQL データベースリソースを効率的に使用するために、できるだけストアドプロシージャに依存することをお勧めします。</p>\n\n<p>結果のテーブルは次のようになります (簡潔にするためにいくつかの列が削除されました)。</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/b246babc-605f-40d3-8dbb-3016a6476971.png\"><img alt=\"Results table\" border=\"0\" height=\"421\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/8fb80e03-e7d7-425a-8120-d017fd6909fd.png\" style=\"margin: 0px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;\" title=\"結果テーブル\" width=\"997\"></a></p>\n\n<p>この中間データセットを処理する方法の1つとして、次に示すように、最後に受信した値からサンプルの null 値を入力する方法があります。</p>\n\n<p>すべてのビジネスケースとすべてのサンプル値に対してこのソリューションを推奨していないことを強調する必要があります。 この方法は、意味のある値に対して意味があります。 たとえば、特定のケースでは、グループ化ファクト (実際のパスフィードレート) と Zfrt (Z 軸のフィードレート) が理にかなっている可能性があります。 ただし、1つのレコードに対して Xabs (X 軸の絶対位置) と Zfrt を別のケースでグループ化した場合、この方法では意味がない可能性があります。 サンプル値のグループ化は、ビジネスニーズに応じて、ケースバイケースで実行する必要があります。</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/4169c0f4-2f28-401f-a9ab-46d526447a93.png\"><img alt=\"Grouping of the sample values\" border=\"0\" height=\"230\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/17a037b4-74df-4116-86fc-1e777aeac7ca.png\" style=\"margin: 0px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;\" title=\"サンプル値のグループ化\" width=\"1204\"></a></p>\n\n<p>別の方法として、個々のレコードを時間バケットに配置し、そのグループに集計関数を適用する方法があります。</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/069ce023-fd36-4ed6-8bcf-b553d8b53c77.png\"><img alt=\"Another way is to put the individual records into time buckets, and apply an aggregate function in that group.\" border=\"0\" height=\"230\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/3eb7217d-9628-4886-a47a-4fcfdb68bdb2.png\" style=\"margin: 0px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;\" title=\"もう1つの方法は、個々のレコードを時間バケットに配置し、そのグループに集計関数を適用することです。\" width=\"1200\"></a></p>\n\n<p>ここ &rsquo; では、最初のオプションを実現するための小さな例を紹介します。 前の例では、t1 で v1.1 を受け取り、t2 で v2.0 を受け取りました。 ここでは、t2 のサンプル1値に t1s, v1.1 を入力します。</p>\n\n<pre>\n;WITH NonNullRank AS\n(\n     SELECT SampleTimestamp, S2temp,  cnt = COUNT(s2temp) OVER (ORDER BY SampleTimestamp)\n     FROM Machine08Samples\n),\n\nWindowsWithNoValues AS\n(\n     SELECT SampleTimestamp, S2temp, \nr = ROW_NUMBER() OVER (PARTITION BY cnt ORDER BY SampleTimestamp ASC) - 1\n     FROM NonNullRank\n)\n\nSELECT SampleTimestamp, S2temp,\nS2tempWithValues= ISNULL(S2temp, LAG(S2temp, r) OVER (ORDER BY SampleTimestamp ASC))\nFROM WindowsWithNoValues</pre>\n\n<p>上記のクエリを詳しく分析すると、1つ目の共通テーブル式 (CTE) の非 Nullrank によって、受信したデータレコードの S2temp sample 値の null 以外の値のランクが得られます。</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/ab986b60-a7be-4d80-a9bb-969d903354eb.png\"><img alt=\"Common table expression (CTE)\" border=\"0\" height=\"400\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/bd73cc2c-6154-4114-9185-28ab570d2a64.png\" style=\"margin: 0px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;\" title=\"共通テーブル式 (CTE)\" width=\"274\"></a></p>\n\n<p>2つ目の CTE である WindowsWithNoValues は、受信した値が先頭にあるサンプルのウィンドウと、ウィンドウ内の null 値の順序 (列 r) を提供します。</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/da8cdee9-c909-4f2f-8bb8-7fcd34cde4cb.png\"><img alt=\"The second CTE, Windows With No Values\" border=\"0\" height=\"404\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/c439ec81-74de-452f-895e-dad121f50916.png\" style=\"margin: 0px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;\" title=\"2番目の CTE、値が指定されていない Windows\" width=\"273\"></a></p>\n\n<p>結論となるクエリは、ウィンドウの上部から現在の行までの受信値を取得することによって、LAG 分析関数を使用して null 値を入力します。</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/ce884a16-fd62-4dee-a7dd-d70cd294714b.png\"><img alt=\"The concluding query fills in the null values using the LAG analytic function.\" border=\"0\" height=\"401\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/732e4486-499f-4705-8ae7-d66712214b9a.png\" style=\"margin: 0px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;\" title=\"結論となるクエリは、LAG 分析関数を使用して null 値を入力します。\" width=\"350\"></a></p>\n\n<p>前に説明した2番目のオプションは、受け取った値をグループ化し、グループ内に集計関数を適用することです。</p>\n\n<pre>\n;WITH With30SecondBuckets AS\n(\n     SELECT *,\n(dateadd(second,(datediff\n(second,&#39;2010-1-1&#39;,[SampleTimestamp])/(30))*(30),&#39;2010-1-1&#39;))\nAS  [SampleTimestamp30Seconds]\n     FROM Machine08Samples\n)\n\nSELECT SampleTimestamp30Seconds, AVG(S2Temp)\nFROM With30SecondBuckets GROUP BY SampleTimestamp30Seconds\nORDER BY SampleTimestamp30Seconds</pre>\n\n<p>これらのクエリをストアドプロシージャに配置して、分析ソリューションで使用するために必要に応じて新しい集計テーブルと概要テーブルを生成することができます。</p>\n\n<p>ここで、開いている引数をさらに繰り返します。 分析の問題に対する解決策は、使用可能なデータとビジネスニーズによって異なります。 1つのソリューションが存在しない場合もありますが、Azure には特定のソリューションを実装するための多くのテクノロジオプションが用意されています。</p>\n\n<h2>次の手順</h2>\n\n<ul>\n <li>Spark アクティビティとオンデマンドの Azure HDInsight のリンクされたサービスを使用して、クラウド内のデータを変換する ADF <a href=\"https://docs.microsoft.com/en-us/azure/data-factory/tutorial-transform-data-spark-portal?WT.mc_id=iotinsightsblog-blog-ercenk\" target=\"_blank\">チュートリアル</a> を完了して、別の例を確認してください。</li>\n <li>ソリューション ガイドから IoT データから分析情報を抽出するための大きな画像 <a href=\"https://aka.ms/manufacturingsolutionguide\" target=\"_blank\">を取得します</a>。</li>\n</ul>"
