### YamlMime:Yaml
ms.openlocfilehash: e633f830754396cd460606d11c52504d40b4aa15
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139889510"
Slug: creating-primary-keys-across-databases
Title: データベース間での主キーの作成
Summary: '[この記事は SQL Azure チームによって提供されました。]複数の SQL Azure データベース間でデータを水平方向にパーティション分割する場合、または SQL Azure にデータ同期 Server を使用する場合は、時間がかかることがあります。'
Content: <p>[この記事は SQL Azure チームによって提供されました。]</p><p>複数の SQL Azure データベース間でデータを水平方向にパーティション分割する場合、または SQL Azure にデータ同期 Server を使用する場合は、主キーのマージの競合を発生させずに、メンバーデータベースに書き込む必要がある場合があります。 この場合は、すべてのデータベースで一意の主キーを生成できる必要があります。 この記事では、主キーとその長所と短所を生成するさまざまな手法について説明します。</p>  <h2>UniqueIdentifier</h2>  <p>一意の主キーを生成する方法の1つとして、NEWID () 関数を Transact SQL で使用します。これにより、GUID が<strong>uniqueidentifier</strong>データ型として生成されます。 GUID は、すべてのデータベースで一意であることが保証されます。</p>  <p>長所:</p>  <ul>   <li>これは、SQL Azure するネイティブな型です。</li>    <li>非常に大きいので、Guid が不足することはありません。</li>    <li>は、行方向のパーティション分割とデータ同期サービスの両方で動作します。</li> </ul>  <p>不利益</p>  <ul>   <li>この手法を使用する場合の短所は、GUID に基づいています。生成されたデータベースを識別する方法はありません。 これにより、行方向のパーティション分割を行うときに余分な複雑さが生じる可能性があります。</li>    <li><strong>Uniqueidentifier</strong>データ型は large で、行のサイズに追加されます。 </li> </ul>  <h2>Bigint </h2>  <p>もう1つのオプションは、 <strong>int</strong>の代わりに<b>bigint</b>データ型を使用する方法です。この手法では、主キーが id 列であることから生成されます。ただし、各データベースの各 id は異なるオフセットで開始されます。 オフセットが異なる場合は、競合していない主キーを作成します。</p>  <p>最初に質問するのは、主キーのニーズをすべて表すのに十分な <b>bigint</b> データ型です。 <b>BigInt</b>データ型は8バイトで格納されるため、9223372036854775807のようにサイズが大きくなることがあります。 これは、 <b>int</b> データ型の最大サイズ (2147483647) より4294967298倍です。 これは、40億の SQL Azure データベースを、約20億行のテーブルで水平方向にパーティション分割できる可能性があることを意味します。 データ型とサイズの詳細については、 <a href="https://msdn.microsoft.com/en-us/library/ms187745.aspx">こちら</a>を参照してください。</p>  <p>最初の SQL Azure データベースで、次のようなテーブルを作成します。</p>  <pre class="csharpcode"><span class="kwrd">CREATE</span> <span class="kwrd">TABLE</span> TEST(x bigint <span class="kwrd">PRIMARY</span> <span class="kwrd">KEY</span> <span class="kwrd">IDENTITY</span> (1,1))</pre>      <p>2番目の SQL Azure データベースで、次のようなテーブルを作成します。</p>    <pre class="csharpcode"><span class="kwrd">CREATE</span> <span class="kwrd">TABLE</span> TEST(x bigint <span class="kwrd">PRIMARY</span> <span class="kwrd">KEY</span> <span class="kwrd">IDENTITY</span> (2147483648,1))</pre>      <p>さらに、行方向のパーティション分割で、各データベースのシード値のインクリメントを続けます。</p>    <p>長所:</p>    <ul>    <li>主キーとして <b>int</b> データ型を使用したレガシテーブルから <b>bigint</b> データ型にアップグレードする方が簡単です (レガシテーブルは最初のパーティションになります)。</li>      <li>他のいくつかの手法よりも簡単に修復できます。これは、行の移動には、(再計算されたハッシュではなく) ストレートの case ステートメントが含まれるためです。</li>      <li>パーティション分割を実装するデータ層コードでは、主キーの <strong>uniqueidentifier</strong> を使用する場合とは異なり、主キーが存在するパーティションを調べることができます。</li>      <li><b>Bigint</b>データ型では、8バイトの領域が使用されます。これは、16バイトを占有する<b>uniqueidentifier</b>データ型よりも小さくなります。</li>  </ul>    <p>短所:</p>    <ul>    <li>各パーティションのデータベーススキーマが異なります。</li>      <li>この手法は、行方向のパーティション分割では適切に機能しますが、データ同期サービスには適していません。</li>  </ul>    <h2>主キープール</h2>    <p>この手法では、すべての主キーが格納されている単一の id データベースが構築されます。ただし、データは含まれません。 この id データベースには、自動インクリメント id として整数 (<b>int</b> データ型) の単一の列を含む、一致するテーブルのセットが含まれています。 パーティション全体のいずれかのテーブルで挿入が必要な場合は、データ層コードによって id データベースに挿入され、@ @IDENTITY がフェッチされます。 Id データベースのこの主キーは、メンバーデータベースまたはパーティションに挿入する主キーとして使用されます。 Id データベースはキーを生成しているので、競合は発生しません。</p>    <p>SQL Azure データベースに格納できる整数の数は 50 gb ですか。 主キープールとして機能しているデータベースの領域が不足している場合は、その行を挿入できないため、これは良い質問です。 すべてのテーブルで、主キーデータベースの単一の列整数が使用されている場合は、200万行の25000テーブル (テーブルサイズは 2 mb) を50ギガバイト SQL Azure データベースに格納できます。 現在、50ギガバイトは、主キーデータベースに使用できる最大の SQL Azure データベースです。 または、400万行の12000テーブル、または800万行の6000テーブルなど、このような組み合わせがあります。</p>    <p>長所:</p>    <ul>    <li>これは、レガシテーブルで実装する最も簡単な手法です。データ型の変更はありません。 ただし、IDENTITY 属性は、データテーブルから削除する必要があります。</li>      <li>は、行方向のパーティション分割とデータ同期サービスの両方で動作します。</li>  </ul>    <p>短所:</p>    <ul>    <li>この手法は、主キーデータベースの競合が問題にならない、低書き込みの高読み取りシナリオで最適に機能します。</li>      <li>データデータベースとプライマリデータベースが同じデータセンターにない場合は特に、すべての挿入で、プライマリデータベースに対する追加のクエリが必要になり、パフォーマンスの問題が発生する可能性があります。</li>      <li>データ層レイヤーでは、データが主キーからどのパーティションに格納されているかを特定することはできません。 このため、読み取りと書き込みを行う既知のメンバーデータベースがあるデータ同期サービスに最適です。 </li>      <li>最大 50 gb バイト SQL Azure データベースで保持できる主キー (<b>int</b>データ型) の数には制約があります。これは、パーティション全体の行数に関する制限です。</li>  </ul>    <h2>2列の主キー</h2>    <p>もう1つの方法は、2つの列を使用して主キーを表すことです。 最初の列は、パーティションまたはメンバーデータベースを指定する整数です。 2番目の列は、整数の ID であり、自動的にインクリメントされます。 複数のメンバーまたはパーティションデータベースでは、2番目の列には競合が発生しますが、2つの列を組み合わせて一意の主キーが作成されます。</p>    <p>2列の主キーを持つ CREATE TABLE ステートメントの例を次に示します。</p>    <pre class="csharpcode"><span class="kwrd">CREATE</span> <span class="kwrd">TABLE</span> TEST ([partition] <span class="kwrd">int</span>,       [id] <span class="kwrd">int</span> <span class="kwrd">IDENTITY</span>,       <span class="kwrd">CONSTRAINT</span> PK_TEST           <span class="kwrd">PRIMARY</span> <span class="kwrd">KEY</span>([partition], [id]));</pre>      <p>すべての主キーに対して2番目の列を追加し、すべての外部キー参照に2番目の列を追加する必要があることに注意してください。</p>    <p>長所:</p>    <ul>    <li>列を追加してレガシテーブルからアップグレードする方が簡単です。そのため、これらのテーブルを <strong>uniqueidentifier</strong> 主キーに変換します。 </li>      <li>2つの整数は、8バイトの領域を使用します。これは、16バイトを占有する <b>uniqueidentifier</b> データ型よりも小さくなります。</li>      <li>は、行方向のパーティション分割とデータ同期サービスの両方で動作します。</li>      <li>パーティション分割を実装するデータ層コードでは、主キーの <strong>uniqueidentifier</strong> を使用する場合とは異なり、主キーが存在するパーティションを調べることができます。</li>  </ul>    <p>短所:</p>    <ul>    <li>2つの列を主キーとして使用するのは、不自然で面倒であると感じています。</li>      <li>データ層コードは、主キーにアクセスするために2つの整数を追跡する必要があります。 これは、 <a href="https://msdn.microsoft.com/en-us/library/ah19swz4(VS.71).aspx">C# のカスタム<b>構造体</b></a>のような新しいデータ型を作成するために言語要素を使用して難読化できます。</li>  </ul>    <h2>まとめ</h2>    <p>同じ問題を解決するためのお気に入りの手法がありますか。以下のコメントで、お客様と共有してください。 または、どのような技法が最適であるかについてのご意見をお寄せください。 質問、懸念事項、コメントをお持ちですか? これらを下に投稿してください。</p>
