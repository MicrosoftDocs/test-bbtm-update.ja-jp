### YamlMime:Yaml
ms.openlocfilehash: 2c7c94193151f66d0d9a4392d85967595009d026
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139909621"
Slug: monitoring-azure-media-services-application
Title: Azure Media Services アプリケーションの監視
Summary: この記事では、Media Services 上に構築されたアプリケーションの監視システムを計画するための出発点として使用できるサンプルコードを提供します。
Content: "監視は、運用オンラインアプリケーションの重要なコンポーネントです。 適切に実装された監視システムを使用すると、主要なイベントのアラートを受信し、適切に対応できます。 この投稿では、Media Services アカウントを監視するために記述したサンプルコードをいくつか紹介します。 このサンプルコードを出発点として使用して、Media Services 上に構築されたアプリケーション用の独自のカスタム監視システムの計画を開始することができます。\n\n&nbsp;\n<h2>サンプル コード</h2>\n大まかに言えば、提供されるサンプルコードは、サービスに対して一定の間隔でコードを実行するという原則に基づいて機能します。 操作の結果がログに記録され、コードの別の部分によってログにエラーがないかどうかが定期的にチェックされます。 プログラミングされたエラー状態がトリガーされると、アラートが発生します。 このため、コードは2つの Visual Studio プロジェクトに分割されます。 最初のプロジェクトは、定期的に Media Services asset api の作成と削除を呼び出し、結果を Azure テーブルに記録します。 2番目のプロジェクトは、Azure テーブルの上位5つのエントリを定期的にチェックしてエラーを確認し、5つのエントリすべてがエラーとして記録された場合にアラートを発生させます。\n\n最初のプロジェクトの App.config は次のとおりです。\n<pre class=\"prettyprint\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;configuration&gt;\n  &lt;startup&gt;\n    &lt;supportedRuntime version=\"v4.0\" sku=\".NETFramework,Version=v4.5\" /&gt;\n  &lt;/startup&gt;\n  &lt;appSettings&gt;\n    &lt;add key=\"MediaServicesAccountName\" value=\"&lt;MediaAccountName&gt;\" /&gt;\n    &lt;add key=\"MediaServicesAccountKey\" value=\"&lt;MediaAccountKey&gt;\" /&gt;\n    &lt;add key=\"StorageConnectionString\" value=\"DefaultEndpointsProtocol=https;AccountName=&lt;StorageAccountName&gt;;AccountKey=&lt;StorageAccountKey&gt;\" /&gt;\n  &lt;/appSettings&gt;\n  &lt;runtime&gt;\n    &lt;assemblyBinding xmlns=\"urn:schemas-microsoft-com:asm.v1\"&gt;\n      &lt;dependentAssembly&gt;\n        &lt;assemblyIdentity name=\"Microsoft.WindowsAzure.Storage\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" /&gt;\n        &lt;bindingRedirect oldVersion=\"0.0.0.0-4.1.0.0\" newVersion=\"4.1.0.0\" /&gt;\n      &lt;/dependentAssembly&gt;\n    &lt;/assemblyBinding&gt;\n  &lt;/runtime&gt;\n&lt;/configuration&gt;</pre>\nmediaaccountname &gt; と &lt; MediaAccountKey &gt; を、 &lt; 監視する Media Services アカウントの名前とキーに置き換えます。 同様に、storageaccountname &gt; と &lt; StorageAccountKey &gt; を、監視データをログに記録するストレージアカウントの名前とキーに置き換え &lt; ます。\n\n&nbsp;\n\n監視を実行するコードは次のとおりです。 前述のように、コードは無限ループで実行され、1分ごとに Media Services api を呼び出して資産を作成してから削除します。 API 呼び出しが失敗した場合、Azure テーブルに失敗のエントリが記録されます。それ以外の場合は、成功のエントリがログに記録されます。 使用される関数の説明は、コード自体の下にあります。\n<pre class=\"prettyprint\">using System;\nusing System.Linq;\nusing System.Configuration;\nusing System.IO;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing Microsoft.WindowsAzure;\nusing Microsoft.WindowsAzure.Storage;\nusing Microsoft.WindowsAzure.Storage.Blob;\nusing Microsoft.WindowsAzure.Storage.Table;\nusing Microsoft.WindowsAzure.MediaServices.Client;\n\nnamespace Monitoring\n{\n    /// &lt;summary&gt;\n    /// \n    /// &lt;/summary&gt;\n    public class AssetLogEntity : TableEntity\n    {\n        public int Status { get; set; }        \n        public string FailureData { get; set; }\n    }\n\n    /// &lt;summary&gt;\n    /// \n    /// &lt;/summary&gt;\n    class Program\n    {\n        // Read values from the App.config file.\n        private static readonly string _mediaServicesAccountName =\n            ConfigurationManager.AppSettings[\"MediaServicesAccountName\"];\n        private static readonly string _mediaServicesAccountKey =\n            ConfigurationManager.AppSettings[\"MediaServicesAccountKey\"];\n        private static readonly string _storageConnectionString =\n            ConfigurationManager.AppSettings[\"StorageConnectionString\"];\n\n        private static CloudStorageAccount _cloudStorage = null;\n        private static CloudTableClient _tableClient = null;\n        private static CloudTable _monitoringTable = null;\n\n        // Field for service context.\n        private static CloudMediaContext _context = null;\n        private static MediaServicesCredentials _cachedCredentials = null;\n\n        /// &lt;summary&gt;\n        /// \n        /// &lt;/summary&gt;\n        /// &lt;param name=\"args\"&gt;&lt;/param&gt;\n        static void Main(string[] args)\n        {\n            try\n            {\n                // Create and cache the Media Services credentials in a static class variable.\n                _cachedCredentials = new MediaServicesCredentials(\n                                _mediaServicesAccountName,\n                                _mediaServicesAccountKey);\n                // Used the chached credentials to create CloudMediaContext.\n                _context = new CloudMediaContext(_cachedCredentials);\n\n                _cloudStorage = CloudStorageAccount.Parse(_storageConnectionString);\n                _tableClient = _cloudStorage.CreateCloudTableClient();\n\n                _monitoringTable = _tableClient.GetTableReference(\"MonitoringData\");\n                _monitoringTable.CreateIfNotExists();\n\n                Monitor();\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// \n        /// &lt;/summary&gt;\n        static void Monitor()\n        {\n            try\n            {\n                while (true)\n                {\n                    try\n                    {\n                        Console.WriteLine(\"Starting Monitoring loop: \" + DateTime.Now.ToString());\n                        IAsset _asset = _context.Assets.Create(\"Monitoring Asset\", AssetCreationOptions.None);\n                        if (_asset == null)\n                        {\n                            LogMonitoringData(1, \"Create Asset returned null\");\n                        }\n                        else\n                        {\n                            _asset.Delete();\n                        }\n\n                        LogMonitoringData(0);\n                    }\n                    catch (Exception x)\n                    {\n                        Console.WriteLine(x.Message);\n                        LogMonitoringData(1, x.Message);\n                    }\n\n                    Console.WriteLine(\"Going to sleep for a minute\");\n                    Console.WriteLine(\"\");\n                    Thread.Sleep(1000 * 60);\n                }\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// \n        /// &lt;/summary&gt;\n        static void LogMonitoringData(int status, string _failureData = \"\")\n        {\n            try\n            {\n                AssetLogEntity _assetLogEntity = new AssetLogEntity();\n                _assetLogEntity.PartitionKey = \"Asset\";\n                _assetLogEntity.RowKey = (DateTime.MaxValue.Ticks - DateTime.Now.Ticks).ToString(\"D12\");\n                _assetLogEntity.Status = status;\n                _assetLogEntity.FailureData = _failureData;\n\n                TableOperation op = TableOperation.Insert(_assetLogEntity);\n                _monitoringTable.Execute(op);\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message);\n            }\n        }\n    }\n}</pre>\nコードは非常に単純です。 次に簡単な説明を示します。\n<ul>\n <li><strong>AssetLogEntity </strong>–このクラスは、テーブルエンティティを定義します。 上記のコードでは、成功の場合は0、失敗の場合は1という状態がログに記録されます。 FailureData 文字列は、Status = 1 の場合にエラーメッセージを書き出すために使用されます。</li>\n <li><strong>main</strong> – main 関数は、Media Services アカウントコンテキストを作成します。 その後、まだ存在していない場合は、 <strong>Monitoringdata</strong> Azure テーブルを作成します。 最後に、 <strong>Monitor</strong> 関数を呼び出します。</li>\n <li><strong>Monitor </strong>–これは主要な監視コードです。 関数は、無限 while ループで実行されます。 1分ごとに、Media Services アカウントコンテキストを使用して資産を作成し、削除します。 成功した場合、Api は成功をログに記録し、 <strong>Logmonitoringdata</strong> 関数を呼び出してエラーをログに記録します。</li>\n <li><strong>Logmonitoringdata</strong> –この関数は、データを <strong>monitoringdata</strong> テーブルに書き込む実際のタスクを実行します。 最新のログ項目が一番上にあることを確認するために、現在の DataTime から最大 DateTime 値を減算することによって計算される rowkey を使用します。 これは、Azure テーブルが項目を昇順で列挙するためです。</li>\n</ul>\n&nbsp;\n\n2番目のプロジェクトの App.config は次のとおりです。\n<pre class=\"prettyprint\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;configuration&gt;\n  &lt;startup&gt;\n    &lt;supportedRuntime version=\"v4.0\" sku=\".NETFramework,Version=v4.5\" /&gt;\n  &lt;/startup&gt;\n  &lt;appSettings&gt;\n    &lt;add key=\"StorageConnectionString\" value=\"DefaultEndpointsProtocol=https;AccountName=&lt;StorageAccountName&gt;;AccountKey=&lt;StorageAccountKey&gt;\" /&gt;\n  &lt;/appSettings&gt;\n  &lt;runtime&gt;\n    &lt;assemblyBinding xmlns=\"urn:schemas-microsoft-com:asm.v1\"&gt;\n      &lt;dependentAssembly&gt;\n        &lt;assemblyIdentity name=\"Microsoft.WindowsAzure.Storage\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" /&gt;\n        &lt;bindingRedirect oldVersion=\"0.0.0.0-4.1.0.0\" newVersion=\"4.1.0.0\" /&gt;\n      &lt;/dependentAssembly&gt;\n    &lt;/assemblyBinding&gt;\n  &lt;/runtime&gt;\n&lt;/configuration&gt;</pre>\n構成ファイルは最初のプロジェクトに似ていますが、Media Services アカウントの資格情報がない点が異なります (このプロジェクトでは、 <strong>monitoringdata</strong>テーブルのエントリにのみ焦点を当てます)。 大まかに言えば、このコードは無限ループで実行され、1分ごとに5つの連続する失敗エントリが記録されたかどうかを確認します。 そうであれば、アラートが生成されます。 コードは次のようになり、その後にコード内の関数の簡単な説明が続きます。\n<pre class=\"prettyprint\">using Microsoft.WindowsAzure.Storage;\nusing Microsoft.WindowsAzure.Storage.Table;\nusing System;\nusing System.Collections.Generic;\nusing System.Configuration;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace Alerts\n{\n    /// &lt;summary&gt;\n    /// \n    /// &lt;/summary&gt;\n    public class AssetLogEntity : TableEntity\n    {\n        public int Status { get; set; }\n        public string FailureData { get; set; }\n    }\n\n    class Program\n    {\n        private static readonly string _storageConnectionString =\n            ConfigurationManager.AppSettings[\"StorageConnectionString\"];\n\n        private static CloudStorageAccount _cloudStorage = null;\n        private static CloudTableClient _tableClient = null;\n        private static CloudTable _monitoringTable = null;\n\n        /// &lt;summary&gt;\n        /// \n        /// &lt;/summary&gt;\n        /// &lt;param name=\"args\"&gt;&lt;/param&gt;\n        static void Main(string[] args)\n        {\n            try\n            {\n                _cloudStorage = CloudStorageAccount.Parse(_storageConnectionString);\n                _tableClient = _cloudStorage.CreateCloudTableClient();\n\n                _monitoringTable = _tableClient.GetTableReference(\"MonitoringData\");\n                _monitoringTable.CreateIfNotExists();\n\n                CheckforFailures();\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// \n        /// &lt;/summary&gt;\n        static void CheckforFailures()\n        {\n            while (true)\n            {\n                try\n                {\n                    Console.WriteLine(\"Starting failure checking loop \" + DateTime.Now.ToString());\n                    TableQuery&lt;AssetLogEntity&gt; query = new TableQuery&lt;AssetLogEntity&gt;().Where(TableQuery.GenerateFilterCondition(\"PartitionKey\", QueryComparisons.Equal, \"Asset\"));\n                    query.Take(5);\n\n                    TableQuerySegment&lt;AssetLogEntity&gt; tqs = _monitoringTable.ExecuteQuerySegmented(query, null);\n                    if ((tqs != null) &amp;&amp; (tqs.Results != null))\n                    {\n                        if (tqs.Results.Count == 5)\n                        {\n                            bool _fireAlert = true;\n                            for (int i = 0; i &lt; tqs.Results.Count; i++)\n                            {\n                                if (tqs.Results[i].Status == 0)\n                                {\n                                    _fireAlert = false;\n                                    break;\n                                }\n                            }\n\n                            if (_fireAlert)\n                            {\n                                Console.WriteLine(\"More than 5 consecutive failures detected\");\n                            }\n                        }\n                    }\n\n                    Console.WriteLine(\"Going to sleep for a minute\");\n                    Console.WriteLine(\"\");\n                    Thread.Sleep(1000 * 60);\n                }\n                catch (Exception ex)\n                {\n                    Console.WriteLine(ex.Message);\n                }\n            }\n        }\n    }\n}</pre>\nコードの簡単な説明を次に示します。\n<ul>\n <li><strong>AssetLogEntity </strong>–これは、最初のプロジェクトと同じです。</li>\n <li><strong>main </strong>– main 関数は、 <strong>monitoringdata</strong> テーブルへの参照を作成し、 <strong>checkforfailures</strong> 関数を呼び出します。</li>\n <li><strong>Checkforfailures</strong> –この関数は、無限ループをループします。 1分ごとに、 <strong>Monitoringdata</strong> テーブルの上位5つのエントリが取得され、5つのエントリすべてが失敗したかどうかが確認されます。 [はい] の場合、画面にメッセージを出力することによってアラートが生成されます。</li>\n</ul>\n&nbsp;\n\n障害をシミュレートするために、Azure 管理ポータルに移動して、Media Services アカウントに関連付けられている Storage アカウントのキーを再生成しました。 この操作により、Media Services アカウントが資産のコンテナーを作成するために Storage アカウントにアクセスできなくなり、その結果、最初のプロジェクトで createasset の呼び出しが失敗します。 5分以上待機した後、Azure 管理ポータルに戻り、[プライマリキーの同期] ボタンをクリックしてストレージキーを同期しました (次のスクリーンショットを参照してください)。\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/07/2014-07-18_12h05_23.png\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"2014-07-18_12h05_23\" alt=\"2014-07-18_12h05_23\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2014-07-18_12h05_23_thumb.png\" width=\"623\" height=\"484\" border=\"0\" /></a>\n\nこの操作により、Media Services アカウントが数分後に再び機能するようになりました。 次に、 <strong>Monitoringdata</strong> テーブルのエントリのスクリーンショットを示します。 エラーに対応するエントリを強調表示しました。\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/07/2014-07-17_16h08_11-LogTable.png\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"2014-07-17_16h08_11-LogTable\" alt=\"2014-07-17_16h08_11-LogTable\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2014-07-17_16h08_11-LogTable_thumb.png\" width=\"1028\" height=\"623\" border=\"0\" /></a>\n\n次に示すのは、上記の2つのサンプルコードプロジェクトに関連付けられているコンソールウィンドウのスクリーンショットです。 どちらのスクリーンショットにも、エラー期間が記載されています。\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/07/2014-07-17_16h03_30-Monitoring.png\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"2014-07-17_16h03_30-監視\" alt=\"2014-07-17_16h03_30-Monitoring\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2014-07-17_16h03_30-Monitoring_thumb.png\" width=\"696\" height=\"772\" border=\"0\" /></a>\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/07/2014-07-17_16h04_16-Alerts.png\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"2014-07-17_16h04_16-アラート\" alt=\"2014-07-17_16h04_16-Alerts\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2014-07-17_16h04_16-Alerts_thumb.png\" width=\"744\" height=\"772\" border=\"0\" /></a>\n\n&nbsp;\n<h2>考慮事項</h2>\nこのトピックのいくつかの終わりの解説\n<ul>\n <li>Media Services アカウントに関連付けられているストレージアカウントを使用して、 <strong>monitoringdata</strong>テーブルを作成しませんでした。 実際には、別のデータセンターでストレージアカウントを使用しました。 このサンプルでは、Media Services アカウント自体に関連したエラー状況をシミュレートしましたが、ネットワークの問題や、メディアアプリケーションがホストされているデータセンターのストレージサービスの問題に関連するエラーをキャッチする場合は、監視データを別の場所に記述することをお勧めします。 監視と警告コードを実行する場所にも同じことが当てはまります。 ここでは、Media Services アカウントが配置されているデータセンターの外部から、上記の2つのサンプルコードを実行しました。</li>\n <li>監視頻度とアラート条件を慎重に選択します。 非常に機密性の高い監視システムによって、誤アラートが過剰に発生します。</li>\n <li>適切に設計された監視システムを使用すると、複数の Azure データセンター内の複数のインスタンスで実行されている<a href=\"https://en.wikipedia.org/wiki/High_availability\">高可用性</a>アプリケーションを構築するときに、<a href=\"https://en.wikipedia.org/wiki/Failover\">フェールオーバー</a>とフェールバックを自動化できます。</li>\n <li>上記のサンプルでは、Media Services アカウント自体を監視しています。 Media Services 上に構築されたアプリケーションの監視にも、同じ原則を使用することを検討してください。</li>\n <li>また、上記のサンプルの原則を使用して、アプリケーションが依存している他の Azure サービスを監視することもできます。</li>\n</ul>"
