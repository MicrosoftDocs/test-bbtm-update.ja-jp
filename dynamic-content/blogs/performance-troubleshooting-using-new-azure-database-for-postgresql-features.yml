### YamlMime:Yaml
ms.openlocfilehash: b941d2d06628ecdac9e52a6248dd41d96ae2e84e
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139903993"
Slug: performance-troubleshooting-using-new-azure-database-for-postgresql-features
Title: Azure Database for PostgreSQL の新機能を使用したパフォーマンスのトラブルシューティング
Summary: Ignite 2018 では、お客様からのフィードバックに応じてパフォーマンスのトラブルシューティングを容易にするために、マイクロソフトの Azure Database for PostgreSQL がクエリストア (QS)、Query Performance Insight (QPI)、およびパフォーマンスに関する推奨事項 (PR) のプレビューを発表しました。 このブログでは、いくつかの一般的なシナリオのトラブルシューティングに使用できる機能を使用する方法について、アイデアを提供する予定です。
Content: "<p>Ignite Azure Database for PostgreSQL 2018 &rsquo; では、お客様からのフィードバックに応じてパフォーマンスのトラブルシューティングを容易にするために、クエリストア (QS)、Query Performance Insight (QPI)、およびパフォーマンスに関する推奨事項 (PR) のプレビューが <a href=\"https://azure.microsoft.com/en-us/blog/latest-updates-to-open-source-database-services-for-azure-ignite-2018\" target=\"_blank\">発表</a> されました。 このブログでは、いくつかの一般的なシナリオのトラブルシューティングに使用できる機能を使用する方法について、アイデアを提供する予定です。</p>\n\n<p><a href=\"https://azure.microsoft.com/en-us/blog/performance-best-practices-for-using-azure-database-for-postgresql/\" target=\"_blank\">パフォーマンスのベストプラクティス</a>に関する以前のブログ投稿では、使用しているアプリケーションパターンに基づいて問題が発生している可能性のあるレイヤーについて触れています。 このブログでは、問題領域をいくつかの領域に分類し、一般的な手法を利用して、根本原因をすばやく把握できるようにします。 新たに発表されたこれらの機能 (QS、QPI、PR) を使用して、さらに拡張することを希望しています。</p>\n\n<p>これらの機能を使用するには、 <strong>query_capture_mode を pg_qs 設定 pgms_wait_sampling し、query_capture_mode を ALL に</strong>設定して、データ収集を有効にする必要があります。</p>\n\n<p><strong><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/7df716f3-3bdb-4da0-9a2a-8eed9d5725c0.png\"><img alt=\"New features on Azure Database for PostgreSQL\" border=\"0\" height=\"379\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/d125a2ad-7e33-48db-95c5-863faa95f8a6.png\" style=\"margin: 0px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;\" title=\"Azure Database for PostgreSQL の新機能\" width=\"1607\"></a></strong></p>\n\n<p>クエリストアを使用すると、さまざまなシナリオでデータ収集を有効にし、これらのシナリオのトラブルシューティングを容易にすることができます。 この記事では、スコープを低下した queries に限定するシナリオについて説明します。</p>\n\n<h2>低下したクエリ</h2>\n\n<p>クエリストアが監視に使用できる重要なシナリオの1つは、 <strong>低下したクエリ</strong>です。 Query_capture_mode を<strong>ALL</strong>に<strong>pg_qs</strong>設定すると、時間の経過と共にクエリのパフォーマンスの履歴が得られます。 このデータを活用して、ニーズに基づいてシンプルまたは複雑な比較を行うことができます。</p>\n\n<p>低下したクエリリストを生成するときに直面する課題の1つは、クエリの実行時統計のベースラインを指定する比較期間を選択することです。 比較期間を選択する場合は、次の点を考慮する必要があります。</p>\n\n<ul>\n <li><strong>季節</strong>性: ワークロードまたは懸案事項のクエリは、継続的にではなく定期的に発生しますか。</li>\n <li><strong>履歴</strong>: 十分な履歴データがありますか。</li>\n <li><strong>しきい値</strong>: 一定の割合の変化のしきい値を使い慣れていないか、回帰の統計的な意味を証明するためにより複雑な方法を必要としていますか。</li>\n</ul>\n\n<p>では、 &rsquo; ワークロードに季節性がないと仮定して、既定の7日間の履歴では、低下したクエリを選択する変更の単純なしきい値を評価するのに十分であることを想定しています。 必要な作業は、ベースラインの開始時刻と終了時刻を選択し、テストの開始時刻と終了時刻を選択して、追跡するメトリックの回帰の量を計算することだけです。</p>\n\n<p>過去7日間の履歴を見ると、最後の2時間の実行と比較して、上位の低下したクエリが降順の割合で並べ替えられます。 結果セットに負の値が含まれている場合は、ベースラインがゼロになると &rsquo; テスト期間が向上したことを示しています。これは、基準期間中に変更されていないか、実行されていない可能性があることに注意してください。</p>\n\n<pre>\ncreate or replace function get_ordered_query_performance_changes(\nbaseline_interval_start int,\nbaseline_interval_type text,\ncurrent_interval_start int,\ncurrent_interval_type text)\nreturns table (\n     query_id bigint,\n     baseline_value numeric,\n     current_value numeric,\n     percent_change numeric\n) as $$\nwith data_set as (\nselect query_id\n, round(avg( case when start_time &gt;= current_timestamp - ($1 || $2)::interval and start_time &lt; current_timestamp - ($3 || $4)::interval then mean_time else 0 end )::numeric,2) as baseline_value\n, round(avg( case when start_time &gt;= current_timestamp - ($3 || $4)::interval then mean_time else 0 end )::numeric,2) as current_value\nfrom query_store.qs_view where query_id != 0 and user_id != 10 group by query_id ) , \nquery_regression_data as (\nselect *\n, round(( case when baseline_value = 0 then 0 else (100*(current_value - baseline_value) / baseline_value) end )::numeric,2) as percent_change \nfrom data_set ) \nselect * from query_regression_data order by percent_change desc;\n$$\nlanguage &#39;sql&#39;;</pre>\n\n<p>この関数を作成し、次のように実行すると、過去7日間の2時間前の計算されたベースライン値と比較して、直近の2時間の上位の低下したクエリが降順で取得されます。</p>\n\n<pre>\nselect * from get_ordered_query_performance_changes (7, &#39;days&#39;, 2, &#39;hours&#39;);</pre>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/0815ff55-718c-4087-bd8a-3fe7d29e84a5.png\"><img alt=\"Query performance\" border=\"0\" height=\"289\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/ff43913d-284a-405c-82d5-8991dfa13f00.png\" style=\"margin: 0px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;\" title=\"クエリパフォーマンス\" width=\"483\"></a></p>\n\n<p>ベースライン期間からのデルタの種類が予想される場合を除き、上位の変更は、データのサイズが変化したりトランザクションの量が増加したりすることがわかっている場合を除いて、後で行うことをお勧めします。 さらに調査するクエリを特定したら、次の手順として、クエリストアのデータに注目し、ベースライン統計が現在の期間とどのように比較され、さらに手掛かりを収集するかを確認します。</p>\n\n<pre>\ncreate or replace function compare_baseline_to_current_by_query_id(baseline_interval_cutoff int,baseline_interval_type text,query_id bigint,percentile decimal default 1.00)\nreturns table(\n     query_id bigint,\n     period text,\n     percentile numeric,\n     total_time numeric,\n     min_time numeric,\n     max_time numeric,\n     rows numeric,\n     shared_blks_hit numeric,\n     shared_blks_read numeric,\n     shared_blks_dirtied numeric,\n     shared_blks_written numeric,\n     local_blks_hit numeric,\n     local_blks_read numeric,\n     local_blks_dirtied numeric,\n     local_blks_written numeric,\n     temp_blks_read numeric,\n     temp_blks_written numeric,\n     blk_read_time numeric,\n     blk_write_time numeric\n)\nas $$\n\nwith data_set as\n( select *\n, ( case when start_time &gt;= current_timestamp - ($1 || $2)::interval then &#39;current&#39; else &#39;baseline&#39; end ) as period\nfrom query_store.qs_view where query_id = ( $3 )\n)\nselect query_id\n, period\n, round((case when $4 &lt;= 1 then 100 * $4 else $4 end)::numeric,2) as percentile\n, round(percentile_cont($4) within group ( order by total_time asc)::numeric,2) as total_time\n, round(percentile_cont($4) within group ( order by min_time asc)::numeric,2) as min_time\n, round(percentile_cont($4) within group ( order by max_time asc)::numeric,2) as max_time\n, round(percentile_cont($4) within group ( order by rows asc)::numeric,2) as rows\n, round(percentile_cont($4) within group ( order by shared_blks_hit asc)::numeric,2) as shared_blks_hit\n, round(percentile_cont($4) within group ( order by shared_blks_read asc)::numeric,2) as shared_blks_read\n, round(percentile_cont($4) within group ( order by shared_blks_dirtied asc)::numeric,2) as shared_blks_dirtied\n, round(percentile_cont($4) within group ( order by shared_blks_written asc)::numeric,2) as shared_blks_written\n, round(percentile_cont($4) within group ( order by local_blks_hit asc)::numeric,2) as local_blks_hit\n, round(percentile_cont($4) within group ( order by local_blks_read asc)::numeric,2) as local_blks_read\n, round(percentile_cont($4) within group ( order by local_blks_dirtied asc)::numeric,2) as local_blks_dirtied\n, round(percentile_cont($4) within group ( order by local_blks_written asc)::numeric,2) as local_blks_written\n, round(percentile_cont($4) within group ( order by temp_blks_read asc)::numeric,2) as temp_blks_read\n, round(percentile_cont($4) within group ( order by temp_blks_written asc)::numeric,2) as temp_blks_written\n, round(percentile_cont($4) within group ( order by blk_read_time asc)::numeric,2) as blk_read_time\n, round(percentile_cont($4) within group ( order by blk_write_time asc)::numeric,2) as blk_write_time\nfrom data_set\ngroup by 1, 2\norder by 1, 2 asc;\n$$\nlanguage &#39;sql&#39;;</pre>\n\n<p>関数を作成したら、調査するクエリ id を指定します。 関数は、指定したカットオフ時間に基づいて、前と後の間の集計値を比較します。 たとえば、次のステートメントでは、2時間前から2時間前までのすべての地点を、クエリに対して2時間後にマークアップするように指定しています。 除外する外れ値がわかっている場合は、パーセンタイル値を使用できます。</p>\n\n<pre>\nselect * from compare_baseline_to_current_by_query_id(30, &#39;minutes&#39;, 4271834468, 0.95);</pre>\n\n<p>&rsquo;を使用しない場合、既定値は、すべてのデータポイントを含む100です。</p>\n\n<pre>\nselect * from compare_baseline_to_current_by_query_id(2, &#39;hours&#39;, 4271834468);</pre>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/5e676856-576d-4681-8d86-d6d328612940.png\"><img alt=\"Query performances\" border=\"0\" height=\"90\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/8edbd5c2-7942-48f6-96a8-e200f5cd7c81.png\" style=\"margin: 0px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;\" title=\"クエリのパフォーマンス\" width=\"1713\"></a></p>\n\n<p>大きなデータサイズの変更がなく、キャッシュヒット率が安定していることを除外する場合は、同じ期間内に発生した明確な待機イベントの変更を調査することもできます。 待機イベントの種類によって、異なる待機の種類が性質に似たバケットに結合されるため、データを分析する方法については1つの処方箋がありません。 ただし、一般的な比較では、システム状態の変化に関するアイデアを得ることができます。</p>\n\n<pre>\ncreate or replace function compare_baseline_to_current_by_wait_event (baseline_interval_start int,baseline_interval_type text,current_interval_start int,current_interval_type text)\nreturns table(\n     wait_event text,\n     baseline_count bigint,\n     current_count bigint,\n     current_to_baseline_factor double precision,\n     percent_change numeric\n)\nas $$\nwith data_set as\n( select event_type || &#39;:&#39; || event as wait_event\n, sum( case when start_time &gt;= current_timestamp - ($1 || $2)::interval and start_time &lt; current_timestamp - ($3 || $4)::interval then 1 else 0 end ) as baseline_count\n, sum( case when start_time &gt;= current_timestamp - ($3 || $4)::interval then 1 else 0 end ) as current_count\n, extract(epoch from ( $1 || $2 ) ::interval) / extract(epoch from ( $3 || $4 ) ::interval) as current_to_baseline_factor\nfrom query_store.pgms_wait_sampling_view where query_id != 0\ngroup by event_type || &#39;:&#39; || event\n) ,\nwait_event_data as\n( select *\n, round(( case when baseline_count = 0 then 0 else (100*((current_to_baseline_factor*current_count) - baseline_count) / baseline_count) end )::numeric,2) as percent_change\nfrom data_set\n)\nselect * from wait_event_data order by percent_change desc;\n$$\nlanguage &#39;sql&#39;;\n\nselect * from compare_baseline_to_current_by_wait_event (7, &#39;days&#39;, 2, &#39;hours&#39;);</pre>\n\n<p>上記のクエリを実行すると、2つの期間の間に異常な変更がいくつか表示されます。 ここでのイベントカウントは近似値として取得され、数値は、指定された時間におけるインスタンスの比較負荷のコンテキスト内で取得される必要があることに注意してください。</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/0bbc0dc9-18df-4dae-b675-36854248d316.png\"><img alt=\"Queries\" border=\"0\" height=\"165\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/50e7c13a-c2dd-46b3-bb82-c6f3900f3c9a.png\" style=\"margin: 0px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;\" title=\"問い合わせ\" width=\"748\"></a></p>\n\n<p>ご覧のように、使用可能な時系列データがクエリストアであれば、ここで実装できる分析とアルゴリズムの種類には創造性があります。 単純な計算をいくつか紹介しました。これにより、候補を特定して改善するための直接的な方法を適用できます。 これは出発点として考えられます。私たちが何 &rsquo; をしているのかということを願っています。</p>\n\n<p>お客様からのフィードバックを常にお待ちしております。</p>\n\n<h2>謝辞</h2>\n\n<p>シニアデータ科学者の Korhan Ileri に感謝し、このブログ投稿への投稿については、プリンシパルデータサイエンスマネージャー Intaik パークおよび Saikat に感謝します。</p>"
