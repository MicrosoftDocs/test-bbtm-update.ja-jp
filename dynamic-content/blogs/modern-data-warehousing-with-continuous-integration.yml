### YamlMime:Yaml
ms.openlocfilehash: 4a9eb9ff02d70009a7d7b4651775909381d5831e
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139890369"
Slug: modern-data-warehousing-with-continuous-integration
Title: 継続的インテグレーションを使用した最新のデータ ウェアハウス
Summary: API (.NET) ベースのアプリケーションに一般的な CI プラクティスを採用することで、データ ウェアハウスを開発する従来の方法を超えた一歩を踏み出します。 これは、データ ウェアハウスに対して長い間保留されています。..
Content: >-
  <p><em>この投稿は、Mohit Chand(Microsoft IT プリンシパル SWE リード) によって共同執筆されました。 </em></p>


  <p>API (.NET) ベースのアプリケーションに対してより一般的な CI プラクティスを採用することで、データ ウェアハウスを開発する従来の方法を超える一歩を踏み出します。 データ ウェアハウス チームが最新のソフトウェア エンジニアリング プラクティスに追いつくのは、長い間保留されています。 Visual Studio Online (VSTS) SQL Server Data Tools (SSDT) &amp; が登場し、環境をオンザフライで回転することにより、自動化を最大限に活用した環境間でのコードのデプロイが容易になります。 これらの最新のプラクティスを採用して、Business インサイト (DW) プロジェクトのエンジニアリングの生産性を向上しました。 SSDT と VSTS の支援を受け、DW のデプロイをアジャイル リリース (2 週間スプリント) と完全に調整しました。 このブログでは、アプリケーションの CI を実装する方法について詳しく説明Data Warehouse。 コードの分岐、pull-request-triggered-build、Azure リソースと環境のプロビジョニング、スキーマのデプロイ、シード データの生成、自動テストを使用した毎日の統合リリース、およびより高い環境に新しいコードを昇格するための承認ベースのワークフローから始まるビジネス ユーザー ストーリーのライフ サイクルについて説明します。</p>


  <h2>DevOps</h2>


  <p>なぜDevOps? 従来の開発および運用モデルでは、&rsquo;ソフトウェアが期待した通り機能しない場合、混乱と議論が常に発生する可能性があります。 Dev は、それぞれの環境で適切に動作するソフトウェアを要求し、Ops の問題としてそれを防御します。 Ops は、Devs が実稼働&rsquo;可能なソフトウェアを提供しなかったことを示し、Dev&rsquo; の問題を示します。 これを解決するにはどうすれば良いでしょうか。 1&rsquo; つのチームが開発、テスト、運用を行うのは良い考えでしょうか。</p>


  <p>ビジネスや他の利害関係のある保有者と密接に関わる作業を行い、より優れた迅速な結果を顧客に効率的に提供します。 DevOps、技術的負債とリスクを軽減しながら、顧客とのより良い接続で迅速に提供できるようになりました。</p>


  <p>&nbsp;</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/08739887-4d45-4bd6-a6a7-21af3fa8c7e3.png"><img alt="DevOps" border="0" height="240" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/f2c166bc-ab31-4260-8167-2d06248b8ff0.png" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" title="DevOps" width="514"></a></p>


  <h2>DW アーキテクチャ</h2>


  <p>この方法Data Warehouse Azure テクノロジを使用します。 データは、さまざまなソースからランディング ゾーンまたはステージング領域に到着し、Azure Data Factory。 データをAzure Data Factory (ADF) ジョブを使用して、データをウェアハウスに変換します。 準備ができたら、ディメンション テーブルとファクト テーブルの形式で顧客がデータを使用できます。</p>


  <p>&nbsp;</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/150c1301-3ac0-47a7-b49d-84fe19cca014.png"><img alt="DWArchitecture" border="0" height="415" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/dcb7566d-c0c6-4410-94bf-f243976b4472.png" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" title="DWArchitecture" width="717"></a></p>


  <h4>ツール/テクノロジ</h4>


  <p>この最新のData Warehouse主に Microsoft テクノロジを使用してソリューションを顧客に提供します。</p>


  <ul>
   <li>SQL Azure (PaaS)</li>
   <li>Azure Data Factory</li>
   <li>Azure Blob Storage</li>
   <li>SQL MDS 2016</li>
   <li>Visual Studio Team Services (VSTS)
   <ul>
    <li>
    <ul>
     <li>アジャイルおよびかんばんボード</li>
     <li>コードの分岐 (Git)</li>
     <li>ゲート チェックイン</li>
     <li>自動テスト</li>
     <li>ビルド</li>
     <li>Release</li>
    </ul>
    </li>
   </ul>
   </li>
  </ul>


  <h2>プラン</h2>


  <p>アジャイル スクラムでは、ユーザー ストーリーが実装の単位です。 エンジニアは、特定のスプリントでユーザー ストーリーを取得して配信します。</p>


  <p>&nbsp;</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/d670ace0-9db3-409a-964f-7742e1df426a.jpg"><img alt="Story" border="0" height="218" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/bfabb0a8-3119-43a3-a955-6c284aa2c21d.jpg" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" title="話" width="817"></a></p>


  <h2>コード</h2>


  <h4>分岐戦略</h4>


  <p>アジャイル コードの分岐は重要な役割を果たします。 これを行うには、スプリント分岐、機能の分岐、ストーリー/バグの分岐など、さまざまな方法があります。この例では、ユーザー ストーリー レベルの分岐を採用しました。 共同作成者は、自分が受け取った各 &ldquo;ストーリーに対して、開発&rdquo; ブランチからブランチを作成します。 この分離された&rsquo;&ldquo;ブランチを維持し、ストーリーが完了またはコード レビューの準備ができたら、開発ブランチで Pull Request&rdquo; を作成してマージする必要があります。 共同作成者は、自分のコードをメイン ストリーム ブランチに直接マージすることはできません。 コードを承認するには、少なくとも 2 つのコード レビューが必要です。</p>


  <p>ストーリー ベースの分岐を使用すると、開発者はコード<strong></strong>をメイン ストリームと頻繁にマージし、同じブランチで長時間動作しないようにすることができます。 これにより、コード統合の問題が大幅に軽減されます。 もう 1 つの利点は、開発者が&rsquo;他の開発者コードを使用する頻度を高くすることで、より効率的に作業できるという利点です。 コードの依存関係の待機時間が短縮され、開発者のブロックが少なくなります。</p>


  <p>VSTS を使用して、共同作成者は新しいブランチを作成します。</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/e0e1b132-8e1f-4c48-8757-64e8095edc02.png"><img alt="Branch-1" border="0" height="276" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/c7f237a5-1d09-4b83-905c-2dda07c36eab.png" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" title="Branch-1" width="335"></a></p>


  <p>Nomenclature の後に続く名前は &lt;共同作成者名&gt;_&lt;ストーリーまたはバグです&gt;</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/d48d3b6a-4bae-426e-838c-05ce0b345d96.png"><img alt="Branch-2" border="0" height="280" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/04093714-aa83-4841-acc2-acf18ba6fa3d.png" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" title="Branch-2" width="599"></a></p>


  <p>ブランチを作成した後、共同作成者によって発行され、チームの他の全員に表示されます。</p>


  <p>&nbsp;<a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/be086e86-4d79-4af6-b826-6291a042e029.png"><img alt="Branch-3" border="0" height="478" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/6b853f47-d841-48fe-a6b2-b4b550075a28.png" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" title="Branch-3" width="480"></a></p>


  <p>分岐が設定されると、共同作成者はすべてストーリーから始まり、機能を実装するコードの記述を開始します。</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/d455f43d-004c-43a3-b089-9ec8f36f4bec.png"><img alt="Checkin-1" border="0" height="359" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/f588162a-195c-4b71-9140-918485c22fe9.png" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" title="Checkin-1" width="287"></a></p>


  <h3>コード レビューとコードマージ</h3>


  <p>コードが完了すると、開発者はコードを確認し、VSTS ポータルを使用してpull requestを作成します。 より高いレベルのコード品質を&rsquo;確保するには、ゲートチェックイン プロセスを実行する必要があります。 各開発者は、コードをチェックインするときにビルドが破損していない必要があります。 コードは、メイン ストリームとマージされる前に、少なくとも 2 つのピアによって確認および承認される必要があります。 2 つのコード レビュー承認がない&rsquo;場合、コードをメイン ストリーム コードとマージできない。</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/0cb0eec6-ff98-43cf-b48b-42adb6ff5fd6.png"><img alt="PullRequest-1" border="0" height="224" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/3c918294-b477-4598-af0f-b3b9ccb425b8.png" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" title="PullRequest-1" width="538"></a></p>


  <p>開発者pull request作成され、適切なコメントと作業項目と一緒に送信されます。</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/ed143bdd-f418-446d-a1b4-5dd636521238.png"><img alt="PullRequest-2" border="0" height="701" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/c997c5a3-0117-4171-9e7e-084b81586ef2.png" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" title="PullRequest-2" width="830"></a></p>


  <p>&nbsp;</p>


  <h3>ビルド</h3>


  <p>共同作成者によって &ldquo;Pull Request が&rdquo; 作成されるとすぐに、CI ビルドが自動的に起動されます。</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/3eeebf48-e2a3-4634-9e7b-05a5b7da2c4a.png"><img alt="Build-1" border="0" height="274" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/3b3b6f33-04af-4e81-9557-f5cbe97314d0.png" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" title="Build-1" width="693"></a></p>


  <p>&nbsp;</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/927eb45a-f720-4066-b61b-4c9f077140bb.png"><img alt="Build-2" border="0" height="399" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/9cd6cd82-5de1-41af-868d-34e5927cb0fb.png" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" title="Build-2" width="690"></a></p>


  <p>すべてのレビュー担当者が電子メール通知を受信 &ldquo;し、共同作成者によって作成された新しい Pull Request&rdquo; に関する情報を更新します。 レビュー担当者は、コード レビューを開始するのも良い方法です。</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/b3dd56a9-03b6-4ddd-8734-689798531f80.png"><img alt="CodeReview-1" border="0" height="268" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/10481211-7307-492c-b9f7-08a8d53895af.png" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" title="CodeReview-1" width="747"></a></p>


  <p>&nbsp;</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/0dd019c6-fd3e-451a-b204-8d153772ee87.png"><img alt="CodeReview-2" border="0" height="406" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/8295b351-3b1d-472e-b711-b861115f2f78.png" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" title="CodeReview-2" width="668"></a></p>


  <p>レビューアーは、コードの品質に応 &ldquo;じて、コードを承認&rdquo;、質問、または &ldquo;拒否&rdquo; します。</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/1cfd4f7c-8216-4034-b282-1451c8cfc936.png"><img alt="CodeReview-3" border="0" height="391" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/aed57027-ac4a-47ed-87c2-c5ac5a9dc6ad.png" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" title="CodeReview-3" width="437"></a></p>


  <p>すべてのレビュー担当者がコード レビューを完了すると、リード開発者はコードをメイン ストリームとマージします。</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/54ebe553-b3ac-4dca-af85-33c00cd4c163.png"><img alt="CodeReview-4" border="0" height="398" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/8fb7437a-815b-443a-bc6a-00f05a1c2c0a.png" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" title="CodeReview-4" width="423"></a></p>


  <h2>テスト (オートメーション)</h2>


  <p>DW プロジェクトでは、環境によってデータが異なる可能性があるため、さまざまな環境で高いコード品質を確保するには困難な場合があります。 新しいコードを作成する前に、すべての新しいコードに自動テスト ケースが含pull request。 これにより、バグが実稼働環境に漏れるのを防ぐだけでなく、成果物の品質も向上しました。</p>


  <p>次の図は、テスト ケースの実行結果全体を示しています。 デプロイの一環として、すべてのテスト ケースを実行して、エンド 製品の整合性と品質を確保します。</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/1ae10f24-3f47-4998-94ed-e37b434e3b02.png"><img alt="TestCases-1" border="0" height="188" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/50c8915d-d22f-47ed-b8e2-902b6ebd7483.png" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" title="TestCases-1" width="726"></a></p>


  <h2>リリースの &amp; デプロイ</h2>


  <p>コードがメイン ストリーム コードと正常にマージされると、新しいビルドが自動的に起動されます。 統合環境は、最新のコードを使用して 1 日に 1 回デプロイされます。</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/42ca0503-001f-40bf-8b7e-68a5c794c4d6.png"><img alt="Release-1" border="0" height="323" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/9f8df944-9bde-49e8-a8b8-c8204e4edffa.png" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" title="Release-1" width="606"></a></p>


  <p>&nbsp;</p>


  <p>次の図は、管理する 3 つの環境を示Data Warehouse。 統合、&ldquo;エンド&rdquo; ユーザー&ldquo;、および実稼働&rdquo;環境&rdquo;&ldquo;があります。 統合環境は、継続的インテグレーション&ldquo;とデプロイ環境であり、動的にプロビジョニングおよびプロビジョニングが取り出され、コードとして<strong>インフラストラクチャとして管理されます</strong>&rdquo;。 これは、毎日行う&ldquo;&rdquo;チェックインを統合するために、次の手順を順に実行するスケジュールされたプロセスです。</p>


  <ul>
   <li>開発ブランチから最新の情報を取得して新しいビットをビルドする (統合コード スキャンを含む)</li>
   <li>新しい Azure リソース グループを作成し、新しいリソース SQLします</li>
   <li>シード データ&ldquo;を新しく&rdquo;作成されたインスタンスにSQLする</li>
   <li>スキーマの名前変更を実行する</li>
   <li>DACPAC をデプロイして新しいスキーマ変更をデプロイする</li>
   <li>手順を迅速に実行するためにデータベースをスケールアップする</li>
   <li>コード ビットをビルド サーバーにコピーする</li>
   <li>追加のエンティティSQLデプロイする</li>
   <li>データ同期ジョブを実行する</li>
   <li>テスト アセンブリを実行する</li>
   <li>Azure Data Factories をデプロイする</li>
   <li>使用停止環境</li>
  </ul>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/9d7817d1-35d0-4c0b-a3e8-1b369f8d1569.png"><img alt="Release-2" border="0" height="770" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/ec63cc26-6eb2-41ef-868b-4fbc6b42eef4.png" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" title="Release-2" width="709"></a></p>


  <h4>データをシードして自動テストを有効にする</h4>


  <p>DW での自動テストは、正確なデータの可用性に大きな依存します。 データがない場合、テストできない多数のシナリオが発生します。 この問題を解決するために、デプロイ時にデータの実稼働コピーをシード &ldquo;データとして&rdquo; 使用します。 次の図は、日次統合環境 (DIT) でシード データを設定する方法を示しています。 データが非常に大きい場合は、レプリカ全体をコピーする代わりに、実稼働データのサブセットを含むサブタイプ DB を使用できます。</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/8c64f49c-3df7-4b63-a25a-71b2d4f1e5ee.png"><img alt="SeedData" border="0" height="254" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/7db2f4a8-1806-4396-9f02-a9ebad86a35c.png" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" title="SeedData" width="701"></a></p>


  <p>手順 1: DW 環境内のデータを分離するために使用する複数のスキーマ (ステージング、変換されたデータなど) を使用して、運用データを表します。</p>


  <p>手順 2: データが Azure Geo レプリカにコピーされる (ディザスター リカバリー コピー) を表します。</p>


  <p>手順 3: リリースデプロイ中に、geo レプリカを新しく調達した DIT サーバー インスタンスSQLコピーします。</p>


  <p>手順 4: 実稼働データの同等のコピーの可用性を表します。 さらに、DACPACK のデプロイでは、新しく追加されたスキーマが追加され、後でテスト自動化スイートが実行され、エンド 製品の品質がテストされます。</p>


  <h4>より高い環境へのリリースのデプロイ</h4>


  <p>ある環境から別の環境へのリリースの昇格は、承認ワークフローを通じて設定され、直接デプロイすることはできません。 このシナリオでは、事前に割り当てられた利害関係者からの承認なしに、直接 Production にデプロイすることはできません。</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/28c7d133-05e8-4385-b3d4-d27d6b8387bc.png"><img alt="WorkFlow-1" border="0" height="381" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/de4f7cba-49ed-40d1-a616-7472307e0f50.png" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" title="WorkFlow-1" width="365"></a></p>


  <p>承認ワークフローは、環境の昇格を示しています。 必要な承認者がワークフローを承認すると、リリースは自動的に次の環境に昇格されます。</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/9975b953-c56f-4618-adaa-64a963312438.png"><img alt="Approval-1" border="0" height="401" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/659220a3-2a91-406e-95f1-b00c2161c267.png" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" title="Approval-1" width="620"></a></p>


  <h2>Monitor</h2>


  <p>同DevOpsチームは、事前に開発された環境と prod 環境で障害を監視します。 DRI (直接責任を持つ個人) モデルを採用し、DRI&rsquo; 担当者はシステムの正常性とすべての通知を事前に監視して確認します。 問題がある場合は、アプリケーションの継続的な可用性を確保するために、優先順位に基づき修正されます。 ADF の監視と通知は、いくつかのカスタム監視ツールと共に使用します。 また、実稼働環境で毎日実行される自動レポートとして実装された複数のデータ品質チェックと、プロセスのバグとして修正できるデータの異常を報告したり、修正のためにソース システムに迅速にトレースバックしたりすることもできます。</p>


  <p>確&rsquo;かに、データ ウェアハウスの CI&rsquo;&rsquo; の設定は単純なわけではありませんが、すべてのペニーに価値があります。 スプリント中に新しいコードを追加するときにテスト ケースのエラーの課題に直面しました。ただし、チームはそれらのインスタンスから学習し、新しいコードが追加される際に既存のテスト ケースを確実に更新します。 製品の品質を常に向上するために、機能、ビルド、環境検証のテスト ケースを継続的に追加しています。 CI により、私たちは真にアジャイルで、エンド 製品に対して非常に自信を持つものになれたのです。 自動化されたテスト スイートを使用することで、一般的なバグ リークを実稼働環境に対して防止できます。 テスト環境の必要性を排除し、今後の四半期に直接実稼働環境にデプロイする必要が生じていました。 可能だと強く信&rsquo;じています。</p>
