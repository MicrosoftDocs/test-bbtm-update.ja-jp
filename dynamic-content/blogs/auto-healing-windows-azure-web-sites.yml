### YamlMime:Yaml
ms.openlocfilehash: 738494efd9872bd60f36fe0718305956206e4a5a
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139894588"
Slug: auto-healing-windows-azure-web-sites
Title: Azure websites Windows の自動復旧
Summary: Web サイトの再起動によって解決された問題について、夜の途中でウェイクアップされた回数を確認できます。 特定の条件を自動的に検出して...
Content: >-
  <p style="margin: 0in 0in 0pt;">Web サイトの再起動によって解決された問題について、夜の途中でウェイクアップされた回数を確認できます。 特定の条件を自動検出して自動的に回復するのは便利ではないでしょうか。</p>

  Azure websites (waws) Windows の最近の更新により、これらの質問に対処しようとしました。 "Always ON" 機能にはいくつかの新機能が追加されており、これらの機能強化により、web アプリケーションをホストしているワーカープロセスを自動的にリサイクルすることができます。 これを "自動復旧" 機能と呼びます。次にそのしくみを示します。


  Web サイトのルート web.config ファイルで <strong>トリガー </strong>を定義し、これらのトリガーがヒットしたときに実行される <strong>アクション</strong> を構成するだけです。 大まかに言えば、構成セクションの構造は次のようになります。


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/6064.Apurva-Joshi-Auto-Heal-image1.png-550x526.png"><img class="alignnone  wp-image-132211" alt="6064.Apurva Joshi - Auto Heal - image1.png-550x526" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/6064.Apurva-Joshi-Auto-Heal-image1.png-550x526.png" width="550" height="122" /></a>


  <strong>注:</strong> "Always ON" と同じように、この機能は Standard インスタンスでのみ使用できます。


  シナリオごとに使用可能なオプションを分割してみましょう。


  (サポートされているすべての要素と属性の詳細については、投稿の終わりに記載されています)。

  <h4>シナリオ1– "要求数に基づくリサイクル"</h4>

  X 個の要求を Y 時間に提供した後に、アプリケーションを自動的にリサイクルする必要があるシナリオを考えてみましょう。 非常に短い時間で大量の要求が殺到した後に、適切に拡張できないことがわかっています。 この状態を検出し、ワーカープロセスを自動的にリサイクルして、イベントをログに記録します。


  次のサンプル構成を使用して、アプリケーションのルート web.config ファイルを編集するだけです。 (既存の web.config ファイルがある場合は、既存 &lt; の system.webserver &gt; セクションの下にある [監視 &gt; ] セクションをコピー &lt; してください)


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/7848.Apurva-Joshi-Auto-Heal-image2.png-550x526.png"><img class="alignnone  wp-image-132201" alt="7848.Apurva Joshi - Auto Heal - image2.png-550x526" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/7848.Apurva-Joshi-Auto-Heal-image2.png-550x526.png" width="550" height="168" /></a>


  上記の構成では、10分で <strong>1000</strong> <strong>要求</strong> を処理したワーカープロセスがリサイクルされ <strong>ます。 </strong>また、eventlog.xml ファイル (web ルートディレクトリの [ログファイル] フォルダーにあります) にもイベントが記録されます。 イベントをログに記録すると、自動復旧 web サイトの発生を追跡し、トラブルシューティングや根本原因分析のための重要なフォレンジックを提供できます。 最初の要求が届いたら、timeInterval クロックを開始します。次に、発生回数のカウントを開始します。TimeInterval の有効期限が切れる前にカウントが最大値を超えると、アクションが実行されます。時間間隔が経過すると、タイマーとカウントの <em>両方</em> がリセットされます。 これにより、上記の構成では次のような結果になる可能性があります。


  00:00:00 –最初の要求が到着した


  00:09:59 –998要求が処理されます


  00:10:00 –タイマーの有効期限が切れ、0にリセットされます


  00:10:01 –999要求が処理されます


  このシナリオでは、1つ目または2番目の timeInterval ウィンドウで1000要求が発生していないため、何も実行されません。


  <strong>注: </strong>Web サイトのインスタンスが複数ある場合は、すべてのインスタンスではなく、このトリガーにヒットしたインスタンスのワーカープロセスのみが再起動されます。


  eventlog.xml ファイルに記録されたイベントの例。


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/3527.Apurva-Joshi-Auto-Heal-image3.png-550x526.png"><img class="alignnone  wp-image-132191" alt="3527.Apurva Joshi - Auto Heal - image3.png-550x526" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/3527.Apurva-Joshi-Auto-Heal-image3.png-550x526.png" width="550" height="274" /></a>


  &nbsp;

  <h4>シナリオ2– "遅い要求に基づくリサイクル"</h4>

  アプリケーションのパフォーマンスが低下し、いくつかのページの表示に時間がかかる場合を考えてみます。 この状況を検出し、ワーカープロセスを自動的にリサイクルしたいと考えています。


  次のサンプル構成を使用して、アプリケーションのルート web.config ファイルを編集するだけです。 (既存の web.config ファイルがある場合は、既存 &lt; の system.webserver &gt; セクションの下にある [監視 &gt; ] セクションをコピー &lt; してください)


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/7824.Apurva-Joshi-Auto-Heal-image4.png-550x526.png"><img class="alignnone  wp-image-132181" alt="7824.Apurva Joshi - Auto Heal - image4.png-550x526" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/7824.Apurva-Joshi-Auto-Heal-image4.png-550x526.png" width="550" height="148" /></a>


  上記の構成では、 <strong>20 件</strong>を超える要求が<strong>過去2分</strong>間に実行されるまでに<strong>45 秒</strong>以上かかっていることを検出すると、ワーカープロセスがリサイクルされます。SlowRequests のトリガーは各要求の実行の終了時に評価されることに注意してください。これにより、timeInterval の値を Timeinterval れた値に設定することも同様に重要になります。


  <strong>注: </strong>Web サイトのインスタンスが複数ある場合は、すべてのインスタンスではなく、このトリガーにヒットしたインスタンスのワーカープロセスのみが再起動されます。


  eventlog.xml ファイルに記録されたイベントの例。


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/3438.Apurva-Joshi-Auto-Heal-image5.png-550x526.png"><img class="alignnone  wp-image-132171" alt="3438.Apurva Joshi - Auto Heal - image5.png-550x526" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/3438.Apurva-Joshi-Auto-Heal-image5.png-550x526.png" width="550" height="290" /></a>

  <h4>シナリオ3– HTTP 状態コードに基づいてイベント (またはリサイクル) をログに記録する</h4>

  Web サイトで特定の HTTP 状態コード、サブステータスコード、または win32 状態コードのスローが開始されたときに通知されるようにするシナリオについて考えてみます。 リサイクルするか、単に eventlog.xml ファイル (web サイトのコンテンツルートの [ログファイル] フォルダー内にあります) でイベントをログに記録することを選択できます。


  次のサンプル構成を使用して、アプリケーションのルート web.config ファイルを編集するだけです。


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/8741.Apurva-Joshi-Auto-Heal-image6.png-550x526.png"><img class="alignnone  wp-image-132161" alt="8741.Apurva Joshi - Auto Heal - image6.png-550x526" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/8741.Apurva-Joshi-Auto-Heal-image6.png-550x526.png" width="550" height="135" /></a>


  上記の構成では、 <strong>10 個の要求</strong>によって<strong>HTTP ステータスコード 500</strong>が<strong>100 の</strong><strong>過去30秒間</strong>に発生したことを検出すると、eventlog.xml ファイルにイベントが記録されます。


  <strong>注: </strong>Web サイトのインスタンスが複数ある場合は、すべてのインスタンスではなく、このトリガーにヒットしたインスタンスのイベントのみがログに記録されます。 必要に応じて、イベントをログに記録するのではなく、リサイクルすることもできます。 既定では、リサイクルによってイベントがログに記録されます。


  eventlog.xml ファイルに記録されたイベントの例。


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/4034.Apurva-Joshi-Auto-Heal-image7.png-550x526.png"><img class="alignnone  wp-image-132151" alt="4034.Apurva Joshi - Auto Heal - image7.png-550x526" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/4034.Apurva-Joshi-Auto-Heal-image7.png-550x526.png" width="550" height="249" /></a>

  <h4>シナリオ4–メモリ制限に基づいてカスタムアクション (またはリサイクル/ログ) を取得する</h4>

  Web サイトのメモリリークをトラブルシューティングし、メモリダンプの生成、電子メール通知の送信、メモリダンプの生成、プロセスのリサイクルなどのカスタムアクションを実行するシナリオについて考えてみます。


  次のサンプル構成を使用して、アプリケーションのルート web.config ファイルを編集するだけです。 <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/4834.Apurva-Joshi-Auto-Heal-image8.png-550x526.png"><img class="alignnone  wp-image-132141" alt="4834.Apurva Joshi - Auto Heal - image8.png-550x526" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/4834.Apurva-Joshi-Auto-Heal-image8.png-550x526.png" width="550" height="131" /></a>


  上記の構成では、ワーカープロセスが<strong>800Mb のプライベートバイト  </strong>に達したことを検出したときに、 <strong>procdump.exe</strong>を実行して<strong>ミニメモリダンプ</strong>を生成するカスタムアクションを実行します。自動復旧は、http.sys (カーネルドライバー) から送信された特定の HTTP エラーコードではトリガーされませんが、要求はワーカープロセスパイプラインには作成されません。 このような状態コードの例としては、304、302、400 (多くの400番台ではありません)、503などがあります。


  <strong>注: </strong>Web サイトの複数のインスタンスがある場合は、すべてのインスタンスではなく、このトリガーにヒットしたインスタンスのメモリダンプのみが生成されます。 必要に応じて、電子メールを送信するカスタムアクションを実行するように選択することもできます。また、procdump.exe は、web サイトのルート (d:\home) では既定では利用できないことにも注意してください。これは、web サイトで xcopy をデプロイするものです。


  リサイクルのアクションの種類の eventlog.xml ファイルに記録されたイベントの例。


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/7026.Apurva-Joshi-Auto-Heal-image9.png-550x526.png"><img class="alignnone  wp-image-132131" alt="7026.Apurva Joshi - Auto Heal - image9.png-550x526" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/7026.Apurva-Joshi-Auto-Heal-image9.png-550x526.png" width="550" height="281" /></a>


  <strong>最後</strong>に、特定のページまたは URL でトリガーを構成する場合は、freb モジュールを使用して、次のブログに記載されている手順を構成することができます。


  <a href="(WAWS)-Collecting-dumps-of-the-worker-process-(w3wpexe)-automatically-whenever-a-request-takes-a-long-time">(WAWS)-w3wpexe-()--------要求--------------------------------------------</a>


  このアプローチでは、5-10% のパフォーマンスが低下するため、FREB を有効にする必要があります。


  <strong>注</strong>: 上記の方法は、[標準] モードでも有効になります。これは、共有モードとフリーモードでは、1時間後に自動的に freb を無効にするためです。


  &nbsp;


  <span style="text-decoration: underline;">サポートされている構成とその意味の一覧を次に示します。 </span>


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/6471.forgot-1.png-550x526.png"><img class="alignnone  wp-image-132121" alt="6471.forgot 1.png-550x526" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/6471.forgot-1.png-550x526.png" width="550" height="74" /></a>


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/5040.forgot-2.png-550x526.png"><img class="alignnone  wp-image-132111" alt="5040.forgot 2.png-550x526" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/5040.forgot-2.png-550x526.png" width="550" height="270" /></a>


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/6675.forgot-3.png-550x526.png"><img class="alignnone  wp-image-132101" alt="6675.forgot 3.png-550x526" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/6675.forgot-3.png-550x526.png" width="550" height="446" /></a>


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/7380.forgot-4.png-550x526.png"><img class="alignnone  wp-image-132091" alt="7380.forgot 4.png-550x526" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/7380.forgot-4.png-550x526.png" width="550" height="261" /></a>
