### YamlMime:Yaml
ms.openlocfilehash: cd986f9fcadec50582ac2710540c38abf8141c36
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139909888"
Slug: dynamic-manifests-and-rendered-sub-clips
Title: 動的マニフェストとレンダリングされたサブクリップ、ライブストリーミング用の重要なツール
Summary: 私は、メディアプラットフォームに2つの新しい機能セットが到着したことをお知らせします。これにより、ライブワークフローと線形ワークフローを構築するすべてのユーザーのツールボックスが大幅に拡張されます。
Content: >-
  私は、メディアプラットフォームに2つの新しい機能セットが到着したことをお知らせします。これにより、ライブワークフローと線形ワークフローを構築するすべてのユーザーのツールボックスが大幅に拡張されます。この記事では、これらの機能とその使用シナリオの概要について説明します。これらの機能セットを一般に使用できるようになったときに、フォローアップ投稿を引き続きご利用ください。Cenk (動的マニフェストの PM 所有者) および Anil (サブクリップの PM 所有者) は、次の週のコードサンプルを含む使用状況/実装の詳細になります。

  <h2>動的マニフェスト (別名 動的マニフェスト操作または DMM)</h2>

  おそらく、機能セットのギーク名のうちの1つを使用することをお勧めしますが、お読みください。 動的マニフェストを使用すると、アセットのストリーミングマニフェストにフィルターを定義して、いくつかのクールな処理を実行できます。 すべてのストリーミング機能と同様に、サポートされているすべてのプロトコル (HLS、MPEG ダッシュ、Smooth Streaming、HDS) でも同様に機能します。そのため、フィルターを定義するときは、これらの各プロトコルに動的にパッケージ化するときに同じように適用されます。


  動的マニフェストは、基本的には、アセットのストリーミングマニフェストに適用できるフィルターです。 これらは、資産レベルとグローバルレベルの両方で定義できます。これにより、柔軟性が向上します。 たとえば、資産レベルでは、トリミングを実行する場所が資産ごとに異なる可能性があるため、タイムラインのトリミングの種類のフィルター (以下で説明) を定義することができます。 ただし、さまざまな種類のデバイスに提供する品質レベルを定義するために (以下で説明する) レンディション機能を使用している場合は、すべてのストリーミングアセットに適用されるビジネスポリシーがある可能性があるため、これらのフィルターをグローバルレベルで1回記述する方が効率的です。


  1つのフィルターが適切であれば、2つの方が優れています。 実際には、複数のフィルターをグローバルに、資産レベルで定義できます。 たとえば、さまざまな対象ユーザーに対して、資産に異なるタイムラインのトリミングが必要になる場合があります。また、デバイスの種類が異なるため、それぞれに対してレンディションフィルターを設定する必要があります。 また、フィルターを組み合わせて、デバイスの種類に基づいてレンディションをフィルター処理し、タイムラインをフィルター処理してイベントの開始時に縮小することもできます。


  ストリーミングマニフェストをフィルター処理するには、2つの方法があります。詳細については、以下のセクションで説明します。

  <h2><span style="font-size: medium;"><span style="text-decoration: underline;">演奏フィルター処理</span></span></h2>

  私たちは、マルチプラットフォームの世界に住んでいます。これにより、 <a href="https://msdn.microsoft.com/en-us/library/azure/jj889436.aspx" target="_blank">動的パッケージング機能</a> により、資産をすべての主要プロトコルでストリーミングできるようになりました。 しかし、私たちは、4つの "携帯電話と 72" の LCD ディスプレイの画面サイズが大きく異なる、世界中に住んでいます。 これらのすべてのデバイスを解決と帯域幅の観点からカバーするには、資産に対して10個以上のレンディションが必要であり、これがビデオ専用です。 オーディオ側には、モバイルデバイス用の AAC、OTT デバイスの Dolby Digital + など、さまざまなレンディションが含まれている場合があります。


  これらすべてのビデオとオーディオのレンディションを1つの資産にする場合、動的マニフェストを使用しない場合の問題は、デバイスが適切ではないレンディションを再生できないようにする方法です。 たとえば、大きな画面の OTT デバイスでは、モバイルデバイス用に作成した240p ビデオレンディションを含むマニフェストを使用したくない場合があります。これは、これらのビューアーでは、かなりの色のビデオを再生する必要があるためです。


  DMM を使用せずにこの問題を解決するには、2つの方法があります。 これをサポートするデバイスでは、クライアント側ロジックを記述してマニフェストをフィルター処理するか、再生するレンディションを指定します。 この方法の問題は、必要なすべてのプラットフォームのクライアント側ロジックを構築、テスト、および管理することが、非常に時間がかかり、問題になる可能性があることです。 この問題を解決するためのもう1つのオプションとして最も目立つのは、デバイスごとに異なる資産を作成することです。 このアプローチで明らかに問題となるのは、デバイスの種類ごとにアセットを出力するために、より複雑なワークフローを構築、テスト、および保守する必要があり、追加の開発、資産の準備処理、ストレージによってコストが劇的に増加することです。


  ただし、動的マニフェストでは、すべてのデバイスに必要なすべてのレンディションを含む1つの資産を作成する資産準備ワークフローが1つだけ必要です。 その後、その資産で、サーバー上の要求時に適用される、含まれるレンディションにフィルターを適用できます。 最終的には、各デバイスは、適切なレンディションのみを含むマニフェストを受け取ることになります。 したがって、クライアント側のロジックは必要ありません。 ビットレート、解像度、コーデックに基づいてフィルター規則を定義できます。既に説明したように、資産に適用できる複数のフィルターを定義して、使用するデバイスの種類ごとに1つのフィルターを設定することもできます。

  まとめると、整理フィルターは、適切なデバイスに適切なレンディションを提供できる非常に強力なツールであり、作成する必要があるワークフローやクライアントロジックの複雑さや、資産を準備して格納するためのコストも削減できます。


  <a href="https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2015/04/13/RenditionFilter2.png"><img style="padding-top: 0px; padding-left: 0px; padding-right: 0px; border-width: 0px;" title="RenditionFilter2" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/RenditionFilter2_thumb.png" alt="RenditionFilter2" width="1024" height="569" border="0" /></a>


  上の例では、イメージをクリックすると、より大きなバージョンが表示されます。 Azure Media Encoder の "H264 アダプティブビットレート MP4 セット 1080p" プリセットを使用して資産を準備しました。これは、サポートされているストリーミングプロトコルに動的にパッケージ化できる 180 p から1080p の7個の ISO Mp4 ビデオレンディションになります。図の上部では、フィルターが指定されていない資産の HLS マニフェストが要求されているため、応答には7つのすべてのレンディションがありました。左下に HLS マニフェストの入力を求められましたが、今度は、マニフェストをフィルター処理して、1 Mbps 未満のすべてのビットレートを削除するように指定しました。これにより、下部の2つの品質レベルが応答で除去されます。右下に HLS をもう一度使用しています。ここでは、"mobile" フィルターを指定しています。このフィルターでは、2つの1080p レンディションがオフになっていることを示す720p を超える分解能を指定しています。

  <h2><span style="font-size: medium;"><span style="text-decoration: underline;">タイムラインのトリミング (事前およびポストロールスレートの削除用)</span></span></h2>

  一般的なライブイベントワークフローでは、イベントが開始されるまで数分後にライブストリームを開始し、すべてが正常に動作していることを確認し、対象ユーザーが早期に接続できるようにして、イベントの開始を見逃しないようにします。 この期間中は、"すぐに開始してください" という順序で、イベントがすぐに開始されるというスレートが表示されることがあります。 これを、事前ロールスレートと呼びます。 次に、イベントが終了したときに、"監視に感謝します。イベントは終了しました。" というスレートでストリームを実行し続けることができます。 これはロールアウトスレートと呼ばれます。


  これは、ストリームがライブの場合に適していますが、プログラムを停止したときに、資産がすぐにオンデマンドで表示できるようになったときには、事前ロールとポストロールも用意されています。 これは、オンデマンドストリームを表示し、アーカイブの先頭から再生を開始するすべてのユーザーが、イベントの開始を検索するタイムラインを探すために残されることを意味します。 一部のお客様は、この問題に対処することを選択します。これは、イベントの開始までビデオプレーヤーをシークするためのクライアント側ロジックを記述することですが、この方法にはいくつかの問題があります。 まず、必要なすべてのプラットフォームでクライアント側ロジックを作成、テスト、および維持するという課題に直面しています。 2つ目の方法として、事前ロールはクライアントに配信されるマニフェストにまだ存在しています。そのため、最初にシークすることを決定した人は、それ自体がロール的なスレートになることがあり、最初の検索を再試行する必要があります。 また、ビデオプレーヤーのタイムラインの期間は、イベントの実際の継続時間を正しく反映していません。


  動的マニフェストでは、イベントが開始される前とイベント終了後にマニフェスト内のすべてのフラグメントが必要であることを、フィルターを使用して指定できます。これは、サーバー上で、要求時に動的に実行されます。 最後に理解しなければならないのは、マニフェスト全体を含む資産全体です。これにより、異なるトリムポイントを持つさまざまなフィルターを作成できます。また、フィルターを使用せずにストリームを要求することもできます。 ここでも、すべてのビデオプレーヤーが指定されたマニフェストを再生する必要があるため、クライアント側のロジックは必要ありません。


  さらに優れた動的マニフェストのトリムは、イベントがまだライブのときに適用できます。 つまり、スレートを削除してイベントが開始されるとすぐに、ストリームにフィルターを定義して適用し、事前ロールスレートからトリムすることができます。 このようにすると、遅れて到着したすべてのビューアーは、イベントの開始を探していなくても、最初からイベントを監視することになります。

  <blockquote>注: トリミングはマニフェストからフラグメント全体を削除します。つまり、トリム配置の粒度は、使用しているフラグメントのサイズによって制限されます ( GOP の長さ)。 通常、ライブプラットフォームでは、ほとんどのユーザーが2つの2番目のフラグメントを取り込みに使用しています。これは、切り取りとトリムの配置では2秒の粒度があることを意味します。</blockquote>

  <a href="https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2015/04/13/TimelineTrimEvent.png"><img style="padding-top: 0px; padding-left: 0px; padding-right: 0px; border-width: 0px;" title="TimelineTrimEvent" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/TimelineTrimEvent_thumb.png" alt="TimelineTrimEvent" width="640" height="167" border="0" /></a>


  上の図では、トリムフィルターを使用して、野球ゲームアーカイブから事前ロールとポストロールのスレートを削除する例を示しています。上部のタイムラインは、マニフェスト要求でフィルターが指定されていない完全なイベントアーカイブを示しています。応答で返される内容は、ロールの前のスレートとポストロールのスレートを含む資産内のすべてを含むマニフェストです。イベントが終了した後、"eventonly" という名前のアセットに対してフィルターを作成しました。このフィルターでは、タイムコード値が X 未満のすべてのフラグメント (ゲームの開始時刻) と Y よりも大きいものを、マニフェストから除外するように指定しています。図の2行目では、マニフェスト要求に "filter = eventonly" を追加してフィルターを適用しました。応答では、イベントの開始から終了までのフラグメントのみを含むマニフェストが返されます。

  <h2><span style="font-size: medium;"><span style="text-decoration: underline;">タイムライントリミング (サブクリップの作成用)</span></span></h2>

  動的マニフェストのタイムライントリミング機能を使用するもう1つの方法として、マニフェストをすべて下位方向に切り取って、サブクリップの長さにすることができます。 カバーしているイベントが野球ゲームであり、4番目の回には、オンデマンド表示のための短い形式の強調表示 (つまり、サブクリップ) を提供するホームランがあるとします。 この目的のために動的マニフェストを使用することもできます。前述のように、切り取りまたはトリムポイントをもう一度指定しているのと同じように、タイムラインを大幅に縮小しているのは1-2 分のクリップだけです。 フィルター定義は処理 (トランスコード) を必要としないため、ほぼ瞬時に使用できます。つまり、カットポイントを指定できるように、ホーム実行のサブクリップを対象ユーザーに提供できます。


  このように動的マニフェストを使用すると、2つの注意点があります。 前述のように、トリム/カットポイントは、フラグメント/GOP の境界でのみ使用できます。 #1 新しい資産を作成していない #2、完全なイベントアーカイブに対してのみフィルターが適用されます。 つまり、サブクリップのライフサイクルとセキュリティ属性は完全なイベントアーカイブと同じになります。 つまり、完全なイベントアーカイブを削除すると、この方法で作成したすべてのサブクリップが使用されます。同様に、完全なイベントアーカイブが動的暗号化用に構成されていれば、すべてのサブクリップも同様に暗号化されます。


  <a href="https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2015/04/13/TimelineTrimSubclip2.png"><img style="padding-top: 0px; padding-left: 0px; padding-right: 0px; border-width: 0px;" title="TimelineTrimSubclip2" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/TimelineTrimSubclip2_thumb.png" alt="TimelineTrimSubclip2" width="640" height="176" border="0" /></a>


  上の図では、野球ゲームの完全なイベントアーカイブを含む資産をもう一度使用しています。最初の行には、アーカイブ内のすべてのフラグメントを含むマニフェストが必要であることが指定されています。ただし、上記のようにイベントの開始と終了までトリムするのではなく、2番目の行では、この時間によってフィルターを作成して、ゲームのホームの実行を優先する短い形式のクリップにトリミングすることができます。

  <h2>レンダリングされた Sub-Clips</h2>

  過去1年間、ライブストリーミングでは、これらのライブストリームからサブクリップを作成できるようにしたいと考えています。 つまり、新しいオンデマンド資産を作成するために、ライブストリームの一部を切り取ることができるようにしたいと考えています。 典型的なの例はライブスポーツの範囲にあります。これは、前に説明したように、サイト、アプリ、またはソーシャルメディアで使用できるようにするために、前に説明したホームの実行と同様に強調表示されます。


  前述の「動的マニフェスト」セクションで説明したように、このような場合には、この目的のためにタイムラインのトリミングを使用できます。 しかし、ほとんどの人は、サブクリップをレンダリングしている別の新機能を使用することにします。 ライブストリームでレンダリングされたサブクリップの完全なイベントアーカイブを除去する動的マニフェストと比較するには、代わりに必要なストリームの部分を抽出し、新しいアセットを作成します。そのため、名前の "レンダリングされる" 部分が生成されます。 この方法の利点は、サブクリップが切り取ったストリームから独立したライフサイクルを持つことができ、独自のセキュリティプロパティを持つことができることです。 たとえば、完全なイベントは DRM にすることができますが、サブクリップはクリアでもかまいません。


  通常、サブクリッピングがあるゲームの名前は速度になります。この機能を使用すると、サイトのファンでそのホームの実行を強調することができます。また、この機能を構築する際には、パフォーマンスが確実に考慮されます。 最初に注意すべき点は、イベントがまだライブであるときに、レンダリングされたサブクリップを記述し、レンダリングできることです。 2つ目は、要件に応じて2つの表示オプションを提供することです。 フラグメント/GOP の境界を切り取っても問題ない場合は、ライブアセットから新しい資産にフラグメントをコピーするだけなので、これは非常に高速なトランスコードなしオプションを提供します。 ただし、フレームの精度が必要な場合は、フレームの精度を実現するためのトランスコードを実行するもう1つのオプションが用意されています。


  <a href="https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2015/04/13/RenderedSubclip3.png"><img style="padding-top: 0px; padding-left: 0px; padding-right: 0px; border-width: 0px;" title="RenderedSubclip3" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/RenderedSubclip3_thumb.png" alt="RenderedSubclip3" width="640" height="173" border="0" /></a>


  上の図では、野球ゲームの同じサンプルイベントに戻りました。最初の行には、イベントの完全なアーカイブが再び表示されています。ここでは、動的マニフェストフィルターを使用してストリーミングマニフェストを短縮し、ホームの実行の強調表示を作成するのではなく、処理したサブクリッピングジョブを作成しました。最後の結果は、ホーム ランのフレーム正確なクリップを含む新しい資産です。そのため、フィルターを使用して資産のストリーミング マニフェストを要求すると、ホームランの 30 秒が返されます。

  <h2>まとめ</h2>

  動的マニフェストとレンダリングされたサブクリッピングは、ツールボックスに追加する強力な新しいツールです。 数週間以内の詳細な実装の投稿については、こちらを参照してください。 以下のコメント セクションで質問してください。できる限り迅速に応答します。
