### YamlMime:Yaml
ms.openlocfilehash: 3b2f72765bde0cc1f512518e72997a1cf3740a7e
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139891889"
Slug: working-with-collations-in-sql-azure
Title: の照合順序のSQL Azure
Summary: '[この記事は、チームによってSQL Azureされました。]照合順序は、ギリシャ語やポーランド語などの言語、または Latin1 などのアルファベットの文字の適切な使用を制御する規則をエンコードします。'
Content: "<p>[この記事は、チームによってSQL Azureされました。]</p><p>照合順序は、ギリシャ語やポーランド語などの言語、または Latin1_General (西ヨーロッパ言語で使用されるラテンアルファベット) などのアルファベットの文字の適切な使用を制御する規則をエンコードします。 データベース内の文字データの既定のSQL Azure<b>は、SQL_Latin1_General_CP1_CI_AS</b>。 この照合順序は、データベース オブジェクトを定義するSQL Azure並べ替えと比較を行うインフラストラクチャ全体で使用されます。 サーバーレベルとデータベース レベルの照合順序は、次のSQL Azure。 ただし、列レベルと式レベルで、選択した照合順序を使用できます。 この記事では、その方法について示します。</p>  <p>サーバーとデータベースの照合順序は、SQL Azureで構成することはできませんが、次のように、これらのプロパティの両方に対してクエリを実行することもできます。 </p>  <pre class=\"csharpcode\"><span class=\"kwrd\">SELECT</span> SERVERPROPERTY(<span class=\"str\">'Collation'</span>)  <span class=\"kwrd\">SELECT</span> DATABASEPROPERTYEX(<span class=\"str\">'TestDB'</span>, <span class=\"str\">'Collation'</span>)</pre>      <p>現時点では、両方のクエリが既定の照合順序 (SQL_Latin1_General_CP1_CI_AS) <b>を返します</b>。</p>    <p>SQL Azure で構築するソリューションで文字データに対して別の照合順序が必要な場合は、列レベルで照合順序を設定するか、式レベルの照合順序を使用して特定の照合順序に明示的にキャストする必要があります。 読み続け、方法を学習してください。</p>    <h2>列の照合順序</h2>    <p>スクリプトのSQL Server Management Studioウィザードを使用する場合 (このブログ記事のスクリプト生成ウィザードの使用の詳細)、列の照合順序は既定で含まれます。 これを確認するには、\"照合順序を含<a href=\"https://msdn.microsoft.com/en-us/library/bb326600.aspx\">める\" オプション</a>が \"True\" (既定値) に設定されています。</p>    <p>このサンプルでは、特定の照合順序を持つ列を作成する方法を示します。</p>    <pre class=\"csharpcode\"><span class=\"kwrd\">CREATE</span> <span class=\"kwrd\">TABLE</span> t  (      id    <span class=\"kwrd\">int</span> <span class=\"kwrd\">IDENTITY</span>(1,1) <span class=\"kwrd\">NOT</span> <span class=\"kwrd\">NULL</span> <span class=\"kwrd\">PRIMARY</span> <span class=\"kwrd\">KEY</span> <span class=\"kwrd\">CLUSTERED</span>,      c1    nvarchar(20) <span class=\"kwrd\">COLLATE</span> SQL_Latin1_General_CP1_CI_AS,  c2    nvarchar(20) <span class=\"kwrd\">COLLATE</span> Japanese_CI_AS  ) </pre>      <p>上記の例の列照合順序プロパティを取得するには: </p>    <pre class=\"csharpcode\"><span class=\"kwrd\">SELECT</span> name, collation_name <span class=\"kwrd\">FROM</span> sys.columns      <span class=\"kwrd\">WHERE</span>    object_id = OBJECT_ID(<span class=\"str\">'t'</span>, <span class=\"str\">'U'</span>)          <span class=\"kwrd\">AND</span> name &lt;&gt; <span class=\"str\">'id'</span></pre>      <p>列レベルまたは式レベルの照合順序を使用する方法の詳細については、オンライン <a href=\"https://msdn.microsoft.com/en-us/library/ms177439.aspx\"></a> ブックの<a href=\"https://msdn.microsoft.com/en-us/library/ms184391.aspx\">「COLLATE</a>」と「照合順序の設定と変更SQL Server参照してください。</p>    <h2>一時テーブル</h2>    <p>メタデータ オブジェクト (ログイン、データベース、テーブル、ビュー、列名など) と共に、既定の照合順序は、変数、GOTO ラベル、一時テーブルの識別子にも適用されます。 一時テーブルとテーブル値パラメーター (および関連するユーザー定義テーブル型) は、注意する必要がある興味深いケースを表します。 SQL Azure のデータベースの既定の照合順序は、一時テーブルまたはユーザー定義テーブル型の文字データ列に使用される照合順序と同じですが、データベースで列レベルの照合順序を使用すると、照合順序と照合順序の競合が一致しない可能性があります。 また、列database_default照合順序を設定するオプションは、常に列レベルの照合順序に <b>SQL_Latin1_General_CP1_CI_AS</b>。</p>    <p>既定以外の照合順序を使用する列を含むテーブルと組み合わせて使用する一時テーブル (またはテーブル型) を作成する必要がある場合は、照合順序が一致する一時テーブルに列を作成する必要があります。 次に例を示します。</p>    <pre class=\"csharpcode\"><span class=\"kwrd\">CREATE</span> <span class=\"kwrd\">TABLE</span> #TestTempTable  (      id <span class=\"kwrd\">int</span> <span class=\"kwrd\">IDENTITY</span>(1,1) <span class=\"kwrd\">PRIMARY</span> <span class=\"kwrd\">KEY</span>,       c1 nvarchar(20),      c2 nvarchar(20) <span class=\"kwrd\">COLLATE</span> database_default,      c3 nvarchar(20) <span class=\"kwrd\">COLLATE</span> Japanese_CI_AS,  )</pre>      <p>列 c1 と c2 は、上記の例と同じ照合順序を持つ点に注意してください。</p>    <p>次のクエリでは、照合順序の競合エラーが返されます。</p>    <pre class=\"csharpcode\"><span class=\"kwrd\">SELECT</span> * <span class=\"kwrd\">FROM</span> t <span class=\"kwrd\">INNER</span> <span class=\"kwrd\">JOIN</span> #TestTempTable <span class=\"kwrd\">on</span> t.c2 = #TestTempTable.c1  <span class=\"kwrd\">SELECT</span> * <span class=\"kwrd\">FROM</span> t <span class=\"kwrd\">INNER</span> <span class=\"kwrd\">JOIN</span> #TestTempTable <span class=\"kwrd\">on</span> t.c2 = #TestTempTable.c2</pre>      <p>これら 2 つは機能しますが、</p>    <pre class=\"csharpcode\"><span class=\"kwrd\">SELECT</span> * <span class=\"kwrd\">FROM</span> t <span class=\"kwrd\">INNER</span> <span class=\"kwrd\">JOIN</span> #TestTempTable <span class=\"kwrd\">on</span> t.c2 = #TestTempTable.c3  <span class=\"kwrd\">SELECT</span> * <span class=\"kwrd\">FROM</span> t <span class=\"kwrd\">INNER</span> <span class=\"kwrd\">JOIN</span> #TestTempTable <span class=\"kwrd\">on</span> t.c2 = #TestTempTable.c2 <span class=\"kwrd\">COLLATE</span> Japanese_CI_AS</pre>      <p>Transact-SQL での上記の修正は、ステートメントの実行時に実行され、テーブルに格納されているデータには影響しない、式の宣言型照合順序の例です。</p>    <h2>静的文字列</h2>    <p>また、Unicode 文字列の前に大文字の N を付け、SQL-92 標準では National Language を表し、大文字を使用する必要があります。 Unicode 文字列の前に N プレフィックスがない場合、現在のデータベース照合順序に対応するコード ページが使用され、N プレフィックスが原因でデータが破損する可能性がある場合は、文字が変換されます。</p>    <p>次の例では、ひらがな文字 E の最初のエントリが正しく変換されるのに対し、2 番目のエントリではデータが破損します。 この例では、列の照合順序が変換に使用されない方法も示しています。</p>    <pre class=\"csharpcode\">INSERT <span class=\"kwrd\">INTO</span> t      <span class=\"kwrd\">VALUES</span>(N<span class=\"str\">'え'</span>, N<span class=\"str\">'え'</span>), (<span class=\"str\">'え'</span>, <span class=\"str\">'え'</span>)  <span class=\"kwrd\">SELECT</span> * <span class=\"kwrd\">FROM</span> t</pre>      <p>    <h2>まとめ</h2>    <p>質問、懸念事項、コメントはありますか? 以下に投稿すると、対処を試みることができます。</p>"
