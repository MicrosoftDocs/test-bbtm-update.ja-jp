### YamlMime:Yaml
ms.openlocfilehash: f1e5f4b859a115ddea9c7dc2c5292bf895d9818a
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139904845"
Slug: data-driven-styling-and-more-in-the-latest-azure-maps-web-sdk-update
Title: 最新の Azure Maps Web SDK 更新プログラムにおけるデータドリブンスタイル
Summary: 楽しん Web SDK Azure Maps の最新の更新プログラムを発表することをお勧めします。 チームは、夏を通じて、多くの強力な機能を追加し、Web マップ SDK の全体的なパフォーマンスを向上させました。
Content: "<p>楽しん Web SDK Azure Maps の最新の更新プログラムを発表することをお勧めします。 チームは、夏を通じて、多くの強力な機能を追加し、Web マップ SDK の全体的なパフォーマンスを向上させました。 この更新プログラムに追加される主な機能強化の一部を次に示します。</p>\n\n<ul>\n <li>開発者に特化した API の機能強化</li>\n <li>新しいデータソースとレイヤーモデル</li>\n <li>データソースへの複数のレイヤーの Connect</li>\n <li>新しい管理しやすい図形クラス</li>\n <li>レイヤーのデータドリブンスタイル</li>\n <li>空間数値演算ライブラリ</li>\n <li>Geospatially 正確な円のサポート</li>\n</ul>\n\n<h2>開発者に特化した API の機能強化</h2>\n\n<p>API インターフェイスをさらに直感的に拡張し、パフォーマンスを向上させました。 以前は、SDK の機能の大部分は、Map クラスの関数として公開されていました。 関連する関数がグループ化されていなければ、多くの場合、開発者は、必要な関数を見つけるために、SDK 内のほぼすべての関数とプロパティをスキャンする必要がありました。 このリリースでは、多くの関連機能がグループ化され、マップクラスのマネージャープロパティを通じて公開されています。 最後のバージョンでは、マップクラスに30を超える関数があり、そのうち7つはデータレイヤーに関連付けられていました。 この更新プログラムでは、これらの機能がマップの [ &ldquo; レイヤー &rdquo; ] プロパティを通じて公開されるようになりました。さらに多くの機能が追加され、レイヤーの操作が簡単になりました。 また、コントロール、イベント、マップイメージスプライト、HTML マーカー、およびデータソースのマップに、マネージャープロパティも追加されています。</p>\n\n<p>同様に、既定のマップ SDK 設定の多くを SDK のルート <strong>アトラス</strong> 名前空間に直接設定するオプションも追加しました。 これにより、ページ上で作成されたすべてのマップインスタンスと作成されたサービスクライアントは、これらの設定を既定値として使用します。 以前は、アプリケーションに追加されたすべてのマップインスタンスとサービスクライアントは、その機能の初期化時に Azure Maps キーを渡す必要がありました。 これは、アプリケーションでこの同じ設定を何度も設定する必要があることを意味します。これは煩雑になる可能性があります。 ルートの <strong>アトラス</strong> 名前空間でキーを設定することにより、アプリケーションで1回だけ指定する必要があります。これにより、必要に応じて、後で簡単に更新することができます。</p>\n\n<pre>\natlas.setSubscriptionKey(&#39;Your Azure Maps Key&#39;);</pre>\n\n<p>言語やユーザー地域の情報など、他のいくつかの設定は、ルート <strong>アトラス</strong> の名前空間で既定値として設定することもできます。 これらは既定値であることに注意してください。マップインスタンスまたはサービスクライアントを初期化するときに同等のオプション &rsquo; を指定しないと、これらの値が使用されます。 たとえば、マップを初期化するときに別の言語を渡すと、代わりにその言語が使用されます。 これは、複数のマップを異なる言語のページに表示する必要がある場合に便利です。</p>\n\n<p>これらの開発者向けの機能強化により、Azure Maps でアプリケーションを開発しやすくなり、パフォーマンスが向上し、アプリケーションの作成に必要なコードの量も削減されます。</p>\n\n<h2>新しいデータソースとレイヤーモデル</h2>\n\n<p>以前は、マップコントロールは、GeoJSON 形式のベクター空間データをマップに追加する機能しか提供していませんでした。 このデータは、シーンの背後で独自のデータソースを作成および管理するレイヤーに追加されました。 レイヤー内のデータを変更するには、非効率的な既存のレイヤーを上書きする必要があります。また、以下のサンプルコードでわかるように、にくいのコードが必要です。</p>\n\n<pre>\nvar myPins = [/* Array filled with pin data */];\n\n//Add pins to map.\nmap.addPins(pins, {\n     name: &#39;MyPinLayer&#39;\n});\n\n//Create a new pin to add to layer.\nvar pin = new atlas.data.Feature(new atlas.data.Point(lon, lat));\n\n//Add the pin to array of pins.\nmyPins.push(pin);\n\n//Update the layer by overwriting all data in the layer. This is unintuitive and creates a performance hit.\nmap.addPins(pins, {\n     name: &#39;MyPinLayer&#39;,  \n     overwrite: true\n});</pre>\n\n<p>このリリースでは、レイヤーからデータソースが分離されています。これには、データソースの1つのインスタンスのみを保持しながら、複数のレイヤーを使用して1つのデータソースを表示する機能、メモリ使用量の削減、パフォーマンスの向上、さらに理解しやすい API の作成など、いくつかの利点があります。</p>\n\n<pre>\n//Create a data source and add it to the map.\nvar dataSource = new atlas.source.DataSource();\nmap.sources.add(dataSource);\n\n//Create a layer that defines how to render the shapes in the data source and add it to the map.\nvar myPinLayer = new atlas.layer.SymbolLayer(dataSource);\nmap.layers.add(myPinLayer);\n\n//Add pins to the data source.\ndataSource.add([/* Array filled with pin data */]);\n\n//Create a new pin to add to map.\nvar pin = new atlas.data.Feature(atlas.data.Point([lon, lat]));\n\n//Add the pin to the data source, the map automatically updates in the most efficient manner possible.\ndataSource.add(pin);</pre>\n\n<p>GeoJSON の書式設定されたデータの DataSource クラスに加えて、新しい VectorTileSource クラスを使用した vector タイルサービスのサポートも追加しました。 これらのデータソースは、マップ上でのデータの表示方法を定義する次のレイヤーにアタッチできます。</p>\n\n<ul>\n <li><strong>バブルレイヤー &ndash; </strong>ピクセル半径を使用して、スケールされた円としてポイントデータをレンダリングします。</li>\n <li><strong>線レイヤー &ndash; </strong>線と多角形の輪郭を描画します。</li>\n <li><strong>多角形レイヤー &ndash; </strong>多角形の塗りつぶされた領域を描画します。</li>\n <li><strong>シンボルレイヤー &ndash; </strong>ポイントデータをアイコンおよびテキストとして表示します。</li>\n</ul>\n\n<p>また、TileLayer クラスもあります。これにより、画像をマップの上に重ねて並べて表示することができます。 このレイヤーをデータソースにアタッチするのではなく、タイルサービス情報がレイヤーのオプションとして指定されます。</p>\n\n<p>SDK でこの新しいデータソースとレイヤーモデルを作成しているときに、マップ上のデータを視覚化するための機能的な機能とレンダリングオプションが2倍以上になっています。</p>\n\n<h2>データソースへの複数のレイヤーの Connect</h2>\n\n<p>既に説明したように、複数のレイヤーを同じデータソースにアタッチできるようになりました。 これは奇妙に思えるかもしれませんが、さまざまなシナリオでこの機能が役に立ちます。 たとえば、多角形の描画エクスペリエンスを作成するシナリオを考えてください。 ユーザーが多角形を描画できるようにするには、ユーザーがマップにポイントを追加するときに、塗りつぶしの多角形領域を描画する必要があります。 多角形の輪郭を描画するスタイル指定された線を追加すると、描画されている多角形のエッジが見やすくなります。 最後に、多角形内の各位置に何らかの種類のハンドル (ピンやマーカーなど) を追加すると、個別の各位置を編集しやすくなります。 このシナリオを示す画像を次に示します。</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/b0057eae-d9db-45ec-96bb-6845dd9de7f2.png\"><img alt=\"Connect multiple layers to a data source\" border=\"0\" height=\"569\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/ad8b2d0c-b4e0-4c13-b9f4-3d7804fc7377.png\" style=\"border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;\" title=\"データソースへの複数のレイヤーの Connect\" width=\"1428\"></a></p>\n\n<p>ほとんどのマッピングプラットフォームでこれを実現するには、polygon オブジェクト、直線オブジェクト、および多角形の各位置のピン留めを作成する必要があります。 多角形が変更されると、線とピンを手動で更新する必要があります。 これを行うために必要な作業は、非常に短時間で実行されます。</p>\n\n<p>Azure Maps で必要なものは、次のコードで示すように、データ ソース内の 1 つの多角形だけです。</p>\n\n<pre>\n//Create a data source and add it to the map.\nvar dataSource = new atlas.source.DataSource();\nmap.sources.add(dataSource);\n\n//Create a polygon and add it to the data source.\ndataSource.add(new atlas.data.Polygon([[[/* Coordinates for polygon */]]]));\n\n//Create a polygon layer to render the filled in area of the polygon.\nvar polygonLayer = new atlas.layer.PolygonLayer(dataSource, &#39;myPolygonLayer&#39;, {\n     fillColor: &#39;rgba(255,165,0,0.2)&#39;\n});\n\n//Create a line layer for greater control of rendering the outline of the polygon.\nvar lineLayer = new atlas.layer.LineLayer(dataSource, &#39;myLineLayer&#39;, {\n     color: &#39;orange&#39;,\n     width: 2\n});\n\n//Create a bubble layer to render the vertices of the polygon as scaled circles.\nvar bubbleLayer = new atlas.layer.BubbleLayer(dataSource, &#39;myBubbleLayer&#39;, {\n     color: &#39;orange&#39;,\n     radius: 5,\n     outlineColor: &#39;white&#39;,\n     outlineWidth: 2\n});\n\n//Add all layers to the map.\nmap.layers.add([polygonLayer, lineLayer, bubbleLayer]);</pre>\n\n<p><a href=\"https://aka.ms/am_polygondrawingsample\" target=\"_blank\">ライブの例</a>を参照してください。</p>\n\n<h2>新しい管理しやすい図形クラス</h2>\n\n<p>Azure Maps Web SDK のベクターベースのデータはすべて、定義済みのスキーマに従った JSON オブジェクトである GeoJSON オブジェクトで構成されます。 GeoJSON データを使用する場合の制限事項の1つは、データを変更すると、マップ &rsquo; が変更を認識せず、マップ内のオブジェクトを削除して置換するまでの間に、その変更が認識されないことです。 より簡単で直感的なものにするために、新しい Shape クラスを追加しました。これにより、任意の GeoJSON 機能またはジオメトリをラップすることができます。 このクラスには、GeoJSON データを簡単に更新できるようにするいくつかの関数が用意されており、その変更を、図形が追加されたデータソースに瞬時に反映させることができます。 これは、DataSource クラスに追加されたすべての GeoJSON オブジェクトを自動的にラップするために役立つことがわかりました。</p>\n\n<p>たとえば、マップ上のデータポイントの位置を更新するシナリオを考えてください。 以前は、レイヤー内のデータを個別に管理し、次のコードに示すようにレイヤーを上書きする必要がありました。</p>\n\n<pre>\n//Create a pin from a point feature.\nvar pin = new atlas.data.Feature(new atlas.data.Point([-110, 45]));\n\n//Add a pin to the map.\nmap.addPins([pin], {\n     name: &#39;MyPinLayer&#39;\n});\n\n//Update pins coordinates... Map does not update.\npin.geometry.coordinates = [-120, 30];\n\n//Overwrite all pins in the layer to update the map.\nmap.addPins([pin], {\n     name: &#39;MyPinLayer&#39;,\n     overwrite: true\n});</pre>\n\n<p>これはにくいであり、より多くの作業を行う必要があります。 図形クラスを使用してデータポイントをラップすることで、次のコードに示すように、マップ上のデータポイントの位置を更新するためのコードを1行だけ取得します。</p>\n\n<pre>\n//Create a data source and add it to the map.\nvar dataSource = new atlas.source.DataSource();\nmap.sources.add(dataSource);\n\n//Create a layer that defines how to render the shapes in the data source and add it to the map.\nvar myPinLayer = new atlas.layer.SymbolLayer(dataSource);\nmap.layers.add(myPinLayer);\n\n//Create a pin and wrap with the shape class and add to data source.\nvar pin = new atlas.Shape(new atlas.data.Point([-110, 45]));\ndataSource.add(pin);\n\n//Update the coordinates of the pin, map automatically updates.\npin.setCoordinates([-120, 30]);</pre>\n\n<p><strong>ヒント:</strong> 各オブジェクトを個別にラップするのではなく、データソースからラップされたデータの形式を簡単に取得できます。</p>\n\n<h2>レイヤーのデータ駆動型スタイル</h2>\n\n<p>この更新の重要な新機能は、プロパティ関数を使用した新しいデータドリブンスタイル機能です。 これにより、接続されたデータソース内の個々の図形に定義されているプロパティを考慮して、個々のスタイル設定オプションにビジネスロジックを追加できます。 また、レイヤーがレンダリングされるときに、ズームレベルを考慮することもできます。 データドリブンスタイルを使用すると、通常は、if ステートメントや監視マップイベントを使用して、この種のビジネスロジックを記述し、定義する必要があるコードの量を大幅に削減できます。</p>\n\n<p>例として、地震データを考慮してください。 各データポイントには、マグニチュードプロパティがあります。 マップ上の各データポイントの関連する大きさを表示するには、BubbleLayer を使用して、データポイントの大きさが大きい場合に円の半径が大きい場合に、スケールされた円を描画することができます。 次のコードは、BubbleLayer の radius オプションにデータドリブンスタイルを適用する方法を示しています。これにより、線形スケール上の各データポイントのマグニチュードプロパティに基づいて、2ピクセル、0 ~ 40 ピクセルの大きさ、および大きさが8に設定された半径がスケールされます。&nbsp;</p>\n\n<pre>\nvar earthquakeLayer = new atlas.layer.BubbleLayer(dataSource, null, {\n     radius: [&#39;interpolate&#39;, [&#39;linear&#39;], [&#39;get&#39;, &#39;magnitude&#39;],\n         0, 2,\n         8, 40\n     ]\n});</pre>\n\n<p>また、同様のデータドリブンスタイルを適用して、各円の色を定義し、次のようなマップを生成することもできます。</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/fa840646-ce65-45f5-9b1f-06e5d75d75bb.png\"><img alt=\"Data driven map style\" border=\"0\" height=\"915\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/beb6bc70-7317-4e54-9d83-3b7be650a4bb.png\" style=\"border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;\" title=\"データドリブンマップスタイル\" width=\"1601\"></a></p>\n\n<p><a href=\"https://aka.ms/am_earthquakesample\" target=\"_blank\">ライブの例</a>を参照してください。</p>\n\n<h2>空間数値演算ライブラリ</h2>\n\n<p>新しい空間数値演算ライブラリが <strong>アトラス</strong> 名前空間に追加されました。これは、多くのマップアプリケーションで一般的に必要とされる有用な計算のコレクションを提供します。 一部の機能は、次のような計算機能を提供します。</p>\n\n<ul>\n <li>位置の間の直線距離。</li>\n <li>行またはパスの長さ。</li>\n <li>位置の間の見出し。</li>\n <li>距離変換。</li>\n <li>カーディナルスプライン。一連の点の間で、優れた滑らかな曲線のパスを計算することができます。</li>\n <li>Geodesic パス。地球の曲率を考慮する2つの点の間の直接のパスです。</li>\n <li>パスに沿った中間位置。</li>\n</ul>\n\n<p><a href=\"https://aka.ms/am_spatialmathsample\" target=\"_blank\">ライブの例</a>を参照してください。</p>\n\n<p>このライブラリには、一般的な単純な空間計算が多数用意されています。 ジオメトリ共用体や交点などのより高度な空間計算が必要な場合は、 <a href=\"https://github.com/Turfjs/turf\" target=\"_blank\">オープンソースの Turf.js ライブラリ</a> が役に立つことがあります。 Turf.js は、Azure Maps 内のすべてのベクトルデータの基本形式である GeoJSON データを直接操作するように設計されており、Azure Maps で簡単に使用できます。</p>\n\n<h2>Geospatially 正確な円のサポート</h2>\n\n<p>GeoJSON スキーマは、geospatially 正確な円を定義するための標準化された方法を提供しません。 このため、Azure Maps チームは、<a href=\"https://docs.microsoft.com/en-us/azure/azure-maps/extend-geojson\" target=\"_blank\">ドキュメント</a>に示されているように、スキーマを壊さずに GeoJSON で geospatially 正確な円を定義するための一般的な方法を標準化しています。 GeoJSON オブジェクトは、純粋な JSON を使用して Azure Maps web コントロールで、または<strong>名前空間</strong>のヘルパークラスを使用して定義できます。 次に示すのは、シアトルで1000を測定する半径を持つ円を定義する方法の例です。</p>\n\n<p><strong>純粋な JSON の使用</strong></p>\n\n<pre>\nvar circle = {\n     &quot;type&quot;: &quot;Feature&quot;,\n     &quot;geometry&quot;: {\n         &quot;type&quot;: &quot;Point&quot;,\n         &quot;coordinates&quot;: [-122.33, 47.6]\n     },\n     &quot;properties&quot;: {\n         &quot;subType&quot;: &quot;Circle&quot;,\n         &quot;radius&quot;: 1000\n     }\n};</pre>\n\n<p><strong>アトラス. data 名前空間のヘルパークラスの使用</strong></p>\n\n<pre>\nvar circle = new atlas.data.Feature(new atlas.data.Point([-122.33, 47.6]), {\n     subType: &quot;Circle&quot;,\n     radius: 1000\n});</pre>\n\n<p>これらの円を描画すると、Azure Maps web コントロールは、この点の特徴を、さまざまなレンダリングレイヤーで使用できる円形の多角形に変換します。 次に示すのは、塗りつぶされた多角形として円がレンダリングされるマップです。</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/d2d894ae-5ed2-49f4-8bf3-3e06ac07c58a.png\"><img alt=\"Map of Seattle\" border=\"0\" height=\"779\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/52ab75ca-1774-4b9b-825b-07e784b1f71c.png\" style=\"border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;\" title=\"シアトルの地図\" width=\"1595\"></a></p>\n\n<p><a href=\"https://aka.ms/am_basicgeocirclesample\" target=\"_blank\">ライブの例</a>を参照してください。</p>\n\n<p>Geospatially の正確な円と BubbleLayer によって生成される円の重要な違いの1つは、バブルレイヤーが各バブルにピクセル半径を割り当てることです。 ユーザーがマップをズームすると、ピクセル半径 &rsquo; は変化しないため、バブルでカバーされるマップ領域は変わりません。 地理的に正確な円の頂点は、マップ上の座標に合わせて調整されます。 マップを拡大すると、円はその領域を拡大縮小して維持します。</p>\n\n<p>このような円は、マップによって使用されているため、常に循環しているとは限りません。 実際、円の近くは、北または南の極に近いほど、表示される可能性が高い、楕円の大きさは円形です。 次のマップは、半径が 750KM (75万 m) の2つの円を示しています。 1つの円は、北極の近くにあるグリーンランドに対してレンダリングされますが、もう一方はブラジルでレンダリングされ、赤道の近くにあります。</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/a008a03d-02bc-41a3-8ef4-f942b11a4076.png\"><img alt=\"Azure Maps Geocircle example\" border=\"0\" height=\"600\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/21c30fa4-b00f-4316-ada7-9e893647a2d3.png\" style=\"border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;\" title=\"Azure Maps Geocircle の例\" width=\"800\"></a></p>\n\n<p><a href=\"https://aka.ms/am_geocirclesample\" target=\"_blank\">ライブの例</a>を参照してください。</p>\n\n<h2>下位互換性</h2>\n\n<p>Azure Maps で既にアプリを開発している場合は、アプリケーション全体を書き直す必要があるかどうかを確認する必要があります。 答えはノーです。 旧バージョンとの互換性を維持するために努力してきました。 これらの関数の多くは、開発者が将来のアプリケーションで使用できないようにするために、ドキュメントで非推奨とマークされていますが、これらの機能は、SDK のバージョン1でも引き続きサポートされます。</p>\n\n<p>これらはすべて、マップコントロールを使用するときに重要な手順をスキップしたいくつかのアプリケーションに対して行われています。 マップコントロールのインスタンスを作成するときは、Web GL キャンバスなどの複数のリソースを読み込む必要があります。 これは非常に高速に行われますが、非同期的に発生します。これは、マップの読み込みが完了する前に、マップインスタンスを作成した後の次のコード行を呼び出す可能性があることを意味します。 そのコード行が、読み込まれる前にマップを操作しようとすると、エラーが発生することがあります。 これを解決するには、 &ldquo; load &rdquo; イベントをマップにアタッチし、マップが読み込まれた後に実行する必要がある機能をイベントのコールバックに追加する必要があります。 現在、map &rsquo; s load イベントを使用していない場合 &rsquo; 、アプリケーションはほとんどの場合に問題なく動作しますが、別のユーザー &rsquo; のデバイスでは正常に機能しない可能性があります。 問題とその解決方法を示すコードを次に示します。</p>\n\n<p><strong>問題点</strong></p>\n\n<pre>\n//Initialize a map instance.\nvar map = new atlas.Map(&#39;myMap&#39;, {\n     &#39;subscription-key&#39;: &#39;Your Azure Maps Key&#39;\n});\n\n//Additional code that interacts with the map. The map may not be finished loading yet.</pre>\n\n<p><strong>以前の API インターフェイスを使用した解決 (まだサポートされています)</strong></p>\n\n<pre>\n//Initialize a map instance.\nvar map = new atlas.Map(&#39;myMap&#39;, {\n     &#39;subscription-key&#39;: &#39;Your Azure Maps Key&#39;\n});\n\n//Wait until the map resources have fully loaded.\nmap.addEventListener(&quot;load&quot;, function (e) {\n     //Add your additional code that interacts with the map here.\n});</pre>\n\n<p><strong>新しい API インターフェイスを使用した解決方法</strong></p>\n\n<pre>\n//Add your Azure Maps subscription key to the map SDK.\natlas.setSubscriptionKey(&#39;Your Azure Maps Key&#39;);\n\n//Initialize a map instance.\nvar map = new atlas.Map(&#39;myMap&#39;);\n\n//Wait until the map resources have fully loaded.\nmap.events.add(&#39;load&#39;, function (e) {\n     //Add your additional code that interacts with the map here.\n});</pre>\n\n<h2>ご意見をお聞かせください</h2>\n\n<p>私たちは、Azure Maps プラットフォームの拡大と改善に常に取り組んでおり、お客様からのご意見をお待ちしております。</p>\n\n<ul>\n <li>機能に関する要望がある場合は、 <a href=\"https://feedback.azure.com/forums/909172-azure-maps\" target=\"_blank\">フィードバックサイト</a>に追加するか、要求を投票します。</li>\n <li>マップデータの問題が見つかりましたか? <a href=\"https://www.tomtom.com/mapshare/tools/\" target=\"_blank\">TomTom &rsquo; s Map Share Reporter ツール</a>を使用して、データプロバイダーに直接送信します。</li>\n <li>コードを動作させるために問題が発生していますか。 Azure ブログに関するトピックをお寄せください。 <a href=\"https://stackoverflow.com/questions/tagged/azure-maps\" target=\"_blank\">Azure Maps フォーラム</a>でお問い合わせください。 ここでは、Azure Maps プラットフォームを最大限に活用できるようにするために、ここで説明 &rsquo; します。</li>\n <li>コードサンプルを探している場合、または共有する優れたサンプルを作成した場合は、 <a href=\"https://github.com/Azure-Samples/AzureMapsCodeSamples\" target=\"_blank\">GitHub</a>にご参加ください。</li>\n</ul>"
