### YamlMime:Yaml
ms.openlocfilehash: fef8ddb325f1602551e7f67c89aa5b964c2c8d5e
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139894932"
Slug: an-end-to-end-prototype-of-aes-encryption-with-acs-authentication-and-acs-token-authorization
Title: ACS 認証と ACS トークン認証を使用した AES 暗号化のエンドツーエンドプロトタイプ
Summary: これは、「ACS 認証と ACS トークン認証を使用した PlayReady 保護のエンドツーエンドプロトタイプを作成した」の「続編」です。
Content: "<h1>はじめに</h1>\nこれは、「 <a href=\"https://azure.microsoft.com/blog/2014/11/17/an-end-to-end-prototype-of-playready-protection-with-acs-authentication-and-acs-token-authorization/\" target=\"_blank\">Acs 認証と Acs トークン認証を使用した PlayReady 保護のエンドツーエンドプロトタイプ</a>を作成した」の「続編」です。\n\n場合によっては、完全な DRM 保護が必須ではないか、経済的な意味を持つことがあります。 代わりに、AES 暗号化を使用することもできます。 ただし、AES 暗号化はとは大きく異なり、DRM ではないことに注意してください。 次の表では、DRM と AES 暗号化の違いについてまとめています。\n<table border=\"0\" width=\"599\" cellspacing=\"0\" cellpadding=\"1\">\n<tbody>\n<tr>\n<td valign=\"top\" width=\"215\"><strong>比較</strong></td>\n<td valign=\"top\" width=\"188\"><strong>PlayReady などの DRM</strong></td>\n<td valign=\"top\" width=\"194\"><strong>AES-128 などの暗号化</strong></td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">コンテンツの保護とファイルの保護</td>\n<td valign=\"top\" width=\"188\">コンテンツ</td>\n<td valign=\"top\" width=\"194\">コンテンツ</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">認証済みユーザーは信頼されていますか。</td>\n<td valign=\"top\" width=\"188\">いいえ。保護されたコンテンツで許可されたユーザーが実行できる内容は、DRM ライセンスに含まれる制限と権限によって制限されます。</td>\n<td valign=\"top\" width=\"194\">はい。許可されたユーザーは、すべてのディスプレイデバイスに対してコピー、保存、共有、またはエクスポートを行うことができます。</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">保護するコンテンツの性質</td>\n<td valign=\"top\" width=\"188\">ビデオなどの共有される興味のコンテンツに適用される</td>\n<td valign=\"top\" width=\"194\">個人のコンテンツに適用されます。ユーザーは、共有することはできません。</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">コンテンツはクライアントデバイスで暗号化解除された後に保護されますか。</td>\n<td valign=\"top\" width=\"188\">はい</td>\n<td valign=\"top\" width=\"194\">いいえ</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">コンテンツへのアクセスを日付/時刻で制限できますか。</td>\n<td valign=\"top\" width=\"188\">はい</td>\n<td valign=\"top\" width=\"194\">いいえ</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">アプリケーションのホワイトリスト登録</td>\n<td valign=\"top\" width=\"188\">はい</td>\n<td valign=\"top\" width=\"194\">いいえ</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">ドメインのバインドと管理</td>\n<td valign=\"top\" width=\"188\">はい</td>\n<td valign=\"top\" width=\"194\">いいえ</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">暗号化キーのローテーション</td>\n<td valign=\"top\" width=\"188\">はい</td>\n<td valign=\"top\" width=\"194\">いいえ</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">ブラック</td>\n<td valign=\"top\" width=\"188\">はい</td>\n<td valign=\"top\" width=\"194\">いいえ</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">出力保護</td>\n<td valign=\"top\" width=\"188\">はい</td>\n<td valign=\"top\" width=\"194\">いいえ</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">ライセンスチェーン</td>\n<td valign=\"top\" width=\"188\">はい</td>\n<td valign=\"top\" width=\"194\">いいえ</td>\n</tr>\n</tbody>\n</table>また\n<a href=\"https://azure.microsoft.com/blog/2014/09/10/announcing-public-availability-of-azure-media-services-content-protection-services/\">Azure Media Services Content Protection</a>では、動的 aes 暗号化機能により、\"1 クリック\" aes 暗号化が現実のものになります。\n\nこのブログでは、トークン認証を使用した smooth streaming 資産の AES 暗号化のエンドツーエンドプロトタイプを紹介します。 認証トークンは、PlayReady 保護のエンドツーエンドプロトタイプで使用されるものと同じ ACS 2.0 名前空間によって発行されます。\n\n&nbsp;\n<h1>エンドツーエンドプロトタイプ</h1>\n<h2>設計と機能</h2>\nこの作業の目的は、次のことをカバーするエンドツーエンドのプロトタイプを提供することです。\n<ul>\n <li>AMS-128 動的暗号化。 AMS の資産に対するトークン制限を使用します。</li>\n <li>暗号化解除キーを配信するためのキー配信サービスを Azure Media Services します。</li>\n <li>SWT 認証トークンを発行するための STS としての<a href=\"https://msdn.microsoft.com/en-us/library/azure/hh147631.aspx\">Azure ACS</a> (Microsoft Azure Active Directory Access Control)。</li>\n <li>OSMF プレーヤー\n<ol>\n <li>ACS サービス Id によって認証されます。</li>\n <li>ACS から認証トークンを取得します。</li>\n <li>ACS トークンを使用して AMS キー配信サービスから復号化キーを取得し、</li>\n <li>復号化とビデオ再生。</li>\n</ol>\n</li>\n</ul>\nこのエンドツーエンドプロトタイプの設計を次の図に示します。\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/11/19/Blog_Secure_Delivery_AES.jpg\"><img style=\"padding-top: 0px; padding-left: 0px; padding-right: 0px; border-width: 0px;\" title=\"Blog_Secure_Delivery_AES\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/Blog_Secure_Delivery_AES_thumb.jpg\" alt=\"Blog_Secure_Delivery_AES\" width=\"631\" height=\"469\" border=\"0\"></a>\n\n&nbsp;\n\nエンドツーエンドのプロトタイプは、Azure でホストされ、Azure Media Services ます。 プロトタイプに関連する情報を次に示します。\n<ul>\n <li>AES 動的暗号化での smooth streaming 資産の URL です。</li>\n <li><a href=\"https://willzhanmediaservice.keydelivery.mediaservices.windows.net/?KID=1814f449-0550-4977-abd5-fe3efeaf6086\" target=\"_blank\">キー配信 URL</a>。</li>\n <li><a href=\"https://willzhanacs.accesscontrol.windows.net/\">SWT authorization トークンを発行する AZURE ACS 名前空間の URL</a>です。</li>\n <li>OSMF プレーヤーの URL。</li>\n</ul>\n&nbsp;\n<h2>実行する方法</h2>\n<ol>\n <li><a href=\"https://azure.microsoft.com/blog/2014/10/27/microsoft-adaptive-streaming-plugin-for-osmf-update/\">Osmf 用のアダプティブストリーミングプラグイン</a>を使用して構築された osmf プレーヤーに移動します。 必要な情報は、既にプレーヤーページの UI にあります。</li>\n <li>[Play] \\ (再生 \\) ボタンをクリックすると、ACS から新しい承認トークンが要求され、新しい承認トークンが OSMF プラグインによって使用されて、再生のための復号化キーの要求が行われることに注意してください。 ACS 2.0 名前空間の認証トークンは、windows media player のページに表示されます。 プレーヤーのスクリーンショットを次に示します。</li>\n</ol>\n<blockquote><a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/11/19/OMFPlayer.jpg\"><img style=\"padding-top: 0px; padding-left: 0px; padding-right: 0px; border-width: 0px;\" title=\"OMFPlayer\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/OMFPlayer_thumb.jpg\" alt=\"OMFPlayer\" width=\"631\" height=\"341\" border=\"0\"></a></blockquote>\n&nbsp;\n<h1>実装</h1>\n実装には、次のものが含まれます。\n<ol>\n <li>Azure Media Services .net API を使用して smooth streaming 資産の動的 AES-128 暗号化を構成します。\n<ul>\n <li>コンテンツキー ID とコンテンツキーを生成します。</li>\n <li>暗号化解除キー配信サービスの構成</li>\n <li>資産配信ポリシーを使用して動的 AES 暗号化を構成する</li>\n <li>アセットを発行します。</li>\n</ul>\n</li>\n <li>プレーヤークライアントを認証し、承認トークンを発行するように Azure ACS 2.0 名前空間を設定します。</li>\n <li>ACS 認証、認証トークン要求、復号化キー要求、およびビデオ再生を処理する OSMF プレーヤーを開発します。</li>\n</ol>\n<a href=\"https://azure.microsoft.com/blog/2014/10/27/microsoft-adaptive-streaming-plugin-for-osmf-update/\">Osmf 用 Microsoft アダプティブストリーミングプラグイン</a>は、オンデマンドとライブの両方でスムーズストリーミングコンテンツの AES 暗号化をサポートしているため、このプロトタイプには osmf プレーヤーを使用することを選択しました。\n\n&nbsp;\n<h2>動的 AES 暗号化の構成</h2>\n最初の手順では、エンベロープの種類のコンテンツキーを作成します。 コードは次のとおりです。\n<div align=\"left\">\n<pre class=\"prettyprint\">static public IContentKey CreateEnvelopeTypeContentKey(CloudMediaContext objCloudMediaContext)\n{\n    // Create envelope encryption content key\n    Guid keyId = Guid.NewGuid();\n    byte[] contentKey = CryptoUtils.GenerateCryptographicallyStrongRandomBytes(16);\n\n    IContentKey objIContentKey = objCloudMediaContext.ContentKeys.Create(keyId, contentKey, \"myContentKey\", ContentKeyType.EnvelopeEncryption);\n\n    return objIContentKey;\n}</pre>\n</div>\n次に、承認ポリシーを作成し、上記で作成したコンテンツキーに追加します。 <a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2331/8475.Blog_5F00_Secure_5F00_Delivery_5F00_API.jpg\" target=\"_blank\">この図</a>に示すように、各 IContentKey には IContentKeyAuthorizationPolicy のインスタンスが1つあります。 次のコードでは、IContentKeyAuthorizationPolicy を作成し、IContentKey にアタッチします。\n<pre class=\"prettyprint\">public static IContentKey AddAuthorizationPolicyToContentKey(CloudMediaContext objCloudMediaContext, IContentKey objIContentKey)\n{\n    // Create ContentKeyAuthorizationPolicy with restrictions and create authorization policy             \n    IContentKeyAuthorizationPolicy policy = objCloudMediaContext.ContentKeyAuthorizationPolicies.CreateAsync(\"Open Authorization Policy\").Result;\n\n    List&lt;ContentKeyAuthorizationPolicyRestriction&gt; restrictions = new List&lt;ContentKeyAuthorizationPolicyRestriction&gt;();\n\n    ContentKeyAuthorizationPolicyRestriction restriction = new ContentKeyAuthorizationPolicyRestriction\n    {\n        Name = \"Authorization Policy with Token Restriction\",\n        KeyRestrictionType = (int)ContentKeyRestrictionType.TokenRestricted,\n        Requirements = ContentKeyAuthorizationHelper.CreateRestrictionRequirements()\n    };\n\n    restrictions.Add(restriction);\n\n    IContentKeyAuthorizationPolicyOption policyOption = objCloudMediaContext.ContentKeyAuthorizationPolicyOptions.Create(\"myDynamicEncryptionPolicy\", ContentKeyDeliveryType.BaselineHttp, restrictions, \"\");\n\n    policy.Options.Add(policyOption);\n\n    // Add ContentKeyAutorizationPolicy to ContentKey\n    objIContentKey.AuthorizationPolicyId = policy.Id;\n    IContentKey IContentKeyUpdated = objIContentKey.UpdateAsync().Result;\n\n    return IContentKeyUpdated;\n}</pre>\n&nbsp;\n\n上記では、CreateRestrictionRequirements () メソッドが次のように定義されています。\n<pre class=\"prettyprint\">public static string CreateRestrictionRequirements()\n{\n    string primarySymmetricKey   = System.Configuration.ConfigurationManager.AppSettings[\"PrimarySymmetricKey\"];\n    string secondarySymmetricKey = System.Configuration.ConfigurationManager.AppSettings[\"SecondarySymmetricKey\"];\n    string scope                 = System.Configuration.ConfigurationManager.AppSettings[\"AcsScope\"];\n    string issuer                = System.Configuration.ConfigurationManager.AppSettings[\"AcsIssuer\"];\n\n    TokenRestrictionTemplate objTokenRestrictionTemplate = new TokenRestrictionTemplate();\n\n    objTokenRestrictionTemplate.PrimaryVerificationKey = new SymmetricVerificationKey(Convert.FromBase64String(primarySymmetricKey));\n    objTokenRestrictionTemplate.AlternateVerificationKeys.Add(new SymmetricVerificationKey(Convert.FromBase64String(secondarySymmetricKey)));\n    objTokenRestrictionTemplate.Audience               = new Uri(scope);\n    objTokenRestrictionTemplate.Issuer                 = new Uri(issuer);\n\n    return TokenRestrictionTemplateSerializer.Serialize(objTokenRestrictionTemplate);\n}</pre>\n&nbsp;\n\n<strong>注:</strong> ACS 2.0 名前空間で使用されているのと <strong>同じ</strong> (プライマリ) 対称ハッシュキーが、(動的な) AES 暗号化承認ポリシーの構成にも使用されていることを確認してください。\n\n次に、資産の配信に使用される IAssetDeliveryPolicy を作成する必要があります。\n<pre class=\"prettyprint\">public static IAssetDeliveryPolicy CreateAssetDeliveryPolicy(CloudMediaContext objCloudMediaContext, IContentKey objIContentKey)\n{\n    Uri keyAcquisitionUri = objIContentKey.GetKeyDeliveryUrl(ContentKeyDeliveryType.BaselineHttp);\n\n    string envelopeEncryptionIV = Convert.ToBase64String(CryptoUtils.GenerateCryptographicallyStrongRandomBytes(16));\n\n    // The following policy configuration specifies: \n    //   key url that will have KID=&lt;Guid&gt; appended to the envelope and\n    //   the Initialization Vector (IV) to use for the envelope encryption.\n    Dictionary&lt;AssetDeliveryPolicyConfigurationKey, string&gt; assetDeliveryPolicyConfiguration = new Dictionary&lt;AssetDeliveryPolicyConfigurationKey, string&gt; \n            {\n                {AssetDeliveryPolicyConfigurationKey.EnvelopeKeyAcquisitionUrl, keyAcquisitionUri.ToString()},\n                {AssetDeliveryPolicyConfigurationKey.EnvelopeEncryptionIVAsBase64, envelopeEncryptionIV}\n            };\n\n    IAssetDeliveryPolicy objIAssetDeliveryPolicy = objCloudMediaContext.AssetDeliveryPolicies.Create(\n                \"SmoothHLSDynamicEncryptionAssetDeliveryPolicy\",\n                AssetDeliveryPolicyType.DynamicEnvelopeEncryption,\n                AssetDeliveryProtocol.SmoothStreaming | AssetDeliveryProtocol.HLS,\n                assetDeliveryPolicyConfiguration);\n\n    Console.WriteLine();\n    Console.WriteLine(\"Adding Asset Delivery Policy: \" + objIAssetDeliveryPolicy.AssetDeliveryPolicyType);\n    Console.WriteLine(\"Key Delivery URL = {0}\", keyAcquisitionUri.ToString());\n\n    return objIAssetDeliveryPolicy;\n}</pre>\n&nbsp;\n\n最後に、上記のすべてを組み合わせて、資産に対して AES 動的暗号化を追加するための次の全体的な流れを示します。\n<pre class=\"prettyprint\">public static void DynamicAesEncryptionFlow(CloudMediaContext objCloudMediaContext, IAsset objIAsset)\n{\n    //Create IContentKey\n    IContentKey objIContentKey = CreateEnvelopeTypeContentKey(objCloudMediaContext);\n\n    //add AuthorizationPolicy to IContentKey\n    objIContentKey = AddAuthorizationPolicyToContentKey(objCloudMediaContext, objIContentKey);\n\n    //create asset delivery policy\n    IAssetDeliveryPolicy objIAssetDeliveryPolicy = CreateAssetDeliveryPolicy(objCloudMediaContext, objIContentKey);\n\n    //Associate IContentKey with IAsset\n    objIAsset.ContentKeys.Add(objIContentKey);\n\n    // Add AssetDelivery Policy to the asset\n    objIAsset.DeliveryPolicies.Add(objIAssetDeliveryPolicy);\n}</pre>\nこれを実行した後、API または Azure portal を使用してプログラムでアセットを発行する必要があります。\n\n&nbsp;\n<h2>ACS のセットアップ</h2>\nこのブログでは、 <a href=\"https://azure.microsoft.com/blog/2014/11/17/an-end-to-end-prototype-of-playready-protection-with-acs-authentication-and-acs-token-authorization/\" target=\"_blank\">Acs 認証と Acs トークン認証を使用した PlayReady 保護のエンドツーエンドのプロトタイプ</a>を、同じ対称検証キー、同じサービス id、同じ発行者とスコープなどを使用して設定したものと同じ acs 2.0 名前空間を使用できます。\n\nACS サービス Id を設定するときに、パスワードまたは対称キー資格情報の種類のいずれかを選択できます。 どちらの場合も、プロトタイプ (以下のトークン要求コード) でサポートされています。\n\n&nbsp;\n<h2>プレーヤーコード</h2>\n<a href=\"https://azure.microsoft.com/blog/2014/10/27/microsoft-adaptive-streaming-plugin-for-osmf-update/\" target=\"_blank\">Microsoft アダプティブストリーミングプラグイン OSMF</a> では、AES-128 暗号化 smooth Streaming のオンデマンド再生とライブ再生の両方がサポートされています。 そのため、OSMF プレーヤーを使用します。 OSMF プレーヤーのフローは次のようになります。\n<ol>\n <li>AES 128 で暗号化されたコンテンツを示す smooth streaming マニフェストをダウンロードします。このマニフェストには、テスト資産のクライアントマニフェストに示されているように、キー配信 URL が含まれています。</li>\n <li>認証トークンの要求</li>\n <li>認証トークンを使用して復号化キーを要求します。</li>\n <li>復号化と再生。</li>\n</ol>\nまず、ACS 名前空間から認証トークンを要求するコードを次に示します。\n<pre class=\"prettyprint\">public string GetAcsToken()\n{\n    string issuer   = System.Configuration.ConfigurationManager.AppSettings[\"AcsIssuer\"];\n    string scope    = System.Configuration.ConfigurationManager.AppSettings[\"AcsScope\"];\n    string username = System.Configuration.ConfigurationManager.AppSettings[\"Username\"];\n    string password = System.Configuration.ConfigurationManager.AppSettings[\"Password\"];\n\n    string tokenToReturn = null;\n\n    using (WebClient client = new WebClient())\n    {\n        //  Create the authentication request to get a token\n        client.BaseAddress = (new Uri(issuer)).AbsoluteUri;\n\n        NameValueCollection objNameValueCollection = null;\n        switch (System.Configuration.ConfigurationManager.AppSettings[\"CredentialType\"].ToLower())\n        {\n            case \"password\":\n                objNameValueCollection = new NameValueCollection\n                {\n                    {\"grant_type\",    \"client_credentials\"},\n                    {\"client_id\",     username},\n                    {\"client_secret\", password},\n                    {\"scope\",         scope}\n                };\n                break;\n            case \"symmetrickey\":\n                objNameValueCollection = new NameValueCollection\n                {\n                    {\"grant_type\",    \"\"},\n                    {\"assertion\",     this.CreateToken(username, password)},\n                    {\"scope\",         scope}\n                };\n                break;\n            default:\n                break;\n        }\n\n        byte[] responseBytes = null;\n\n        try\n        {\n            responseBytes = client.UploadValues(new Uri(issuer + \"/v2/OAuth2-13/\"), \"POST\", objNameValueCollection);\n        }\n        catch (WebException we)\n        {\n            Stream stream = we.Response.GetResponseStream();\n            StreamReader reader = new StreamReader(stream);\n\n            throw;\n        }\n\n        using (var responseStream = new MemoryStream(responseBytes))\n        {\n            OAuth2TokenResponse tokenResponse = (OAuth2TokenResponse)new DataContractJsonSerializer(typeof(OAuth2TokenResponse)).ReadObject(responseStream);\n            tokenToReturn = tokenResponse.AccessToken;\n        }\n    }\n\n    return tokenToReturn;\n}\n\npublic string CreateToken(string issuer, string signingKey)\n{\n    System.Text.StringBuilder sb = new System.Text.StringBuilder();\n    // add the issuer name \n    sb.AppendFormat(\"Issuer={0}\", System.Web.HttpUtility.UrlEncode(issuer));\n    string signature = this.GenerateSignature(sb.ToString(), signingKey);\n    sb.AppendFormat(\"&amp;HMACSHA256={0}\", signature);\n    return sb.ToString();\n} \n\nprivate string GenerateSignature(string unsignedToken, string signingKey)\n{\n    System.Security.Cryptography.HMACSHA256 hmac = new System.Security.Cryptography.HMACSHA256(Convert.FromBase64String(signingKey));\n    byte[] locallyGeneratedSignatureInBytes = hmac.ComputeHash(System.Text.Encoding.ASCII.GetBytes(unsignedToken));\n    string locallyGeneratedSignature = System.Web.HttpUtility.UrlEncode(Convert.ToBase64String(locallyGeneratedSignatureInBytes));\n    return locallyGeneratedSignature;\n}</pre>\n&nbsp;\n\nOAuth2TokenResponse 型は次のように定義されます。\n<pre class=\"prettyprint\">[DataContract]\npublic class OAuth2TokenResponse\n{\n    [DataMember(Name = \"access_token\")]\n    public string AccessToken { get; set; }\n\n    [DataMember(Name = \"expires_in\")]\n    public int ExpirationInSeconds { get; set; }\n}</pre>\n&nbsp;\n\nプレーヤーをホストしている ASP.NET web ページは次のとおりです。\n<pre class=\"prettyprint\">&lt;%@ Page Language=\"C#\" AutoEventWireup=\"true\" CodeBehind=\"Aes128OSMFPlayer.aspx.cs\" Inherits=\"SilverlightApplication.Web.OSMF.Aes128OSMFPlayer\" %&gt;\n\n&lt;!DOCTYPE html&gt;\n\n&lt;html xmlns=\"https://www.w3.org/1999/xhtml\"&gt;\n&lt;head runat=\"server\"&gt;\n    &lt;title&gt;AES Encryption | OSMF Player&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        .auto-style1 {\n            height: 17px;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body style=\"font-family:Verdana;font-size:11px\"&gt;\n    &lt;form id=\"form1\" runat=\"server\"&gt;\n        &lt;div&gt;\n            &lt;h3&gt;End-to-End Prototype of AES Encryption with ACS Authorization Token for Smooth Streaming&lt;/h3&gt;\n            &lt;table&gt;&lt;tr&gt;&lt;td&gt;Source URL: &lt;/td&gt;&lt;td&gt;\n                &lt;asp:TextBox ID=\"txtSrcUrl\" runat=\"server\" Width=\"913px\"&gt;https://willzhanmediaservice.origin.mediaservices.windows.net/474c4840-4753-48ec-b3aa-9d05daef612a/LyncSkypeSizzleVideo750k.ism/manifest&lt;/asp:TextBox&gt;\n            &lt;/td&gt;&lt;/tr&gt;\n            &lt;tr&gt;&lt;td&gt;Key Delivery URL:&lt;/td&gt;&lt;td&gt;&lt;a href=\"https://willzhanmediaservice.keydelivery.mediaservices.windows.net/?KID=1814f449-0550-4977-abd5-fe3efeaf6086\" target=\"_blank\"&gt;https://willzhanmediaservice.keydelivery.mediaservices.windows.net/?KID=1814f449-0550-4977-abd5-fe3efeaf6086&lt;/a&gt;\n            &lt;/td&gt;&lt;/tr&gt;\n                &lt;tr&gt;&lt;td class=\"auto-style1\"&gt;Authorization Token:&lt;/td&gt;&lt;td class=\"auto-style1\"&gt;&lt;%=authorizationToken %&gt;&lt;/td&gt;&lt;/tr&gt;\n            &lt;tr&gt;&lt;td&gt;Token Issuer: &lt;/td&gt;&lt;td&gt;&lt;a href=\"https://willzhanacs.accesscontrol.windows.net\" target=\"_blank\"&gt;https://willzhanacs.accesscontrol.windows.net&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;\n            &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;\n                &lt;asp:Button ID=\"cmdPlay\" runat=\"server\" OnClick=\"cmdPlay_Click\" Text=\"Play\" /&gt;\n            &lt;/td&gt;&lt;/tr&gt;\n            &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;\n                    &lt;object width=\"920\" height=\"640\"&gt;\n                        &lt;param name=\"movie\" value=\"StrobeMediaPlayback.2.0.swf\"&gt;&lt;/param&gt;\n                        &lt;param name=\"flashvars\" value=\"src=&lt;%=srcUrl %&gt;&amp;autoPlay=&lt;%=autoPlay %&gt;&amp;plugin_AdaptiveStreamingPlugin=MSAdaptiveStreamingPlugin-v1.0.12-osmf2.0.swf&amp;AdaptiveStreamingPlugin_retryLive=true&amp;AdaptiveStreamingPlugin_retryInterval=10&amp;AdaptiveStreamingPlugin_encryptionKeyToken=&lt;%=authorizationToken %&gt;\"&gt;&lt;/param&gt;\n                        &lt;param name=\"allowFullScreen\" value=\"true\"&gt;&lt;/param&gt;\n                        &lt;param name=\"allowscriptaccess\" value=\"always\"&gt;&lt;/param&gt;\n                        &lt;param name=\"wmode\" value=\"direct\"&gt;&lt;/param&gt;\n                        &lt;embed src=\"StrobeMediaPlayback.2.0.swf\"\n                            type=\"application/x-shockwave-flash\"\n                            allowscriptaccess=\"always\"\n                            allowfullscreen=\"true\"\n                            wmode=\"direct\"\n                            width=\"920\"\n                            height=\"640\"\n                            flashvars=\"src=&lt;%=srcUrl %&gt;&amp;autoPlay=&lt;%=autoPlay %&gt;&amp;plugin_AdaptiveStreamingPlugin=MSAdaptiveStreamingPlugin-v1.0.12-osmf2.0.swf&amp;AdaptiveStreamingPlugin_retryLive=true&amp;AdaptiveStreamingPlugin_retryInterval=10&amp;AdaptiveStreamingPlugin_encryptionKeyToken=&lt;%=authorizationToken %&gt;\"&gt;\n                        &lt;/embed&gt;\n                    &lt;/object&gt;\n                &lt;/td&gt;&lt;/tr&gt;\n                &lt;/table&gt;\n        &lt;/div&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;</pre>\n&nbsp;\n\nまた、対応する分離コードは次のようになります。\n<pre class=\"prettyprint\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Web;\nusing System.Web.UI;\nusing System.Web.UI.WebControls;\n\nnamespace SilverlightApplication.Web.OSMF\n{\n    public partial class Aes128OSMFPlayer : System.Web.UI.Page\n    {\n        protected string authorizationToken;\n        protected string autoPlay;\n        protected string srcUrl;\n        protected void Page_Load(object sender, EventArgs e)\n        {\n            if (!Page.IsPostBack)\n            {\n                this.Play();\n            }\n        }\n\n        protected void cmdPlay_Click(object sender, EventArgs e)\n        {\n            this.Play();\n        }\n\n        protected void Play()\n        {\n            //Request authorization token from ACS 2.0 namespace\n            WCFService objWCFService = new WCFService();\n            string token = objWCFService.GetAcsToken();\n            token = string.Format(\"Bearer={0}\", token);\n\n            //URL-encode the token before using it\n            authorizationToken = System.Web.HttpUtility.UrlEncode(token);\n\n            srcUrl = txtSrcUrl.Text;\n            autoPlay = true.ToString();\n        }\n    }\n}</pre>\n&nbsp;\n<h1>まとめ</h1>\nここでは、すべての主要なコンポーネントを含む Azure Media Services AES 暗号化ソリューションのエンドツーエンドプロトタイプについて説明しました。\n<ol>\n <li>コンテンツキー ID とコンテンツキーの生成</li>\n <li>Azure Media Services でのストリーミングオリジン</li>\n <li>Azure Media Services Content Protection を使用した AES 暗号化</li>\n <li>Azure Media Services Content Protection を使用した AES キー配信</li>\n <li>Windows media player クライアントを認証し、承認トークンを発行するために、Azure ACS 2.0 を介して STS (Secure Token Service) を実行します。</li>\n <li>Azure IaaS VM でホストされるビデオプレーヤーアプリケーション。 ACS 認証、ACS 承認、復号化キーの取得、およびビデオ再生を処理します。</li>\n</ol>\n&nbsp;\n\n<strong>版</strong>\n\n1/6/2015: OSMF プラグインは、より一般的なシナリオでの AES 暗号化テスト用に拡張されています。このブログで説明されているエンドツーエンドの実装で使用される ACS 名前空間だけでなく、任意の Azure ACS 名前空間で動作するようになりました。 自分の ACS 名前空間のパラメーターやシークレットをテストに置き換えるだけで済みます。\n\n1/23/2015: AMS Content Protection での jwt サポートのリリースでは、このプロトタイプは、STS と IdP の両方として Azure Active Directory (AAD) を使用して、jwt にトークン制限が含まれるように拡張されています。 AMS batch ジョブ (動的 PlayReady 保護または AES 暗号化の設定用): AAD テナントを認識しますが、プレーヤーアプリについては何もありません (プレーヤーは問題ありません)。 AAD テナント: は、windows media player アプリを認識しますが、AMS バッチジョブについては何もありません。 プレーヤーアプリ: AAD のテナントを認識しますが、ams や ams バッチジョブについては何もありません。 つまり、AAD テナントとプレーヤーアプリは相互に認識します。 AMS batch ジョブは AAD テナントを認識しますが、どのプレーヤーがコンテンツを消費しているかは考慮しません。\n\n&nbsp;\n\n<b>確認:</b>Microsoft Azure Media Services チームの Quintin 火傷、ジョージ Trifonov、Mingfei yan に感謝しました。この作業には重要なヘルプが提供されています。"
