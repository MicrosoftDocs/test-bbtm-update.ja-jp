### YamlMime:Yaml
ms.openlocfilehash: 403b4d063ee855443d261682eeb196a72a22fa12
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139892222"
Slug: sql-database-row-level-security-block-predicates
Title: '新しい Row-Level セキュリティ機能: ブロック述語 (プレビュー)'
Summary: ブロック述語は、ユーザーが述語に違反する行を挿入、更新、または削除できないようにするために、セキュリティポリシーを有効にします。 SQL Database のプレビューで使用できるようになりました。
Content: "<p>ブロック述語は、Azure SQL Database の<a href=\"https://azure.microsoft.com/en-us/blog/row-level-security-for-sql-database-is-generally-available/\">行レベルセキュリティ</a>(RLS) のプレビュー拡張機能として使用できるようになりました。 ブロックの述語は、ユーザーが述語に違反する行を挿入、更新、または削除できないようにセキュリティポリシーを有効にすることによって、顧客からのフィードバックの共通ポイントに対処します。 現時点では、任意の Azure SQL Database (V12) サーバーでブロック述語を試すことができます。</p>\n\n<p>ブロック述語の一般的なユースケースは次のとおりです。</p>\n\n<ul>\n    <li>マルチテナントデータベースでのクロステナント挿入の防止</li>\n    <li>挿入、更新、削除の各操作に個別のアクセスロジックを必要とするシナリオを含め、さまざまなユーザーのデータへの書き込みアクセスをきめ細かく制御する</li>\n</ul>\n\n<p>ブロック述語はフィルター述語と同様に定義されているので、RLS の基本について既によく理解している&#39;、&#39;を簡単に開始できます。 たとえば、既に RLS を使用して、ユーザーに表示される行をフィルター処理する&#39;、次に示すように、同じ述語関数をブロック述語として再利用できるようになりました。これにより、ユーザーは、表示されている&#39;の外部に行を挿入または更新できなくなります。</p>\n\n<pre class=\"prettyprint\">\nCREATE SECURITY POLICY Security.userAccessPolicy\n ADD FILTER PREDICATE Security.userAccessPredicate(UserId) ON dbo.MyTable,\n ADD BLOCK PREDICATE Security.userAccessPredicate(UserId) ON dbo.MyTable</pre>\n\n<p>フィルター述語は読み取り操作に適用されますが、ブロック述語は書き込み操作に適用されます。</p>\n\n<ul>\n    <li>INSERT および AFTER UPDATE 述語の後に、述語に対して新しい行の値をチェックします。</li>\n    <li>UPDATE および BEFORE DELETE 述語の前に、既存の行の値が述語に対してチェックされます</li>\n</ul>\n\n<p>(上記のように) 操作が指定されていない場合、ブロック述語はすべての操作に適用されます。 それ以外の場合は、ブロック述語ごとに1つの操作を指定できます。 たとえば、UPDATE の前と DELETE の前にブロック述語を使用する場合は、これらの操作ごとに個別のブロック述語を追加する必要があります。</p>\n\n<p>ここでは&#39;s を使用して、マルチテナントデータベースでのクロステナント挿入を防ぐためにブロック述語を使用する方法を示します。 前の <a href=\"https://azure.microsoft.com/en-us/blog/building-more-secure-middle-tier-applications-with-azure-sql-database-using-row-level-security/\">例</a>と同様に、アプリケーションは CONTEXT_INFO を使用してテナントを識別します。</p>\n\n<pre class=\"prettyprint\">\n-- Create sample table, where each row has a TenantId\nCREATE TABLE Sales (\n OrderId int,\n Qty int,\n Product varchar(10),\n TenantId int\n)\n \nINSERT INTO Sales VALUES \n (1, 53, &#39;Valve&#39;, 1), \n (2, 71, &#39;Bracket&#39;, 2), \n (3, 60, &#39;Wheel&#39;, 2)\ngo\n \n-- Create shared user for application to connect\nCREATE USER AppUser WITHOUT LOGIN\ngo\n \n-- Tenants will have both read and write access\nGRANT SELECT, INSERT, UPDATE, DELETE ON Sales TO AppUser\nDENY UPDATE ON Sales(TenantId) TO AppUser -- never allowed to change TenantId\ngo\n \n-- Enable RLS\nCREATE SCHEMA Security\ngo\n \nCREATE FUNCTION Security.tenantAccessPredicate(@TenantId int)\n RETURNS TABLE\n WITH SCHEMABINDING\nAS\n RETURN SELECT 1 AS accessResult\n WHERE @TenantId = CONVERT(int, CONVERT(varbinary(4), CONTEXT_INFO()))\ngo\n \n-- Note: We only need a block predicate AFTER INSERT, because \n-- rows for BEFORE UPDATE and BEFORE DELETE are already filtered, and \n-- AFTER UPDATE is unnecessary due to the column permission\nCREATE SECURITY POLICY Security.tenantPolicy\n ADD FILTER PREDICATE Security.tenantAccessPredicate(TenantId) ON dbo.Sales,\n ADD BLOCK PREDICATE Security.tenantAccessPredicate(TenantId) ON dbo.Sales AFTER INSERT\ngo\n \n-- Try it out by simulating queries as AppUser connected with TenantId = 2\nEXECUTE AS USER = &#39;AppUser&#39;\nSET CONTEXT_INFO 2\ngo\n \nSELECT * FROM Sales -- only rows for current tenant are visible\ngo\n \nINSERT INTO Sales VALUES (4, 1000, &#39;Wheel&#39;, 1) -- blocked from inserting for wrong tenant!\ngo\n \nREVERT\ngo</pre>\n\n<p><br />\nこの機能はお客様からのフィードバックから直接のものであるため、ブロックの述語を大きな部分で&#39;しています。 試してみてください。以下のコメントにご感想をお寄せください。</p>\n\n<p>詳細については、MSDN の <a href=\"https://msdn.microsoft.com/en-us/library/dn765131.aspx\"><font>行レベルのセキュリティ</font></a> に関するドキュメントを参照してください。</p>"
