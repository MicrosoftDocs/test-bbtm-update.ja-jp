### YamlMime:Yaml
ms.openlocfilehash: cb8a61e9a6308f1fa6480c9acdd387bd12fa6622
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139893263"
Slug: api-versioning-with-azure-api-management
Title: Azure API Management での API のバージョン管理
Summary: 'HTTP Api を構築する開発者と対話する場合、バージョン管理の対象は定期的に取得されます。 クイック web 検索を実行すると、何百もの記事がテーマに関するガイダンスを紹介します。 '
Content: >-
  <p>HTTP Api を構築する開発者と対話する場合、バージョン管理の対象は定期的に取得されます。 クイック web 検索を実行すると、何百もの記事がテーマに関するガイダンスを紹介します。 残念ながら、これら &quot; のベストプラクティス &quot; の多くには、矛盾する情報が含まれています。 たとえば、最初のリリースでは、URL に v1 が常に含まれるとします。 それ以外の人は、本当に悪いと思います。 チームが直面した課題は、すべての開発者がどのようなアプローチを使用するかに関係なく、すべての開発者に役立つバージョン管理機能を構築する方法でした。</p>


  <p>さまざまなバージョン識別機構のサポートが非常に簡単であることがすぐにわかりました。実際の課題は、変更を新しいバージョンとして展開する必要がある場合と、そうでない場合を知ることです。 開発者を妨げることがないように、重大な変更と互換性のない変更の両方をサポートする必要があります。 しかし、これを言うと、どういう意味でしょうか。</p>


  <h2>互換性に影響する変更点</h2>


  <p>互換性に関する <i>変更</i>を使用しなくても、数分以上、バージョン管理 api についての会話を行うことはほとんど不可能です。&#39; すべてのユーザーが重大な変更の結果を理解している間に、互換性に影響する変更点についての合意を得ようとすると、非常に困難になります。 ほとんどの開発者は、優先するプログラミング言語に対して、互換性に影響する変更の定義を行う傾向があります。 この領域内には、コンパイラまたはランタイムエンジンによって定義されたインターフェイスを破壊 &quot; する対象 &quot; を定義する、一貫性のある一連の規則があります。 ただし、標準のルールのセットをツールが適用しないようにする HTTP Api はクロス境界です。 <i>互換性に影響する変更</i>の概念に依存して、ソフトウェアコンポーネントの世界から借用することで、開発者が HTTP api を管理しやすくなります。</p>


  <h2>HTTP Api が異なる</h2>


  <p>HTTP Api の動作は、次の2つの主な理由で、コンポーネント Api とは異なります。</p>


  <ul>
      <li>クライアントコードによって中断される内容が決まります。</li>
      <li>API プロバイダーは、変更がオプトインまたは透過的であるかどうかを選択します</li>
  </ul>


  <h2>HTTP クライアントによる結合の制御</h2>


  <p>HTTP Api を使用すると、オペレーティングシステム、言語、コンパイラ、ライブラリが異なるさまざまなシステム間で呼び出しを行うことができます。 API プロバイダーは、コンシューマーが API 応答を解釈するために使用するツールを制御することはできません。 これらのツールを変更するための許容範囲も大きく異なります。 API プロバイダーが HTTP 応答を変更すると、クライアントがどのクライアントを中断するかは、クライアント&#39;のツールの選択に完全に依存します。 最近、JSON が主に XML に置き換えられた理由の1つは、JSON 空間のほとんどのツールが、特に XML ツールと比較して、データ構造の変更に対して非常に強い方法を使用するためです。 しかし、この区別の許容範囲はパフォーマンスコストが発生します。その理由の1つは、パフォーマンスを重視するシナリオでは、Protobuf、Thrift、Bond などのバイナリ形式に移行することです。</p>


  <h2>API プロバイダーコントロールのタイミング</h2>


  <p>再利用可能なソフトウェアコンポーネントは、一般にパッケージマネージャーを介して配布されます。 ソフトウェアコンポーネントを使用するクライアントは、修正プログラムとして識別されている場合でも、新しいバージョンのコンポーネントを明示的に選択する必要があります。 HTTP Api を使用すると、この方法で&#39;する必要がありません。 API プロバイダーは API を更新でき、応答への変更は直ちにクライアントのコンシューマーに影響を与えます。 ただし、パスセグメントのバージョン番号など、予期される要求メッセージで何らかのバージョン識別子を更新することで、API プロバイダーは、準備ができたときにクライアントが変更をオプトインできるようにすることができます。 Azure API Management では、既存の API 定義を取得し、新しいバージョンを作成することができます。 新しいバージョンは、要求メッセージで、パス、クエリ文字列、または HTTP ヘッダーの識別子によって識別されます。</p>


  <p>すべてのクライアントが変更に対して異なる許容範囲を持つことに同意した場合、クライアントの侵入を防ぐために、展開するすべての変更をオプトインする必要があるのでしょうか。 答えはノーです。 鍵となるのは、API コンシューマーに対して期待を明示的に設定することです。</p>


  <h2>明示的にする</h2>


  <p>コンシューマーは、オプトインできる API 変更の種類と、透過的に適合させる必要がある変更の種類を知る必要があります。 たとえば、ほとんどの Api では、クライアントがオブジェクトを解析できない場合でも、JSON オブジェクトに新しいプロパティを追加できることが想定されています。 クライアントは単にその新しいプロパティを無視するか、値をラウンドトリップさせることが想定されます。 しかし、この予測は、一般的に使用されるツールの既定の動作に基づいて構築されています。 長期的な相互運用性を確保するために、明示的に文書化する必要があります。</p>


  <h2>リビジョンによる透過的な更新の有効化</h2>


  <p>透過的な更新プログラムのデプロイを管理するために、Azure API Management には、API 定義のバージョンを作成する機能とは異なる2つ目の機能が導入されています。 これで、API 定義のリビジョンを作成し、それを個別に変更できます。 Azure API Management で定義されているすべての Api とバージョンの Api は、一連のリビジョンを持つことができます。 重要な違いは、1つのリビジョンのみが <i>現在</i> のものであると見なされ、すべてが同じパブリック URL (使用されている場合はバージョン識別子) を共有することです。 新しいリビジョンを <i>現在</i> のバージョンとしてマークすると、変更を顧客に透過的にデプロイすることができます。 以前のリビジョンにロールバックすることは、それを <i>最新</i> のものとしてマークするだけで簡単です。</p>


  <p>API パブリッシャーが現在のリビジョン以外のリビジョンをテストおよびデバッグできるようにするには、URL で特別なマトリックスパラメーターを使用できます。 たとえば、API に2つのリビジョンがあり、rev = 1 が現在のリビジョンと見なされた場合、次の URL を使用して rev = 2 をテストできます。</p>


  <p>GET https://example.org/api ; rev = 2/customers</p>


  <h2>変更に関する別のパースペクティブ</h2>


  <p>HTTP Api の変更の管理は簡単ではありません。 ただし、変更についてさまざまな観点から考えると、Azure API Management のバージョンとリビジョン機能により、すべてのパースペクティブの開発者にとって、変更の管理が簡単になります。 API コンシューマーは、さまざまな種類の変更の配信メカニズムを明示的に使用することで、中断されないクライアントの展開を確実に行うことができます。また、API プロバイダーは、クライアントを壊すことのない変更を確実に行うことができます。</p>
