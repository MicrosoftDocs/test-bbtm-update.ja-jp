### YamlMime:Yaml
ms.openlocfilehash: 0c6023d7a2d0a546f5f952523e4f89e559b6d327
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139909031"
Slug: compression-for-speed-and-cost-savings
Title: 速度とコスト削減のための圧縮
Summary: '[この記事は、チームによってSQL Azureされました。]SQL Azure 2008 年の enterprise エディションのようなページ レベルまたは行レベルの圧縮は現在SQL Serverされていません。 ただし、... を実装できます。'
Content: '<p>[この記事は、チームによってSQL Azureされました。]</p><p>SQL Azure 2008 年の enterprise エディションのようなページ レベルまたは行レベルの圧縮は現在SQL Serverされていません。 ただし、データ アクセス層に独自の列レベルの圧縮を実装して、圧縮のパフォーマンスとコスト削減を活用できます。 これを行う方法について説明し、このブログ記事でコード例を提供します。</p>  <p>列レベルの圧縮は、データをデータベースに書き込む前に圧縮し、データベースから圧縮解除する概念です。 たとえば、 <b>varchar(max)</b> 列のテキストではなく、平均 80% 少ないデータを保持している圧縮テキストの <b>varbinary(max) </b>があります。</p>  <h2>適切なシナリオ</h2>  <p>特定のシナリオでのみ、列レベルの圧縮がうまく機能します。 列を圧縮する場合は、次の点を考慮してください。</p>  <ul>   <li>大きなテキスト列は圧縮に最適です。最も節約が得られるのです。 圧縮による利益は、圧縮ディクショナリを作成するコスト (圧縮圧縮を使用した結果) を超える必要があります。これは、それ自体が繰り返される大量のデータがある場合にのみ発生します。 この手法は、テキストだけでなく、コンテンツによっては大きな xml データやバイナリ データにもメリットがあります。 たとえば、イメージ BLOB を圧縮したくない場合は、通常は既に圧縮されています。</li>    <li>クエリの WHERE 句に表示される列は圧縮されません。 この手法では、圧縮されたテキストを圧縮解除せずにクエリを実行できます。 また、これらのフィールドに対してクエリを実行したり、これらのフィールドにアクセスしたりSSMSを使用してデータを直接読み込BCP.exe</li>    <li>複数の読み取りを回避するために、アプリケーション側でキャッシュできる列を圧縮します。これにより、テキストの圧縮解除のコストが回避されます。</li> </ul>  <p>たとえば、うまく機能するシナリオは、製品の説明を圧縮し、説明内で検索する必要がなく、あまり頻繁に変更しない Web ベースの製品カタログです。</p>  <h2>利点</h2>  <p>圧縮を使用すると、格納するデータの量を減らし、潜在的なコスト削減を実現できます。 また、パーティション分割の開発コストを回避するために、SQL Azure最大 50 ギガバイトのデータベース サイズを下回る可能性があります。</p>  <p>特定のシナリオでは、圧縮によって、クラスター化インデックスで完全なテーブル スキャンが実行されるクエリの速度が向上する可能性があります。 大きな値 <a href="https://msdn.microsoft.com/en-us/library/ms178158.aspx">のデータ</a>型を処理する場合、列のデータが 8,000 バイト未満の場合は、残りの列データを含むページに格納されます。 8,000 バイトを削減できる場合は、一度にページを作成できる行が増え、テーブルの完全なテーブル スキャンのパフォーマンスが向上します。</p>  <h2>テーブルの変更</h2>  <p>圧縮データは <b>varbinary(max) 列に格納する</b>必要があります。 <b>nvarchar(max) 列</b>を圧縮する場合は、データを圧縮する追加の列を作成する必要があります。 これを行うには、ALTER TABLE コマンドを使用します。 テキストを圧縮したら、 <b>nvarchar(max) 列を削除</b> します。 列を列に追加する Transact-SQLの例を次に示SQL Azure。</p>  <pre class="csharpcode"><span class="kwrd">ALTER</span> <span class="kwrd">TABLE</span> Images <span class="kwrd">ADD</span> PageUriCompressed varbinary(<span class="kwrd">max</span>) <span class="kwrd">NOT</span> <span class="kwrd">NULL</span> <span class="kwrd">DEFAULT</span>(0x0)</pre>      <h4>データ層</h4>    <p>さいわい、.NET CLR 2.0 には、GZipStream クラスを使用して <b>System.IO.Compression</b> 名前空間に組み込むいくつかの大 <a href="https://msdn.microsoft.com/en-us/library/system.io.compression.gzipstream.aspx"><b>きな圧縮があります</b></a> 。 最初に行う必要があるのは、既存のすべての行を新しい列に圧縮するために 1 回使用するスローアウェイ コンソール アプリケーションを作成する必要があります。次に示します。</p>    <pre class="csharpcode"><span class="kwrd">do</span>  {      <span class="kwrd">using</span> (SqlConnection sqlConnection =          <span class="kwrd">new</span> SqlConnection(              ConfigurationManager.ConnectionStrings[<span class="str">&quot;SQLAzure&quot;</span>].ConnectionString))      {          String pageUri;          Int64 Id;            <span class="rem">// Open the connection</span>          sqlConnection.Open();            <span class="rem">// Pull One Row At A Time To Prevent Long Running</span>          <span class="rem">// Transactions</span>          SqlCommand sqlCommand = <span class="kwrd">new</span> SqlCommand(              <span class="str">&quot;SELECT TOP 1 ID, PageUri FROM [Images] WHERE PageUriCompressed = 0x0&quot;</span>,              sqlConnection);            <span class="kwrd">using</span> (SqlDataReader sqlDataReader = sqlCommand.ExecuteReader())          {              <span class="rem">// WWB: Exit Do Loop When There Is No More Rows</span>              <span class="kwrd">if</span> (!sqlDataReader.Read())                  <span class="kwrd">break</span>;                pageUri = (String)sqlDataReader[<span class="str">&quot;PageUri&quot;</span>];              Id = (Int64)sqlDataReader[<span class="str">&quot;ID&quot;</span>];          }            Console.Write(<span class="str">&quot;.&quot;</span>);            <span class="rem">// Compress Into the Memory Stream</span>          <span class="kwrd">using</span> (MemoryStream memoryStream = <span class="kwrd">new</span> MemoryStream())          {              <span class="kwrd">using</span> (GZipStream gzipStream = <span class="kwrd">new</span> GZipStream(memoryStream,                  CompressionMode.Compress, <span class="kwrd">true</span>))              {                  <span class="rem">// Unicode == nvarchar</span>                  Byte[] encodedPageUri = Encoding.Unicode.GetBytes(pageUri);                  gzipStream.Write(encodedPageUri, 0, encodedPageUri.Length);              }                <span class="rem">// Now Everything is compressed into the memoryStream</span>              <span class="rem">// Reset to Zero Because We Are Going To Read It</span>              memoryStream.Position = 0;                <span class="rem">// WWB: Stream for Writing</span>              <span class="kwrd">using</span> (SqlStream sqlStream = <span class="kwrd">new</span> SqlStream(sqlConnection,                  <span class="str">&quot;dbo&quot;</span>,                  <span class="str">&quot;Images&quot;</span>,                  <span class="str">&quot;PageUriCompressed&quot;</span>,                  <span class="str">&quot;ID&quot;</span>,                  SqlDbType.BigInt, Id))              {                  <span class="kwrd">using</span> (BinaryReader binaryReader = <span class="kwrd">new</span> BinaryReader(memoryStream))                  {                      <span class="kwrd">using</span> (BinaryWriter binaryWriter = <span class="kwrd">new</span> BinaryWriter(sqlStream))                      {                          Int32 read;                          Byte[] buffer = <span class="kwrd">new</span> Byte[1024];                          <span class="kwrd">do</span>                          {                              read = binaryReader.Read(buffer, 0, 1024);                              <span class="kwrd">if</span> (read &gt; 0)                                  binaryWriter.Write(buffer, 0, read);                            } <span class="kwrd">while</span> (read &gt; 0);                      }                  }              }          }      }  } <span class="kwrd">while</span> (<span class="kwrd">true</span>);    Console.WriteLine(<span class="str">&quot;&quot;</span>);</pre>      <p>このコードでは、このブログ記事で紹介した <b>SqlStream</b> クラスを使用します。また、圧縮される文字列が本当に大きい場合は、ローカル メモリを十分に使用し、消費しすぎずに試みます。 ただし、これにより、非常に "おしゃべり" なアプリケーションが作成され、SQL Azure への接続が作成され、必要以上に低速で実行されます。</p>    <h2>評価</h2>    <p>次の手順では、圧縮された が本当に役立ったのか評価します。 これは、実際のデータを圧縮するまで圧縮の利点を評価するのは難しい可能性があるからです。 これを行うには、Transact-SQL の DATALENGTH フィールドを使用して、圧縮の前と後の 2 つの列を合計します。 クエリは次のように表示されます。</p>    <pre class="csharpcode"><span class="kwrd">SELECT</span> <span class="kwrd">COUNT</span>(1), <span class="kwrd">SUM</span>(DATALENGTH(PageUri)), <span class="kwrd">SUM</span>(DATALENGTH(PageUriCompressed))  <span class="kwrd">FROM</span> Images</pre>      <p>結果は、次のようになります。</p>    <p><a href=""><img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="clip_image001" border="0" alt="clip_image001" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/1727.clip_5F00_image001_5F00_thumb.png" width="273" height="92"></a></p>    <p>この場合、圧縮によって実際にデータベースのサイズが小さになるのが分かっているのが分かっている。 一部のシナリオでは、圧縮によってデータが大きになります。通常、データ ディクショナリが圧縮による利益を超える場合です。 経験則として、テキストに対して効果的な圧縮を行うには、複数の繰り返しフレーズが必要です。これは、長いテキスト ブロックで発生します </p>    <h2>コード </h2>    <p>列が圧縮されたので、圧縮されたデータを読み取り、圧縮されていないデータを圧縮された列に書き込む必要があります。 これを行うのに役立つコード例を次に示します。</p>    <pre class="csharpcode"><span class="kwrd">protected</span> <span class="kwrd">static</span> String Read(Int64 id)  {      <span class="kwrd">using</span> (SqlConnection sqlConnection =          <span class="kwrd">new</span> SqlConnection(              ConfigurationManager.ConnectionStrings[<span class="str">&quot;SQLAzure&quot;</span>].ConnectionString))      {          sqlConnection.Open();            SqlCommand sqlCommand = <span class="kwrd">new</span> SqlCommand(              <span class="str">&quot;SELECT PageUriCompressed FROM [Images] WHERE ID = @Id&quot;</span>,                  sqlConnection);            sqlCommand.Parameters.AddWithValue(<span class="str">&quot;@Id&quot;</span>, id);            <span class="kwrd">using</span> (SqlDataReader sqlDataReader = sqlCommand.ExecuteReader())          {              sqlDataReader.Read();                Byte[] compressedPageUri =                   (Byte[])sqlDataReader[<span class="str">&quot;PageUriCompressed&quot;</span>];                <span class="kwrd">using</span> (MemoryStream memoryStream =                   <span class="kwrd">new</span> MemoryStream(compressedPageUri))              {                  <span class="kwrd">using</span> (GZipStream gzipStream = <span class="kwrd">new</span> GZipStream(memoryStream,                       CompressionMode.Decompress))                  {                      <span class="kwrd">using</span> (StreamReader streamReader =                          <span class="kwrd">new</span> StreamReader(gzipStream, Encoding.Unicode))                      {                          <span class="kwrd">return</span> (streamReader.ReadToEnd());                      }                  }              }          }      }  }</pre>      <p>書き込み用:</p>    <pre class="csharpcode">protected <span class="kwrd">static</span> void <span class="kwrd">Write</span>(Int64 id, String pageUri)  {      <span class="kwrd">using</span> (SqlConnection sqlConnection =          <span class="kwrd">new</span> SqlConnection(              ConfigurationManager.ConnectionStrings[&quot;SQLAzure&quot;].ConnectionString))      {          // <span class="kwrd">Open</span> the <span class="kwrd">connection</span>          sqlConnection.<span class="kwrd">Open</span>();            // Compress <span class="kwrd">Into</span> the Memory Stream          <span class="kwrd">using</span> (MemoryStream memoryStream = <span class="kwrd">new</span> MemoryStream())          {              <span class="kwrd">using</span> (GZipStream gzipStream = <span class="kwrd">new</span> GZipStream(memoryStream,                  CompressionMode.Compress, <span class="kwrd">true</span>))              {                  // Unicode == nvarchar                  Byte[] encodedPageUri = Encoding.Unicode.GetBytes(pageUri);                  gzipStream.<span class="kwrd">Write</span>(encodedPageUri, 0, encodedPageUri.Length);              }                // Now Everything <span class="kwrd">is</span> compressed <span class="kwrd">into</span> the memoryStream              // Reset <span class="kwrd">to</span> Zero Because We <span class="kwrd">Are</span> Going <span class="kwrd">To</span> <span class="kwrd">Read</span> It              memoryStream.<span class="kwrd">Position</span> = 0;                // WWB: Stream <span class="kwrd">for</span> Writing              <span class="kwrd">using</span> (SqlStream sqlStream = <span class="kwrd">new</span> SqlStream(sqlConnection,                  &quot;dbo&quot;,                  &quot;Images&quot;,                  &quot;PageUriCompressed&quot;,                  &quot;ID&quot;,                  SqlDbType.BigInt, id))              {                  <span class="kwrd">using</span> (BinaryReader binaryReader = <span class="kwrd">new</span> BinaryReader(memoryStream))                  {                      <span class="kwrd">using</span> (BinaryWriter binaryWriter = <span class="kwrd">new</span> BinaryWriter(sqlStream))                      {                          Int32 <span class="kwrd">read</span>;                          Byte[] buffer = <span class="kwrd">new</span> Byte[1024];                          do                          {                              <span class="kwrd">read</span> = binaryReader.<span class="kwrd">Read</span>(buffer, 0, 1024);                              <span class="kwrd">if</span> (<span class="kwrd">read</span> &gt; 0)                                  binaryWriter.<span class="kwrd">Write</span>(buffer, 0, <span class="kwrd">read</span>);                            } <span class="kwrd">while</span> (<span class="kwrd">read</span> &gt; 0);                      }                  }              }          }      }  }</pre>      <h2>SQL圧縮</h2>    <p>比較のために、オンプレミスの SQL Server に組み込む圧縮はアプリケーションに対して透過的であり、decimal 型や <b>bigint</b> 型など、<b></b>より広い範囲の型を使用すると、ページの行にスコープが設定されます。 つまり、ページ内のすべての列の圧縮で繰り返しディクショナリを使用できます。 2008 年の圧縮のSQL Serverについては、こちらを参照<a href="https://www.microsoft.com/sqlserver/2008/en/us/compression.aspx">してください</a>。</p>    <h2>まとめ</h2>    <p>同じことを実現するより良い方法はありますか? 以下のコメントに投稿してください。 質問、懸念事項、コメントはありますか? 以下に投稿すると、対処を試みることができます。</p>'
