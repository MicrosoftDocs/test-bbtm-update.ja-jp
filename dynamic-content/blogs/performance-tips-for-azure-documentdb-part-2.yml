### YamlMime:Yaml
ms.openlocfilehash: 3217081424b9117dc2f231af94f2f77b616ae81d
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139903995"
Slug: performance-tips-for-azure-documentdb-part-2
Title: Azure DocumentDB のパフォーマンスヒント-第2部
Summary: この投稿では、インデックス作成ポリシー、スループットの最適化、整合性レベルのパフォーマンスへの影響について説明します。
Content: >-
  <div style="background: rgb(238, 238, 238); padding: 5px 10px; border: 1px solid rgb(204, 204, 204); border-image: none;"><strong>2016 年8月5日の時点で更新する:</strong> パフォーマンスに関するヒントは、「 <em><a href="https://azure.microsoft.com/documentation/articles/documentdb-performance-tips/">DocumentDB のパフォーマンスに関するヒント</a></em> 」ドキュメントに記載され、更新されました。</div>


  <p><b>Azure documentdb &ndash; のパフォーマンスヒントパート 2</b> <a href="https://azure.com/docdb">azure documentdb</a>を使用すると、アプリケーションのニーズに最も合うようにデータベースのパフォーマンスを調整できます。 &nbsp;このシリーズの<a href="https://azure.microsoft.com/blog/2015/01/20/performance-tips-for-azure-documentdb-part-1-2/">第1部</a>では、DocumentDB で利用できるネットワークと SDK の構成オプションと、そのパフォーマンスへの影響について説明しました。 この投稿では、インデックス作成ポリシー、スループットの最適化、整合性レベルのパフォーマンスへの影響について説明します。 &nbsp; パフォーマンスチューニングの推奨設定と同様に、これらのヒントの1つがユースケースに適用されるとは限りませんが、この情報をガイドとして使用して、アプリケーションに適した設計を選択できます。</p>


  <h1>インデックス作成ポリシー</h1>


  <p><b>インデックス作成ポリシーのヒント #1: 遅延インデックスを使用してピーク時のインジェスト料金を高速にする</b>DocumentDB では、コレクションレベル &ndash; でインデックス作成ポリシーを指定 &ndash; できます。これにより、コレクション内のドキュメントに自動的にインデックスを作成するかどうかを選択できます。 &nbsp;さらに、同期 (Consistent) インデックス更新と非同期 (レイジー) インデックス更新のいずれかを選択することもできます。 既定では、コレクションに対するドキュメントの挿入、置換、削除のたびに、インデックスが同期的に更新されます。 これにより、クエリは、インデックスをキャッチアップ &quot; する &ldquo; ための遅延なしで、ドキュメントの読み取りと同じ<a href="https://azure.microsoft.com/en-us/documentation/articles/documentdb-consistency-levels/">一貫性レベル</a>に従うことができます。 データが一括で書き込まれるときに、コンテンツのインデックス作成に必要な処理を長時間にわたって分割して実行する場合に、遅延インデックス作成を検討します。 これにより、プロビジョニングされたスループットを効果的に使用し、待機時間を最小限に抑えながら書き込み要求を処理することができます。 ただし、遅延インデックス作成を有効にしても、DocumentDB アカウント用に構成された整合性レベルに関係なく、クエリの結果では最終的に整合性が維持されることに注意してください。 したがって、整合インデックス作成モード (IndexingPolicy.IndexingMode が Consistent に設定されている場合) では、書き込みごとに最大の要求ユニット使用量が発生しますが、遅延インデックス作成モード (IndexingPolicy.IndexingMode が Lazy に設定されている場合) とインデックスなし (IndexingPolicy.Automatic が False に設定されている場合) では、書き込み時のインデックス作成コストがゼロになります。 <b>インデックス作成ポリシーヒント</b><b> # 2: 使用されていないパスをインデックス作成から除外する高速書き込みで</b> は、DocumentDB &rsquo; s インデックス作成ポリシーを使用して、インデックス作成パスを使用して、インデックス作成に含めるまたは除外するドキュメントパスを指定することもできます (IndexingPolicy indexingpolicy.includedpaths と IndexingPolicy)。 インデックス作成のコストはインデックス付けされた一意のパスの数に直接関連付けられるため、インデックス作成のパスを使用すると、クエリパターンが事前にわかっているシナリオで書き込みパフォーマンスが向上し、インデックスストレージが小さくなる可能性があります。 &nbsp; 例えば：</p>


  <pre class="prettyprint">

  //exclude index paths


  collection.IndexingPolicy.ExcludedPaths.Add(&quot;/\&quot;metaData\&quot;/*&quot;); collection.IndexingPolicy.ExcludedPaths.Add(&quot;/\&quot;subDoc\&quot;/\&quot;subSubDoc\&quot;/\&quot;someProperty\&quot;/*&quot;);

  collection = await client.CreateDocumentCollectionAsync(databaseLink, collection);</pre>


  <p><b>インデックス作成ポリシー </b><b>ヒント #3: 範囲クエリで使用されるすべてのパスに対する範囲インデックスのパスの種類を指定</b> します。 DocumentDB では、現在、ハッシュと範囲という2種類のインデックスパスをサポートしています。 ハッシュのインデックスパスの種類を選択すると、効率的な等値クエリが有効になります。 範囲のインデックスの種類を選択すると、範囲クエリが有効になります ( &gt; 、 &gt; &lt; 、=、 &lt; =)。 &nbsp; &nbsp;例えば：</p>


  <pre class="prettyprint">

  var collection = new DocumentCollection

  {
        Id = ConfigurationManager.AppSettings[&quot;CollectionId&quot;]
  };


  collection.IndexingPolicy.IncludedPaths.Add(new IndexingPath

  {
         IndexType = IndexType.Hash,
         Path = &quot;/&quot;,
  });


  collection.IndexingPolicy.IncludedPaths.Add(new IndexingPath

  {
         IndexType = IndexType.Range,
         Path = @&quot;/&quot;&quot;shippedTimestamp&quot;&quot;/?&quot;,
         NumericPrecision = 7
  });


  collection = await client.CreateDocumentCollectionAsync(databaseLink, collection);</pre>


  <p><b>インデックス作成ポリシー </b><b>のヒント #4: 書き込みとクエリのパフォーマンスとストレージのトレードオフのインデックスの有効桁数</b> を変更します。最後に、インデックス作成ポリシーを使用して、クエリのパフォーマンスを向上させるために、インデックスのパスの有効桁数をバイト単位で変更できます。 より高い有効桁数でインデックス付けされたパスに対してクエリを実行する方が、通常は高速ですが、インデックスのストレージオーバーヘッドが大きくなります。 反対に、低い精度を選択すると、クエリの実行中により多くのドキュメントを処理する必要がありますが、ストレージのオーバーヘッドは低くなります。 インデックス作成ポリシーの詳細については、こちら <a href="https://azure.microsoft.com/en-us/documentation/articles/documentdb-indexing-policies/">のドキュメントを</a> 参照してください。</p>


  <blockquote><b>注:</b> 現在、プレビューリリースでは、コレクションのインデックスポリシーは、コレクションの作成時にのみ指定できます。</blockquote>


  <h1>スループット</h1>


  <p><b>スループットのヒント #1: 低い要求ユニット/秒の使用率の測定と調整</b> DocumentDB には、データベースコレクション内のドキュメントですべての操作を実行する Udf、ストアドプロシージャ、およびトリガー &ndash; を使用したリレーショナルクエリや階層クエリなど、さまざまなデータベース操作が用意されています。 これらの各操作に関連するコストは、操作を完了するために必要な CPU、IO、およびメモリによって異なります。 ハードウェア リソースの管理について考える代わりに、各種のデータベース操作を実行しアプリケーション要求を処理するのに必要なリソースに関する単一の測定単位として要求単位 (RU) を考えることができます。 要求ユニットは、購入した容量ユニットの数に基づいて、各データベースアカウントに対してプロビジョニングされます。 要求単位の消費は、1 秒あたりのレートとして評価されます。 アカウントに対してプロビジョニングされた要求ユニットレートを超過したアプリケーションは、レートがアカウントの予約済みレベルを下回るまで調整されます。 アプリケーションでより高いスループットが必要になった場合は、追加の容量単位を購入できます。 クエリの複雑さは、操作で消費される要求ユニット数に影響します。 述語の数、述語の特性、UDF 数、ソース データ セットのサイズのすべてがクエリ操作のコストに影響します。 任意の操作 (作成、更新、または削除) のオーバーヘッドを測定するに <b>は、ResourceResponse </b> &lt; &gt; &lt; &gt; ヘッダー (または、.net SDK では、またはそれと同等の requestcharge プロパティ) を調べて、これらの操作で使用される要求ユニットの数を計測します。</p>


  <pre class="prettyprint">

  // Measure the performance (request units) of writes


  ResourceResponse&lt;Document&gt; response = await client.CreateDocumentAsync(collectionSelfLink, myDocument);


  Console.WriteLine(&quot;Insert of document consumed {0} request units&quot;, response.RequestCharge);


  // Measure the performance (request units) of queries


  IDocumentQuery&lt;dynamic&gt; queryable = client.CreateDocumentQuery(collectionSelfLink, queryString).AsDocumentQuery();


  while (queryable.HasMoreResults)
       {

            FeedResponse&lt;dynamic&gt; queryResponse = await queryable.ExecuteNextAsync&lt;dynamic&gt;();

            Console.WriteLine(&quot;Query batch consumed {0} request units&quot;, queryResponse.RequestCharge);
       }</pre>

  <p>このヘッダーで返される要求の料金は、プロビジョニングされたスループットの一部 (つまり、2000 Ru/秒) です。 &nbsp; &nbsp;たとえば、上記のクエリが 1000 1 KB ドキュメントを返す場合、操作のコストは1000になります。 そのため、1秒以内に、サーバーは、後続の要求を調整する前に、このような要求を2つしか受け入れません。 <b>スループットのヒント #2: サーバースロットル/要求の処理率が大きすぎ &nbsp; ます </b> クライアントがアカウントの予約済みスループットを超えようとすると、サーバーでパフォーマンスが低下することはなく、予約済みのレベルを超えてスループット容量が使用されることもありません。 サーバーはいち早く RequestRateTooLarge (HTTP 状態コード 429) で要求を終了させ、要求を再試行するまでにユーザーが待機しなければならない時間 (ミリ秒) を示す x-ms-retry-after-ms ヘッダーを返します。</p>


  <blockquote>HTTP 状態429、状態行: いち早く requestratetoolarge-ミリ秒-ミリ秒: 100</blockquote>


  <p>.NET クライアント SDK と LINQ クエリ使用していると、ほとんどの場合は、この例外に対処する必要がありません。なぜなら、最新バージョンの .NET クライアント SDK は暗黙的にこの応答を取得し、サーバーが規定した retry-after ヘッダーを考慮して、要求を再試行するからです。 アカウントに複数のクライアントが同時アクセスしている状況でなければ、次回の再試行は成功します。 常に要求レートを超えて動作するクライアント累積的が複数ある場合、.NET クライアントによって既定で3に設定されている再試行には不十分な場合があります。この場合、クライアントは、ステータスコード429を含む DocumentClientException をアプリケーションにスローします。 .NET SDK の現在のリリースでは、既定の再試行回数をオフにする方法がないことに注意してください。 自動再試行動作は、ほとんどのアプリケーションの回復性と使いやすさを向上させるのに役立ちますが、特に待機時間を測定する場合は、パフォーマンスベンチマークの実行時には問題になる可能性があります。 &nbsp; 実験がサーバーのスロットルに達し、クライアント SDK がサイレントに再試行すると、クライアントによって監視される待機時間が急増します。 パフォーマンスの実験中に待機時間が急増するのを回避するには、各操作で返される使用量を測定し、予約済みの要求レートを下回った状態で要求が行われていることを確認します。 <b>スループットのヒント #3: 空のコレクションを削除して、プロビジョニングされたすべてのスループットを利用する</b>DocumentDB アカウントで作成されたすべてのドキュメントコレクションには、プロビジョニングされた容量ユニット (Cu) の数と作成されたコレクションの数に基づいて、予約済みのスループット容量が割り当てられます。 &nbsp; &nbsp;1つの CU で2000要求ユニット (Ru) を使用できるようになり、最大3つのコレクションをサポートします。 CU に対して作成されたコレクションが1つだけの場合は、そのコレクションに対して CU スループット全体が使用可能になります。 2番目のコレクションが作成されると、最初のコレクションのスループットが半分になり、2番目のコレクションに渡されます。 追加の Cu をプロビジョニングすることにより、既存のコレクションのスループットを増やすことができます。 DocumentDB Preview では、1つのコレクションで最大 10 GB まで拡張でき、1つの CU の最大スループット (2000 要求ユニット/秒) まで割り当てることができます。 コレクションあたりの使用可能なスループットを最大化するには、コレクションへの容量ユニットの数が1:1 であることを確認します。 <b>スループットのヒント #4: より大きいスループットのために小さなドキュメントを設計する</b> 特定の操作の要求の料金 (要求処理コスト) は、ドキュメントのサイズに直接関連付けられます。 サイズの大きいドキュメントの操作は、サイズの小さいドキュメントの操作よりもコストがかかります。</p>


  <h1>整合性レベル</h1>


  <p><b>整合性レベルのヒント #1: 読み取り待機時間を短縮するには、弱い整合性レベルを使用します。</b> DocumentDB アプリケーションのパフォーマンスを調整する際に考慮する必要があるもう1つの重要な要素は、一貫性レベルです。 整合性レベルの選択は、読み取りと書き込みの両方のパフォーマンスに影響します。 データベースアカウントの既定の整合性レベルと、選択した一貫性レベルを構成すると、DocumentDB アカウント内のすべてのコレクション (すべてのデータベース) に適用されます。 書き込み操作に関しては、整合性レベルの変更の影響は、要求の待機時間として監視されます。 より高い整合性レベルが使用されると、 <i>書き込み</i> の待機時間が長くなります。 一方、 <i>読み取り</i> 操作に対する整合性レベルの影響は、スループットの観点から見ていきます。 弱い整合性レベルを使用すると、クライアントで読み取りスループットを向上させることができます。 既定では、ユーザー定義リソースに対して発行されたすべての読み取りとクエリは、データベースアカウントに指定された既定の一貫性レベルを使用します。 ただし、特定の読み取り/クエリ要求の一貫性レベルを下げることができます。これを行うには、-ms-chap レベル<b></b>の要求ヘッダーを指定します。</p>


  <h1>まとめ</h1>


  <p>この投稿と<a href="https://azure.microsoft.com/blog/2015/01/20/performance-tips-for-azure-documentdb-part-1-2/">第 1</a> &rsquo; 部の間に、パフォーマンスに関するヒントがあります。このヒントは、DocumentDB の使用に適しています。 &nbsp;私たちは、DocumentDB の機能や、最も価値のあるエクスペリエンスについて、皆様のご意見をお待ち &rsquo; しております。 &nbsp;Microsoft Azure DocumentDB<a href="https://feedback.azure.com/forums/263030-documentdb?filter=top&amp;page=1">フィードバックフォーラム</a>でご提案をお送りください。 &nbsp;&rsquo;まだ DocumentDB を試していない場合は、<a href="https://azure.microsoft.com/en-us/services/documentdb/">ここ</a>から始めましょう。</p>
