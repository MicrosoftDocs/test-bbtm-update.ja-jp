### YamlMime:Yaml
ms.openlocfilehash: 034c728262e69522dcd28493c5f8450addd3bc60
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139909321"
Slug: azure-functions-the-journey
Title: 'Azure Functions: この旅 '
Summary: '私たちのチームは、新しい Azure Functions サービスのプレビュー版を作成しました。 このサービスについては、既にいくつかのブログを作成しました (Azure Functions など)。しかし、この記事では、バックグラウンドで少し掘り下げて、プロジェクトがどのように開始されたかと、現在の場所に到達するための旅について説明します。 '
Content: >-
  <p><em>このブログ投稿は、Microsoft の主要ソフトウェアエンジニアである Mathew によって作成されました。</em></p>


  <p>私たちのチームは、新しい <a href="https://azure.microsoft.com/en-us/services/functions/">Azure Functions</a> サービスのプレビュー版を作成しました。 本サービスについては、既にいくつかのブログを作成しまし &rsquo; た ( <a href="https://azure.microsoft.com/en-us/blog/introducing-azure-functions/">Azure Functions</a>など)。しかし、この記事 &rsquo; では、バックグラウンドで少し掘り下げて、プロジェクトがどのように開始されたか、そして現在の場所に到達した &rsquo; ことについて説明します。 &rsquo;Functions ランタイム、動的コンピューティング層 ( &ldquo; サーバーレス &rdquo; )、および functions ポータルについて説明し、これらすべての要素がどのように進化し、まとまりのある製品にまとめられているかを大まかに説明します。 これ &rsquo; はチームにとって楽しい作業であり、開始し &rsquo; たばかりです。</p>


  <p>このプロジェクトの進化は、既存のさまざまなプラットフォーム部分にわたる相乗効果を識別し、それらを新しい製品オファリングに接続するための優れた例です。 Azure App Service には、Azure Functions ビジョンで迅速に実行できるように、多くの構成要素が既に用意されています。 これらの既存の資産を活用して新しいイノベーションや機能を導入することで、プロジェクトを迅速に作成できるようになりました。</p>


  <h2>WebJobs SDK</h2>


  <p>「Chris &rsquo; のビルド」で、 <a href="https://github.com/Azure/azure-webjobs-sdk">Azure WebJobs SDK</a>で Azure Functions がどのように構築されているか<a href="https://channel9.msdn.com/events/Build/2016/B858">Azure Functions</a>説明しました。 Web ジョブ SDK は数年で既に存在しています。多くのお客様がこの SDK を使用して、さまざまなイベントソースでトリガーされるバックエンド処理ジョブを構築しています。 Web ジョブ SDK には、単純な宣言型プログラミングモデルが用意されています。これにより、最小限のコードで高度なジョブ関数を簡単に記述できます。 ここに例を示します。</p>


  <pre>

  public static void ProcessOrder(

      [QueueTrigger(&ldquo;orders&rdquo;)] Order order,

      [Blob(&ldquo;processed/{Id}&rdquo;)] out string receipt,

  TraceWriter log)

  {

  log.Verbose(string.Format(&ldquo;Processing Order {0}&rdquo;, order.Id));


      // business logic


      receipt = &ldquo;&lt;some value&gt;&rdquo;;

  }</pre>


  <p>Web ジョブ SDK JobHost がバニラ .NET コンソールアプリケーションでホストされている場合、この関数は、Azure キュー &ldquo; の注文 &rdquo; に新しいキューメッセージが追加されるたびに自動的にトリガーされ、キューペイロードは注文 POCO のインスタンスに逆シリアル化されます。 また、この関数は、blob パスの一部として受信メッセージの Id &rdquo; プロパティを使用して &ldquo; 、出力 blob に自動的にバインドします。 このプログラミングモデルを使用すると、ジョブ関数はビジネスロジック &rsquo; にのみ焦点を当て、ストレージ操作を処理する必要がありません。 すごいですね。</p>


  <p>Web ジョブ SDK を使用したこのような関数のホスティングモデルは、 <a href="https://azure.microsoft.com/en-us/documentation/articles/web-sites-create-web-jobs/">Azure WebJobs</a>としてデプロイすることです。 これは優れた機能であり、多くの柔軟性を備えており、Azure App Service の非常に一般的な機能です。</p>


  <h2>Functions ランタイム</h2>


  <p>昨年の中心として、この単純なプログラミングモデルを他の言語 &ndash; に持ち込むことについて説明しました。これについてもお客様から &rsquo; の要望があります。 すべてのユーザーが .NET C# プログラマであるとは限りませんが、多くの場合、これらの Web ジョブ SDK パターンを使用したいと考えています。 このため、プロトタイプ作成作業を開始し、既存の試行された .NET Web ジョブ SDK ランタイムを利用できるモデルと共に、メタデータの新しい JSON 記述モデルでレイヤー化しました。 結果として、上記と同じ関数を Node.js (またはその他の言語) で記述できます。</p>


  <pre>

  module.exports = function (context, order) {

  context.log(&lsquo;Processing order&rsquo;, order.id);


      // business logic


  context.bindings.receipt = &ldquo;&lt;some value&gt;&rdquo;;

  context.done();

  }</pre>


  <p>&rsquo;この関数は、上記の C# 関数と構造的に同じであることがわかります。 &rsquo;これは、同じランタイム実装にマップされるためです。 宣言型コード属性は、メタデータを指定する1つの方法にすぎません。 単純な JSON 記述ファイルで同じ情報をキャプチャできることに気付きました。 ここでは、この関数のバインディングを記述する、対応するメタデータファイル (C# の例では、宣言型の属性に含まれるすべてのビット) を示し &rsquo; ます。</p>


  <pre>

  {

    &ldquo;bindings&rdquo;: [

      {

        &ldquo;type&rdquo;: &ldquo;queueTrigger&rdquo;,

        &ldquo;name&rdquo;: &ldquo;order&rdquo;,

        &ldquo;direction&rdquo;: &ldquo;in&rdquo;,

        &ldquo;queueName&rdquo;: &ldquo;orders&rdquo;

      },

      {

        &ldquo;type&rdquo;: &ldquo;blob&rdquo;,

        &ldquo;name&rdquo;: &ldquo;receipt&rdquo;,

        &ldquo;direction&rdquo;: &ldquo;out&rdquo;,

        &ldquo;path&rdquo;: &ldquo;processed/{id}&rdquo;

      }

    ]

  }</pre>


  <p>基本的な考え方は、このメタデータを使用して、さまざまな言語と .NET Web ジョブ SDK ランタイムの間にメモリ内アダプターを生成できることです。 上に示した C# 関数を効果的に生成し、その関数のメソッド本体を実際のユーザー関数 (記述した Node.js 関数) に単純にデリゲートします。 その後、Azure 関数は単なる単純な関数です。関数のバインドを記述する json メタデータファイルと、関数を実装する1つ以上のスクリプトファイルのコレクションを示します。 ここ &rsquo; では、同じメタデータファイルを使用し、Windows BAT ファイルとして記述された関数と同じ例を示します。</p>


  <pre>

  SET /p order=&lt;%order%

  echo Processing order &lsquo;%order%&rsquo;

  echo &lsquo;&lt;some value&gt;&rsquo; &gt; %receipt%</pre>


  <p>この同じメタデータファイルを使用して、7つのサポートされている言語のいずれかで関数を記述できます。 もちろん、各言語には独自の特性と機能があり、さまざまなタスクのために他の言語よりも適しています。 ここでの主なポイントは、これらのすべての言語に対して同じトリガー/バインドランタイムを持つことができることです。これにより、各言語が独自の方法でモデルにマップできるようになります。 BAT ファイルは多少制限されていますが、環境変数とファイルストリームによって、入力を受信し、出力を書き込むことができます。これらの関数は、基になる Azure Storage アーティファクトに自動的にマップされます。</p>


  <p>コア Web ジョブ SDK 上でビルドを行う Azure Functions は、Web ジョブ SDK の異なるバージョンを作成して管理する必要があることを意味 &rsquo; しています。これは、大規模なエンジニアリングの勝者です。 すべてのバインド/トリガーロジックを処理するコアランタイムが1つあり、そのコア特典機能に加えて、すべての Web ジョブ SDK 顧客にも対応しています。 また、コア SDK 用に記述されたすべてのトリガー/バインド拡張機能を関数で使用することもできます。 &rsquo;従来のお客様と Azure Functions の両方について、コア WEB ジョブ SDK と拡張機能に多大な投資を続けています。</p>


  <h2>WebHook のサポート</h2>


  <p>注目すべきもう1つの重要な領域は、Webhook の話です。 Azure Storage イベントでトリガーされる関数の機能は非常に優れていますが &rsquo; 、WebHook 要求でもジョブの機能をトリガーできることをお客様に web ジョブています。 この昨年は、既に動作していた <a href="https://www.nuget.org/packages/Microsoft.Azure.WebJobs.Extensions.WebHooks/1.0.0-beta4">Webhook 拡張機能</a> を作成することによって、既に実験ていますが、Kudu SCM サイトで web ジョブを実行するという事実から大きな欠点がありました。これは、要求を行うために基本的な認証資格情報が必要であることを意味します。 &rsquo;これは、ほとんどの WebHook 統合シナリオで使用されます。これは、そのエンドポイントへのアクセスのみを許可するように制限された単純な認証コードで URL を渡すことができるようにするためです。</p>


  <p>これに対処するために、WebApp のルートで実行される <a href="https://github.com/projectkudu/kudu/wiki/Azure-Site-Extensions">サイト拡張機能</a> として Functions ランタイムをパッケージ化することにしました。 これは SCM エンドポイントの背後にないため、必要な認証パターンを実現できることを意味します。 これにより、WebHook 関数に対して認証された一連のエンドポイントを公開できるようになりました。 また、 <a href="https://github.com/aspnet/WebHooks">ASP.NET</a> webhook ライブラリをこのに統合することで、ライブラリでサポートされている多数の WebHook プロバイダーを利用できるようになりました。これにより、GitHub、余裕、DropBox、Instagram などのプロバイダーに対するファーストクラスのサポートが提供されます。</p>


  <p>この時点で、Web ジョブ SDK のトリガー/バインディングモデル (Node.js、C#、F #、Bash、BAT、Python、PHP) をサポートする柔軟な関数ランタイムが用意されています。これには、さまざまな WebHook 統合シナリオをサポートする HTTP head もありました。</p>


  <h2>動的コンピューティング</h2>


  <p>上記の実行時と並行して、サーバーレスコンピューティングとその領域で何をするかについても説明しました。 Web ジョブに対して実行していたこの作業は、非常に synergistic でした。 高スケールでサンドボックス環境でユーザーコードを実行できる、柔軟で多言語の関数ランタイムを開発しています。 ただし、従来の Web ジョブモデルでは、ユーザーは、Web ジョブが実行される WebApp ホストを作成して管理する必要があります。 ユーザーが関数自体 &rsquo; を記述するだけで済み、デプロイとスケールに関するすべての問題に対処する必要がある場合は、どうすればよいでしょうか。 &rsquo;基本的に、サービスとしての WEB ジョブ SDK があります。 Eureka!</p>


  <p>チームを作成して、プラン &ndash; &ldquo; の動的コンピューティング &ldquo; のその部分を調査します。 これは、ごく少数の人間から非常に大規模な2-3 チーム &ndash; に急速に成長してきたプロジェクトのポイントです。動的コンピューティングレイヤーは、負荷の増加に応じて自動的に機能を拡張し、縮小したときにスケールバックすることを担当しています。 エンドユーザーにとっては、このことについて心配する必要はなく、実際に使用したコンピューティング時間に対してのみ課金され &rsquo; ます。 プロジェクトの動的なコンピューティング領域は大きく、監視と診断、テレメトリなどの他のサービスの側面も含まれています。この領域には、今後、独自のブログ記事が掲載されています。</p>


  <h2>Functions ポータル</h2>


  <p>次に説明するのは、これらの機能を簡単に作成して管理できるポータルエクスペリエンスでした。 従来の Web ジョブ SDK モデルでは、すべてのプリコンパイル済みジョブ関数を含む .NET コンソールアプリケーション (JobHost) をコンパイルしてデプロイします。 Azure Functions は、デプロイモデルの方がはるかに簡単です。 Functions ランタイムは、非常に単純なファイルシステムレイアウトを持つように設計されています。 これにより、 <a href="https://github.com/projectkudu/kudu">Kudu</a> api を使用してこれらのファイルを操作するストレートポータル UI が容易になります。 単純なポータルエディターを使用して、これらのファイルを作成/編集したり、関数コンテナー (関数を実行している WebApp) にプッシュしたりすることができます。 また、単純なファイルシステムモデルを使用すると、 <a href="https://azure.microsoft.com/en-us/documentation/articles/resource-group-authoring-templates/">ARM テンプレート</a>を使用して Azure Functions をデプロイすることもできます。 これは実際には可能ですが、まだドキュメントには記載されていません。</p>


  <p>チームは、すぐにポータルを起動して実行することができました。私たちは、このポータルを使用して nascent 製品で遊ぶことができるようになりました。 ポータルが配置されているので、実際には、これらが一体になっているように感じています。 多くのユーザビリティに関する議論や改善が促進され、バグの解決を開始することができるようになりました。ポータルが開始されたときに、Functions ランタイムと同様に、チームは作業を開始しました。しかし、初期の作業によって、その範囲と計画が増加しています。 さらに多くの方にオンボード。 スクラム会議がまだ大きくなっています</p>


  <p><img src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/fd84af25-8228-4bc6-ba2c-fa7390d7e1a8.jpeg"></p>


  <h2>テンプレート</h2>


  <p>関数の単純なファイルシステムモデルでは、Functions ポータルで現在表示されているすばらしいテンプレートモデルを開発することもできました。 さまざまな言語 &ldquo; (QueueTrigger &ndash; ノード &rdquo; 、 &ldquo; GitHub WebHook C# &rdquo; など) の一般的なシナリオに対応した単純なメタデータ/スクリプトテンプレートを任さに開始しました。そのため、すぐに使用できる関数の簡単な &ldquo; レシピ &rdquo; や出発点を用意し、カスタマイズしてニーズに合わせて拡張することができます。 将来的には、コミュニティがエコシステムを推進するために、このようなテンプレートを作成することもできます。</p>


  <p><img src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/34d5fd41-4b4e-4ce6-9e34-7954efbd1ef4.png"></p>


  <h2>機能拡張</h2>


  <p>Azure Functions のビルドに関する発表に特に重点を置いたもう1つの領域は、Functions で利用できる新しい一連の Web ジョブ SDK 拡張機能です。 <a href="https://azure.microsoft.com/en-us/blog/extensible-triggers-and-binders-with-azure-webjobs-sdk-1-1-0-alpha1/">WEB ジョブ SDK 拡張</a>モデルが最後にリリースされ、新しいトリガー/バインドソースに対してプログラミングモデルが開かれました。 私たちのチームは、 <a href="https://github.com/Azure/azure-webjobs-sdk-extensions">WEB ジョブ SDK Exensions</a> リポジトリで、新しい便利な拡張機能 (例: Timertrigger、FileTrigger、sendgrid binding など) を使用してコミュニティに既にシードを行っています。 &rsquo;また、コミュニティメンバーが独自の拡張機能の作成を開始しました。 関数は SDK に基づいて構築されているため、これらのすべての拡張機能を Azure Functions にも使用できます。 私たちは多くの拡張機能を記述したいと思っていましたが、時間はありません &rsquo; でしたが、新しい大規模なチームでは、これらの活用の一部を開始するためのリソースを用意しました。過去2か月 &rsquo; に、EventHub、DocumentDb、notificationhub、MobileApps、ApiHub の各拡張機能が追加され、関数の最初のクラスになりました。 これは、 &ndash; さらに多くの拡張機能が計画されているので、コミュニティでもさらに多くのものを作成することを期待しています。 &rsquo;また、サードパーティが拡張機能を機能にオンボードできるようにするための簡単なモデルに取り組んでいます。 そのようなことをご期待ください。</p>


  <p>もう1つの優れた点は、中核となる <a href="https://github.com/Azure/azure-webjobs-sdk">WEB ジョブ sdk</a> と <a href="https://github.com/Azure/azure-webjobs-sdk-extensions">Web ジョブ sdk 拡張機能</a> リポジトリを使用した場合と同じように、作業を開始する前にすべてのオープンソースを実行したいということです。 Functions ランタイムを含む <a href="https://github.com/Azure/azure-webjobs-sdk-script">WEB ジョブ SDK スクリプト</a> を作成しました。 同様に、Functions ポータルもオープンソースであり、 <a href="https://github.com/projectkudu/AzureFunctionsPortal">AzureFunctionsPortal</a>です。</p>


  <p>これまでのすべての要素は、プロジェクトのさまざまな部分と、それらがどのように組み合わされたかについて、非常に高度な概要を示しました。 Functions ランタイム、Functions ポータル、動的コンピューティングです。 今後の投稿では、 &rsquo; これらのさまざまな分野の詳細について詳しく説明します。</p>
