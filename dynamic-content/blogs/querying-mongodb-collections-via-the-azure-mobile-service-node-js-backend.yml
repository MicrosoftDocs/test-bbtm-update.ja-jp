### YamlMime:Yaml
ms.openlocfilehash: 5fa031b24779642893374d60db5901793ce3a9c9
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139889060"
Slug: querying-mongodb-collections-via-the-azure-mobile-service-node-js-backend
Title: Azure Mobile Service node.js バックエンドを使用した MongoDB コレクションのクエリ
Summary: 前の記事では、Azure Mobile Services node.js バックエンドでテーブルを使用して、単純な CRUD 操作のために MongoDB コレクションと対話する方法を説明しました。 この記事では、テーブル読み取りスクリプトに渡されたすべての OData クエリパラメーターを取得する方法を提示して、Mongo データベースに対するより複雑な読み取り操作をサポートできるようにしました。
Content: "前の<a href=\"https://azure.microsoft.com/blog/2014/06/24/exposing-mongodb-collections-on-the-node-js-backend/\">記事</a>では、Azure Mobile Services テーブルを使用して、既定の SQL Azure ではなく、ストレージ層として mongo データベースを使用する方法について説明しました。 この記事では、作成、更新、削除、および単純な読み取り操作を実装する方法を説明しましたが、テーブルの読み取り操作によってコレクション内の項目のいずれかまたはすべてが返されているため、優れたクエリ機能がありませんでした。 この記事では、node.js ランタイムのドキュメントに記載されていない機能について説明します。ここでは、ユーザーが渡したクエリパラメーターを取得し、ページング、並べ替え、選択、およびフィルター処理のサポートを追加して、node.js モバイルサービスから MongoDB コレクションを完全に (またはほとんど) 使用できるようにします。\n<h2>クエリコンポーネント</h2>\nMongoDB コレクションにクエリを実行する node.js モバイルサービスを紹介している <a href=\"https://www.contentmaster.com/azure/using-windows-azure-mobile-services-with-a-mongodb-database/\">いくつ</a> かの投稿がありますが、クエリはカスタムクエリ文字列パラメーターを使用するか、コード自体にハードコーディングされています。 ただし、エクスペリエンスを向上させるには、クライアントアプリケーションのコードをより自然に記述できるように、クライアントが送信する <a href=\"https://www.odata.org/documentation/odata-version-2-0/uri-conventions\">OData クエリパラメーター</a> をランタイムが尊重するようにします。 つまり、クライアントは次のコードを記述できる必要があります。\n<pre class=\"prettyprint\">var table = client.GetTable&lt;Order&gt;();\nvar last10Orders = await table\n    .OrderByDescending(o =&gt; o.OrderDate)\n    .Take(10)\n    .ToListAsync();</pre>\nまた、Mongo コレクションにクエリを実行するときに、ランタイムはこれらのオプションを適用する必要があります。 上記のコードでは、HTTP 要求 <code>/tables/order?$top=10&amp;$orderby=OrderDate desc</code> で次のクエリ文字列を送信します。 問題は、読み取りスクリプトの<a href=\"https://msdn.microsoft.com/en-us/library/azure/jj554218.aspx\">要求オブジェクト</a>のプロパティによって <code>parameters</code> 、OData クエリパラメーター (' $ ' で始まるもの) が公開されていないことです。 ただし、読み取り操作でこれらのオブジェクトを取得する方法の1つとして、ドキュメント化されていない (このブログ投稿まで) を使用して、を公開 <code>getComponents</code> する<a href=\"https://msdn.microsoft.com/en-us/library/azure/jj613353.aspx\">クエリオブジェクト</a>の関数を取得する方法があります。 これを使用すると、skip/top (ページング)、順序付け、選択、フィルターなど、クライアントによって送信されたすべての OData パラメーターを取得できます。 クエリコンポーネントを出力するように読み取りスクリプトを変更してみましょう。\n<pre class=\"prettyprint\">function read(query, user, request) {\n    console.log(query.getComponents());\n    request.execute();\n}</pre>\nここで、上記の要求をサーバーに送信し、モバイルサービスのログを確認すると、クエリコンポーネントから取得できるすべての情報が表示されます。\n<pre class=\"prettyprint\">{ filters: null,\n  selections: [],\n  projection: null,\n  ordering: { OrderDate: false },\n  skip: null,\n  take: 10,\n  table: 'complexOrders',\n  context: undefined,\n  includeTotalCount: false,\n  version: 2 }</pre>\nコンポーネントには、スクリプトの OData クエリパラメーターを読み取るために必要なすべての情報が含まれています。 では、使用を開始しましょう。\n<h2>ページング (take/skip)</h2>\n前の投稿に戻り、Mongo コレクションから複数の項目を取得するときの結果を確認してみましょう。\n<pre class=\"prettyprint\">function returnMultipleObjects(collection, query, mongoHelper, request) {\n    // TODO: look at query parameters. For now, return all items.\n    collection.find().toArray(function(err, items) {\n        if (err) {\n            console.log('error querying collection: ', err);\n            request.respond(200, { error: err });\n        } else {\n            items.forEach(function(item) {\n                mongoHelper.mongoIdToMobileServiceId(item);\n            });\n            request.respond(200, items);\n        }\n    });\n}</pre>\nここでは、 <a href=\"https://mongodb.github.io/node-mongodb-native/api-generated/collection.html#find\">collection. find メソッド</a>を使用しています。また、と <code>skip</code> のクエリオプション <code>limit</code> については、それぞれと <code>$skip</code> OData パラメーターに <code>$top</code> 相当する追加のパラメーターを受け取ることができます。 これらのオプションを find メソッドに追加することができます。\n<pre class=\"prettyprint\">function returnMultipleObjects(collection, query, mongoHelper, request) {\n    var findOptions = {};\n\n    var queryComponents = query.getComponents();\n\n    applyTopAndSkip(findOptions, queryComponents);\n    applyOrdering(findOptions, queryComponents);\n    applySelect(findOptions, queryComponents);\n    var findQuery = getFilterQuery(queryComponents, request);\n    if (findQuery === null) {\n        // response already sent\n        return;\n    }\n\n    collection.find({}, findOptions).toArray(function(err, items) {\n        if (err) {\n            console.log('error querying collection: ', err);\n            request.respond(200, { error: err });\n        } else {\n            items.forEach(function(item) {\n                mongoHelper.mongoIdToMobileServiceId(item);\n            });\n            request.respond(200, items);\n        }\n    });\n\n    function applyTopAndSkip(findOptions, queryComponents) {\n        if (queryComponents.take) {\n            findOptions.limit = queryComponents.take;\n        }\n\n        if (queryComponents.skip) {\n            findOptions.skip = queryComponents.skip;\n        }\n    }\n\n    function applySelect(findOptions, queryComponents) { }\n    function applyOrdering(findOptions, queryComponents) { }\n    function applyFilter(queryComponents, request) { }\n    function getFilterQuery(queryComponents, request) { return {}; }\n}</pre>\nここで、に <code>/tables/order?$skip=3&amp;$top=5</code> 要求を送信した場合、5つのドキュメントのみを受信し、最初の3つ (既定のコレクションの順序) をスキップします。 メモ: 要求にクエリパラメーターが含まれ <code>$top</code> ていない場合、の <code>queryComponents.take</code> 値は0になりません (node.js ランタイムによって返される項目の既定の最大数である50の値)。したがって、[検索] オプションで制限を定義するときに、その値を確認しても安全です。\n<h2>順序</h2>\nページングの使用 (skip/take) は、ページングを実行する順序を定義できる場合により強力です。 たとえば、クライアント名または注文日によるページングなどです。 クエリコンポーネントの出力で見たように、順序はオブジェクトとして指定され、フィールドを表すキーと、要求された順序が昇順と降順のどちらであるかを表すブール値です。 次に、MongoDB ノードパッケージ (フィールド名/順序を持つ配列) で想定される形式でその形式を使用する必要があります。\n<pre class=\"prettyprint\">function applyOrdering(findOptions, queryComponents) {\n    var orderBy = [];\n    var ordering = queryComponents.ordering;\n    for (var orderField in ordering) {\n        if (ordering.hasOwnProperty(orderField)) {\n            var ascending = queryComponents.ordering[orderField] ? 'ascending' : 'descending';\n            orderBy.push([ orderField, ascending ]);\n        }\n    }\n\n    if (orderBy.length) {\n        findOptions.sort = orderBy;\n    }\n}</pre>\nこれで、この投稿 <code>/tables/order?$top=10&amp;orderby=orderDate desc</code> の冒頭に示したコードスニペットを実行できます。\n<h2>[選択]</h2>\nMongoDB ドキュメント (および一般にデータベースに格納されているエンティティ) には、必要なよりも多くの情報 (プロパティ/列) が含まれることが多く、すべてを取得することは不要なコスト (帯域幅と処理) になります。 OData と MongoDB では、取得するフィールドの選択がサポートされています。また、クエリコンポーネントを MongoDB ノードドライバーで想定される形式にマップすることもできます。\n<pre class=\"prettyprint\">function applySelect(findOptions, queryComponents) {\n    var selects = queryComponents.selections;\n    if (selects &amp;&amp; selects.length) {\n        if (selects.length === 1 &amp;&amp; selects[0] === '*') {\n            // Same as no $select, nothing to do\n        } else {\n            findOptions.fields = {};\n            selects.forEach(function(field) {\n                findOptions.fields[field] = 1;\n            });\n        }\n    }\n}</pre>\nここで、最後の10件の注文のクライアントの名前だけが必要な場合は、を <code>/tables/order?$top=10&amp;$orderby=orderDate desc&amp;$select=client</code> 実行できます。\n<h2>フィルター処理</h2>\n多くの場合、クライアントは、コレクションのすべての要素 (ページングされている場合でも) を要求するのではなく、特定の条件に一致する特定のドキュメントのみを要求します。 たとえば、文字 ' J ' で始まるクライアントの注文のみが必要です。\n<pre class=\"prettyprint\">var table = Client.GetTable&lt;Order&gt;();\nvar items = await table\n    .Where(o =&gt; o.Client.StartsWith(\"J\"))\n    .OrderByDescending(o =&gt; o.OrderDate)\n    .Take(10)\n    .ToListAsync();</pre>\n上記のフィルターは $filter OData クエリパラメーターとしてサーバー <code>/tables/order?$top=10&amp;$orderby=orderDate desc&amp;$filter=startswith(client,'J')</code> に送信されます。 クエリコンポーネントをログに記録すると、次に示すように、filters オブジェクトの ' queryString ' 値にフィルター式が表示されます。 フィルター (args、型) には他にもプロパティがありますが、このシナリオでは使用しません (OData とクエリ文字列を変換するコードは、サーバーランタイムと JavaScript クライアント SDK の間で共有されます。これらはクライアントでのみ使用されます)。\n<pre class=\"prettyprint\">{ filters: \n   { queryString: 'startswith(client,\\'J\\')',\n     args: [],\n     type: 'LiteralExpression' },\n  selections: [],\n  projection: null,\n  ordering: { orderDate: false },\n  skip: 0,\n  take: 10,\n  table: 'complexOrders',\n  context: undefined,\n  includeTotalCount: false,\n  version: 4 }</pre>\nフィルターを使用して、これらをコレクションに渡すことができるようになりました。 node.js MongoDB ライブラリの <a href=\"https://mongodb.github.io/node-mongodb-native/api-generated/collection.html#find\">find メソッド</a> 。 これは簡単なタスクではありませんが、フィルターは文字列として指定されているので、解析して、ノードドライバーで想定される適切な形式に変換します。 ここでは、いくつかの構成要素をサポートする方法を示します (単純な二項演算子では ' startswith ' 関数) が、完全な実装では、クエリ文字列を式ツリーに解析し、それを走査して同等の MongoDB クエリオブジェクトを作成する必要がありますが、この投稿の範囲を超えます (ほとんどの場合、クエリコンポーネントの機能\n<pre class=\"prettyprint\">function getFilterQuery(queryComponents, request) {\n    // Simple case: filter that excludes everything; no need to talk to the DB\n    if (queryComponents.filters &amp;&amp; queryComponents.filters.queryString === 'false') {\n        request.respond(200, []);\n        return null;\n    }\n\n    var findQuery = convertFilter(queryComponents.filters);\n    if (findQuery === null) {\n        request.respond(500, { error: 'Unsupported filter: ' + queryComponents.filters.queryString });\n        return null;\n    }\n\n    return findQuery;\n}\n\nfunction convertFilter(filters) {\n    var findQuery = {};\n\n    var startsWith = [ /^startswith\\(([^,]+),\\'([^\\']+)\\'\\)/, function(p) {\n        var field = p[1];\n        var value = p[2];\n        var result = {};\n        result[field] = new RegExp('^' + value);\n        return result;\n    } ];\n\n    var binaryOperator = [ /^\\(([^\\s]+)\\s+([^\\s]{2})\\s(.+)$/, function(p) {\n        var field = p[1];\n        var operator = p[2];\n        var value = p[3].slice(0, -1); // remove ending ')'\n        if (/datetime\\'\\d{4}-\\d{2}-\\d{2}T\\d{2}\\:\\d{2}\\:\\d{2}\\.\\d{3}Z\\'/.test(value)) {\n            // Date literal\n            value = new Date(Date.parse(value.slice(9, -1)));\n        } else if (/^\\'.+\\'$/.test(value)) {\n            // String literal\n            value = value.slice(1, -1);\n        } else {\n            // Number\n            value = parseFloat(value);\n        }\n\n        var result = {};\n        if (operator === 'eq') {\n            result[field] = value;\n        } else {\n            result[field] = {};\n            result[field]['$' + operator] = value;\n        }\n        return result;\n    } ];\n\n    var supportedFilters = [startsWith, binaryOperator];\n\n    if (filters) {\n        // Easy cases\n        if (filters.queryString === 'true') {\n            return {};\n        }\n\n        var foundMatch = false;\n        for (var i = 0; i &lt; supportedFilters.length; i++) {\n            var match = filters.queryString.match(supportedFilters[i][0]);\n            if (match) {\n                findQuery = supportedFilters[i][1](match);\n                foundMatch = true;\n                break;\n            }\n        }\n\n        if (!foundMatch) {\n            return null;\n        }\n    }\n\n    return findQuery;\n}</pre>\nまた、サポートされているすべての mobile services クライアント Sdk を使用して、MongoDB で非常に複雑なクエリを実行できるようになりました。\n<h2>まとめ</h2>\nこの記事では、 <a href=\"https://msdn.microsoft.com/en-us/library/azure/jj613353.aspx\">クエリオブジェクト</a> にドキュメント化されていない機能を示しました。これにより、読み取りスクリプトが OData クエリパラメーターにアクセスできるようになり、それを使用して MongoDB コレクションへの複雑なクエリを実行できます。 機能が改善される可能性があります (たとえば、フィルターのフィルター処理を変換するためのサポートが向上しています)。ただし、すべてのクライアントでサポートされている同じテーブルの抽象化を他のバックエンドストレージに拡張するために、この (および以前の) 投稿で使用したシナリオが有効になります。\n\nこの投稿の完全なコードを取得する場合は、 <a href=\"https://github.com/carlosfigueira/blogsamples/tree/master/AzureMobileServices/MongoDbOnNodeBackend/ComplexQueryTests/ComplexQueries\">ブログのサンプルリポジトリ</a>に掲載されています。 常に、この投稿のコメントセクションまたは <a href=\"https://social.msdn.microsoft.com/Forums/windowsazure/en-US/home?forum=azuremobile\">MSDN フォーラム</a>でコメント/提案を残しておきます。"
