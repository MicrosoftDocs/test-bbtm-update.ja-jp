### YamlMime:Yaml
ms.openlocfilehash: 4d39fee3612ae49ac50c078d1b5e242fb6fccf13
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139910891"
Slug: building-more-secure-middle-tier-applications-with-azure-sql-database-using-row-level-security
Title: セキュリティを使用したMiddle-TierアプリケーションのAzure SQL Database構築Row-Levelする
Summary: Row-Levelセキュリティを使用すると、開発者はデータベース テーブル内の行に対するきめ細かいアクセス制御を実装できます。
Content: "Row-Level セキュリティ (RLS) は、Azure SQL Database の新しいプログラミング機能で、最新バージョンの SQL Database (V12) のすべてのデータベースでプレビューで<a href=\"https://azure.microsoft.com/en-us/documentation/articles/sql-database-preview-whats-new/\"></a>使用できます。 Row-Levelセキュリティを使用すると、開発者はデータベース テーブル内の行に対するきめ細かいアクセス制御を実装できます。 これは、複数のユーザーが同じテーブルを共有する場合に承認されていないアクセスを防ぐのに役立ち、マルチテナント アプリケーションで接続フィルター処理を実装するのに役立ちます。 この投稿は、RLS を使用して、セキュリティで保護された多層アプリケーションとマルチテナント アプリケーションの構築をAzure SQL Databaseするのに役立ちます。\n\n顧客が売上を追跡するために使用する 3 層の e コマース SaaS ソリューションがあるとします。 お客様は、中層アプリケーションを介してしか販売データにアクセスできません。そのため、効率を高めるには、データ層にマルチテナント アーキテクチャを採用しています。 したがって、すべてのテナント (顧客) の売上データは、同じデータベースとテーブルに格納されます。\n\n<b>Dbo。販売</b>\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"0\">\n<tbody>\n<tr>\n<td valign=\"top\" width=\"96\">OrderId</td>\n<td valign=\"top\" width=\"96\">SKU</td>\n<td valign=\"top\" width=\"96\">Price</td>\n<td valign=\"top\" width=\"96\">TenantId</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\" valign=\"top\" width=\"96\">1</td>\n<td valign=\"top\" width=\"96\">Book001</td>\n<td valign=\"top\" width=\"96\">10</td>\n<td valign=\"top\" width=\"96\">1</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"96\">2</td>\n<td valign=\"top\" width=\"96\">Movie001</td>\n<td valign=\"top\" width=\"96\">15</td>\n<td valign=\"top\" width=\"96\">2</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"96\">3</td>\n<td valign=\"top\" width=\"96\">Movie002</td>\n<td valign=\"top\" width=\"96\">12</td>\n<td valign=\"top\" width=\"96\">2</td>\n</tr>\n</tbody>\n</table>\nテナントが自分の売上データのみを表示できる必要があります。 たとえば、アプリケーションがテナント 1 のログイン中にこのテーブルに対してクエリを実行するたび、\"WHERE TenantId = 1\" 述語を手動で追加できます。 ただし、このようなフィルター処理ロジックを使用してクエリをアプリケーションで書き換えすると、コードベースを変更するたびにエラーが発生しやすく、保守が困難になる可能性があります。 RLS を使用すると、データベース自体内のフィルター処理ロジックを一元化できます。これにより、アプリケーションの開発を続ける間、メンテナンスを簡素化し、エラーのリスクを軽減できます。\n<h2>手順 1: アプリケーション ユーザー コンテキストを次のコマンドで設定CONTEXT_INFO</h2>\nアプリケーションに変更を 1 回だけ行います。 アプリケーションは接続プールを使用し、すべてのアプリケーション ユーザーは同じデータベース ログインを共有します。そのため、RLS がフィルター処理する行を RLS が確認するには、現在ログインしているテナントをデータベースに伝える必要があります。これを行うには、CONTEXT_INFO V12 Update で接続スコープのグローバル変数にアクセスできるSQL Database使用します。<a href=\"https://msdn.microsoft.com/en-us/library/ms180125.aspx\"></a> 次SSMS SSDT で、アプリケーションが TenantId に CONTEXT_INFO を設定するために使用できるストアド プロシージャを T-SQL に作成します。\n<pre class=\"prettyprint\">CREATE PROCEDURE sp_setContextInfoAsTenantId(@TenantId int)\nAS\nSET CONTEXT_INFO @TenantId \nGO\n</pre>\n接続を開いてから、アプリケーションは、ログインしているユーザーの TenantId を使用して、このストアド プロシージャを実行します。\n<h2>手順 2: 述語関数でアクセス ロジックをエンコードする</h2>\n次に、行アクセス ロジック用のインライン テーブル値関数を作成します。 この述語関数は任意に複雑になる可能性がありますが (たとえば、他のテーブルとの結合や、階層型アクセス制御を適用するために複数のパラメーターをチェックする)、アプリケーションの場合は非常に単純です。 ベスト プラクティスとして、述語関数とセキュリティ ポリシーを別のスキーマに設定します。\n<pre class=\"prettyprint\">CREATE SCHEMA rls\nGO\n \nCREATE FUNCTION rls.fn_tenantAccessPredicate(@TenantId int)\nRETURNS TABLE\nWITH SCHEMABINDING\nAS\nRETURN SELECT 1 AS fn_accessResult \nWHERE DATABASE_PRINCIPAL_ID() = DATABASE_PRINCIPAL_ID('AppUser') -- the shared application login\nAND CONVERT(int, CONVERT(varbinary(4), CONTEXT_INFO())) = @TenantId\nGO\n</pre>\nユーザーが Sales テーブルにクエリを実行すると、この関数がすべての行に適用され、TenantId が現在の CONTEXT_INFO の値と一致しない行がフィルター処理されます (または、アプリケーション以外の SQL ログインが何らかの方法でデータベースに直接接続されている場合)。 クエリ オプティマイザーでは、この関数は、Sales テーブルのすべての SELECT、UPDATE、DELETE クエリに上記の WHERE 述語を追加するのと同等として適用されます。\n<h2>手順 3: セキュリティ ポリシーを使用して関数をテーブルにバインドする</h2>\n最後に、この関数を Sales テーブルのフィルター述語としてバインドするセキュリティ ポリシーを作成します。\n<pre class=\"prettyprint\">CREATE SECURITY POLICY rls.tenantAccessPolicy\nADD FILTER PREDICATE rls.fn_tenantAccessPredicate(TenantId) ON dbo.Sales\nGO\n</pre>\nこれで完了です。 現在の値に基づいて、Sales テーブルのクエリから行が自動的にフィルター処理CONTEXT_INFO。 これを確認するには、ストアド プロシージャを使用してCONTEXT_INFO設定をシミュレートします。\n<pre class=\"prettyprint\">EXECUTE sp_setContextInfoAsTenantId 1\nGO\nSELECT * FROM Sales\nGO\n</pre>\nテナント 1 の行だけが返されます (この場合は Book001 のみ)。\n<h2>ベスト プラクティスと次の手順</h2>\nCONTEXT_INFO を使用してアプリケーション ユーザー コンテキストをデータベースに渡す場合、アプリケーション ユーザーは任意の T-SQL (たとえば、SQL インジェクション) を実行して CONTEXT_INFO の値を変更したり、他のテナントに属する行を挿入したりできないことを前提とします。 挿入をブロックするための組み込みのサポートは、このバージョンの RLS には含まれていませんが、トリガーまたはチェック制約 (将来のブログトピックで説明します) を使用するか、ストアド プロシージャを使用して挿入を制御することで、同等の機能を実現できます。\n\nまた、述語関数は必要に応じて複雑になる可能性があります。ただし、関数内に複数のテーブル結合を含め、クエリのパフォーマンスが低下します。\n\nそれでは、次は何でしょうか。 RLS の詳細については、オンライン プレビューの <a href=\"https://msdn.microsoft.com/library/dn765131.aspx\">ドキュメントを参照してください</a>。 それ以外の場合は、以下の質問とコメントを投稿してください。この機能を反復処理して進めたいと思うフィードバックをお待ちしております。\n\n<b>完全なデモ スクリプト</b>: RLS-Middle-Tier-Apps-Demo.sql については、こちらを参照 <a href=\"https://rlssamples.codeplex.com/SourceControl/latest#RLS-Middle-Tier-Apps-Demo.sql\">してください</a><b>。</b>"
