### YamlMime:Yaml
ms.openlocfilehash: b0f452294ebd57fd5334f2c5ff9ad2b4c8735a7c
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139903640"
Slug: calculating-billable-gigabytes-for-media-encoding-jobs
Title: メディアエンコードジョブの課金対象ギガバイト数の計算
Summary: この記事では、ジョブとタスクレベルで課金対象ギガバイトの内訳を生成するために使用するサンプルコードを提供する方法について説明します。
Content: "Media Services では、Azure Media Encoder メディアプロセッサを使用するタスクを使用してジョブを送信すると、処理されたデータ量に基づいて課金されます。 Azure 課金ポータルでは、請求期間にわたってギガバイトの集計値が提供されますが、ジョブまたはタスクレベルでの料金の内訳は提供されません。 このブログでは、課金対象のギガバイトの内訳をジョブとタスクレベルで生成するために使用できるサンプルコードをいくつか紹介します。 また、このブログでは、Excel Power Query を使用して、サンプルコードによって生成されたデータを分析する方法についても説明します。\n<h2>Storage のメディアアセット</h2>\nメディア資産を<a href=\"https://msdn.microsoft.com/en-us/library/hh974277.aspx#create_an_asset\">作成</a>すると、Media Services によって guid が生成され、その guid を使用してメディアアセット Id が作成されます。メディアアセット Id の先頭には \"nb: cid: UUID:\" が付けられ、その後に GUID が続きます。 つまり、メディア資産 Id は \"nb: cid: UUID: &lt; GUID &gt; \" の形式になります。 Media Services も、\"asset- &lt; \" という名前のコンテナーを作成します。GUID &gt; \"が指定された Storage アカウントにあります。 アセットが作成されたら、ストレージコンテナー内のアセットファイルをアップロードできます。 エンコードタスクを使用してジョブを送信すると、エンコーダーからの出力ファイルは、出力資産に関連付けられている Storage コンテナーに配置されます。\n<h2>サンプル コード</h2>\n上記のように、提供されているサンプルコードの動作を次に示します。\n<ul>\n <li>このコードは、特定の Media Services アカウントのすべてのジョブを列挙します。</li>\n <li>各ジョブについて、すべてのタスクが列挙されます。</li>\n <li>タスクが完了すると、すべての入力および出力アセットが列挙されます。</li>\n <li>入力資産と出力資産ごとに、アセットに関連付けられているストレージコンテナー内のすべての blob が列挙され、資産の各 blob のサイズが計算されて、資産のサイズが計算されます。</li>\n <li>次に、このコードでは、 <strong>Jobandtasktableentity</strong> という名前の Azure Table エンティティをパーティション <strong>キーとして、</strong> <strong>TaskId</strong> を行キーとして作成します。\n<ul>\n <li><strong>Jobandtasktableentity</strong>の他のメンバー (StartTime、EndTime、Mediaprocessor、Runningduration、InputAssetSize、OutputAssetSize など) も設定されます。</li>\n</ul>\n</li>\n <li>次に、このコードは<strong>Jobandtasktableentity</strong>を<strong>Jobandtaskmetadata</strong>という名前の Azure テーブルに書き込みます。</li>\n</ul>\n&nbsp;\n\nサンプルコードの App.Config ファイルは次のようになります。\n<pre class=\"prettyprint\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;configuration&gt;\n  &lt;startup&gt;\n    &lt;supportedRuntime version=\"v4.0\" sku=\".NETFramework,Version=v4.5\" /&gt;\n  &lt;/startup&gt;\n  &lt;appSettings&gt;\n    &lt;add key=\"MediaServicesAccountName\" value=\"&lt;MediaAccountName&gt;\" /&gt;\n    &lt;add key=\"MediaServicesAccountKey\" value=\"&lt;MediaAccountKey&gt;\" /&gt;\n    &lt;add key=\"StorageConnectionString\" value=\"DefaultEndpointsProtocol=https;AccountName=&lt;StorageAccountName&gt;;AccountKey=&lt;StorageAccountKey&gt;\"/&gt;\n  &lt;/appSettings&gt;\n  &lt;runtime&gt;\n    &lt;assemblyBinding xmlns=\"urn:schemas-microsoft-com:asm.v1\"&gt;\n      &lt;dependentAssembly&gt;\n        &lt;assemblyIdentity name=\"Microsoft.WindowsAzure.Storage\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" /&gt;\n        &lt;bindingRedirect oldVersion=\"0.0.0.0-4.1.0.0\" newVersion=\"4.1.0.0\" /&gt;\n      &lt;/dependentAssembly&gt;\n    &lt;/assemblyBinding&gt;\n  &lt;/runtime&gt;\n&lt;/configuration&gt;</pre>\n上記の App.Config で、mediaaccountname &gt; と &lt; MediaAccountKey &gt; を Media Services のアカウント名とキーに置き換え &lt; ます。 また、storageaccountname &gt; と &lt; StorageAccountKey &gt; を、Media Services アカウントに関連付けられているストレージアカウントの名前とキーに置き換え &lt; ます。\n\nサンプルコードは次のとおりです。\n<pre class=\"prettyprint\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure;\nusing Microsoft.WindowsAzure.Storage;\nusing Microsoft.WindowsAzure.Storage.Blob;\nusing Microsoft.WindowsAzure.Storage.Table;\nusing Microsoft.WindowsAzure.MediaServices.Client;\nusing System.Configuration;\n\nnamespace JobAndTaskBilling\n{\n    /// &lt;summary&gt;\n    /// \n    /// &lt;/summary&gt;\n    public class JobAndTaskTableEntity : TableEntity\n    {\n        public DateTime StartTime { get; set; }\n        public DateTime EndTime { get; set; }\n        public string MediaProcessor { get; set; }\n        public TimeSpan RunningDuration { get; set; }\n        public Double InputAssetSize { get; set; }\n        public Double OutputAssetSize { get; set; }\n    }\n\n    /// &lt;summary&gt;\n    /// \n    /// &lt;/summary&gt;\n    class Program\n    {\n        // Read values from the App.config file.\n        private static readonly string _mediaServicesAccountName =\n            ConfigurationManager.AppSettings[\"MediaServicesAccountName\"];\n        private static readonly string _mediaServicesAccountKey =\n            ConfigurationManager.AppSettings[\"MediaServicesAccountKey\"];\n        private static readonly string _storageConnectionString =\n            ConfigurationManager.AppSettings[\"StorageConnectionString\"];\n\n        // \n        private static CloudStorageAccount _cloudStorage = null;\n        private static CloudBlobClient _blobClient = null;\n\n        private static CloudTableClient _tableClient = null;\n        private static CloudTable _taskTable = null;         \n\n        private static CloudMediaContext _context = null;\n        private static MediaServicesCredentials _cachedCredentials = null;\n\n        static void Main(string[] args)\n        {\n            try\n            {\n                // Create and cache the Media Services credentials in a static class variable.\n                _cachedCredentials = new MediaServicesCredentials(_mediaServicesAccountName, _mediaServicesAccountKey);\n\n                // Used the chached credentials to create CloudMediaContext.\n                _context = new CloudMediaContext(_cachedCredentials);\n\n                // Use the Storage Connection String from App.Config to create a CloudStorageAccount instance\n                _cloudStorage = CloudStorageAccount.Parse(_storageConnectionString);\n\n                _blobClient = _cloudStorage.CreateCloudBlobClient();   // Create the CloudBlobClient instance to perform Blob operations\n                _tableClient = _cloudStorage.CreateCloudTableClient(); // Create the CloudTableClient instance to perform Table operations\n\n                _taskTable = _tableClient.GetTableReference(\"JobAndTaskMetadata\"); \n                _taskTable.CreateIfNotExists();  // Create the Table if it doesn't exist\n\n                ProcessJobs();\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// This function loops through all jobs in a Media Services account \n        /// &lt;/summary&gt;\n        static void ProcessJobs()\n        {\n            try\n            {\n                Dictionary&lt;string, string&gt; _dictMPs = GetMediaProcessors();\n\n                int skipSize = 0;\n                int batchSize = 1000;\n                int currentBatch = 0;                \n\n                while (true)\n                {\n                    // Loop through all Jobs (1000 at a time) in the Media Services account\n                    IQueryable _jobsCollectionQuery = _context.Jobs.Skip(skipSize).Take(batchSize);\n                    foreach (IJob job in _jobsCollectionQuery)\n                    {\n                        currentBatch++;\n                        Console.WriteLine(\"Processing Job Id:\" + job.Id);\n\n                        ProcessTasks(job, _dictMPs);\n                    }\n\n                    if (currentBatch == batchSize)\n                    {\n                        skipSize += batchSize;\n                        currentBatch = 0;\n                    }\n                    else\n                    {\n                        break;\n                    }                    \n                }\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Enumerates all the Media Processors available in the Media Services accounts and creates a dictionary with MediaProcessorId as key and MediaProcessorName as value\n        /// &lt;/summary&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        static Dictionary&lt;string, string&gt; GetMediaProcessors()\n        {\n            Dictionary&lt;string, string&gt; _dictMPs = new Dictionary&lt;string, string&gt;();\n            foreach (IMediaProcessor mp in _context.MediaProcessors)\n            {\n                _dictMPs.Add(mp.Id, mp.Name);                \n            }\n\n            return _dictMPs;\n        }\n\n        /// &lt;summary&gt;\n        /// This function looks through all the tasks associated with a job\n        /// For all finished tasks, it calculates the input and output asset size and writes an entity to the JobsAndTasksMetadata table\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"job\"&gt;&lt;/param&gt;\n        static void ProcessTasks(IJob job, Dictionary&lt;string, string&gt; _dictMPs)\n        {\n            try\n            {\n                foreach (ITask task in job.Tasks)\n                {\n                    Console.WriteLine(\"Processing Task Id:\" + task.Id);\n\n                    // Loop through the HistoricalEvents associated with the Task to find Tasks that have Finished\n                    // Task.State only has the Conpleted State and based on that it is not possible to know whether the task had an error or did it finish successfully\n                    for (int i = 0; i &lt; task.HistoricalEvents.Count; i++)\n                    {\n                        if (task.HistoricalEvents[i].Code == \"Finished\")\n                        {\n                            try\n                            {\n                                JobAndTaskTableEntity tme = new JobAndTaskTableEntity();\n                                tme.PartitionKey = job.Id;\n                                tme.RowKey = task.Id;\n                                tme.StartTime = Convert.ToDateTime(task.StartTime);\n                                tme.EndTime = Convert.ToDateTime(task.EndTime);\n                                tme.MediaProcessor = _dictMPs[task.MediaProcessorId]; // Use the MediaProcessor dictionary to figure out the MediaProcessorName\n                                tme.RunningDuration = task.RunningDuration;\n                                tme.InputAssetSize = 0;\n                                tme.OutputAssetSize = 0;\n\n                                for (int j = 0; j &lt; task.InputAssets.Count; j++)\n                                {\n                                    tme.InputAssetSize += GetAssetSize(task.InputAssets[j]);\n                                }\n\n                                for (int k = 0; k &lt; task.OutputAssets.Count; k++)\n                                {\n                                    tme.OutputAssetSize += GetAssetSize(task.OutputAssets[k]);\n                                }\n\n                                TableOperation op = TableOperation.Insert(tme);\n                                _taskTable.Execute(op);\n                            }\n                            catch (Exception x)\n                            {\n                                Console.WriteLine(x.Message);\n                            }\n                        }\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Gets the size of an Asset by eumerating all the blobs in the asset container and adding the size of each blob\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"_asset\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        static double GetAssetSize(IAsset _asset)\n        {\n            double _assetSize = 0;\n\n            try\n            {\n                // The asset container has \"asset-\" prefixed to the Asset GUID and the Asset Id has \"nb:cid:UUID:\" prefixed to the Asset GUID\n                foreach (CloudBlockBlob _blobItem in _blobClient.ListBlobs(\"asset-\" + _asset.Id.Replace(\"nb:cid:UUID:\", \"\") + \"/\", true))\n                {\n                    _assetSize += _blobItem.Properties.Length;\n                }\n            }\n            catch (Exception ex)\n            {\n                // If the Asset is not found in storage a value of zero will be returned for the Asset Size\n                // This can happen if the Asset was deleted after the Task finished but before this sample code was run\n                Console.WriteLine(ex.Message);\n            }\n\n            return _assetSize;\n        }        \n\n    }\n}</pre>\n上記のコードの関数の簡単な説明を次に示します。\n\n<strong>ProcessJobs</strong>\n\nこの関数は、指定された Media Services アカウント内のすべてのジョブをループします。 Media Services は、Jobs コレクションの 1000 個のジョブを返します。 この関数は、Skip と Take を使用してすべてのジョブが確実に列挙されるようにします (アカウントに 1,000 個を超えるジョブがある場合)。\n\n<strong>GetMediaProcessors</strong>\n\nこの関数は、指定された Media Services アカウントで使用可能なすべてのメディアプロセッサをループし、キーとして mediaprocesssorid、値として mediaprocessorname を持つディクショナリを作成します。 このディクショナリは、 <strong>Jobandtaskmetadata </strong>テーブルのエンティティを作成するときに使用されます。\n\n<strong>ProcessTasks</strong>\n\nこの関数は、特定のジョブに関連付けられているすべてのタスクをループ処理します。 次に、タスクに関連付けられているすべての履歴イベントをループして、タスクが実際に正常に完了したかどうかを確認します。 これは、エラーが発生したタスク (これらのタスクが課金されないため) のエントリのログを記録しないようにするためです。 完了したタスクの場合、関数は入力と出力のアセットサイズも取得し、 <strong>Jobandtaskmetadata</strong> テーブルのエンティティを作成します。\n\n<strong>GetAssetSize</strong>\n\nこの関数は、ストレージアカウント内の asset コンテナー内のすべての blob をループすることで、資産サイズをバイト単位で計算します。\n<h2>Excel Power Query を使用したデータの分析</h2>\n上記のサンプルコードの実行が完了すると、 <strong>Jobandtaskmetadata</strong> という名前の Azure テーブルと、完了したタスクに関するデータが表示されます。 <a href=\"https://office.microsoft.com/en-us/excel-help/introduction-to-microsoft-power-query-for-excel-HA104003940.aspx?CTT=5&amp;origin=HA104003813\">Excel Power Query</a>を使用して、分析用に Excel にそのデータをインポートできます。 Power Query Excel 使用したことがない場合は、「<a href=\"https://office.microsoft.com/en-us/excel/download-microsoft-power-query-for-excel-FX104018616.aspx\">ダウンロード Microsoft Power Query for Excel</a>」 web ページからダウンロードできます。 インストールが完了すると Excel が開始され、\"POWER QUERY\" という名前のタブが表示されます。 そのタブをクリックし、[その他のソースから] をクリックすると、次のスクリーンショットに示すように、\"from Windows Azure Table Storage\" という名前のメニュー項目が表示されます。\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/07/2014-07-06_00h21_51.png\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"2014-07-06_00h21_51\" alt=\"2014-07-06_00h21_51\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2014-07-06_00h21_51_thumb.png\" width=\"1028\" height=\"540\" border=\"0\" /></a>\n\nそのメニュー項目を選択すると、次のようなダイアログが表示されます。\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/07/2014-07-06_00h28_02.png\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"2014-07-06_00h28_02\" alt=\"2014-07-06_00h28_02\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2014-07-06_00h28_02_thumb.png\" width=\"644\" height=\"234\" border=\"0\" /></a>\n\nStorage アカウント名を入力すると、次のダイアログが表示されます\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/07/2014-07-06_00h29_50.png\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"2014-07-06_00h29_50\" alt=\"2014-07-06_00h29_50\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2014-07-06_00h29_50_thumb.png\" width=\"644\" height=\"279\" border=\"0\" /></a>\n\nアカウントキーを入力し、[保存] をクリックします。 右側に \"Navigator\" というウィンドウが表示されます。 ストレージアカウント内のすべてのテーブルが一覧表示されます。 <strong>Jobandtaskmetadata</strong>テーブルをダブルクリックすると、新しいウィンドウが開きます。 そのウィンドウのスクリーンショットは次のようになります。\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/07/2014-07-06_21h19_26.png\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"2014-07-06_21h19_26\" alt=\"2014-07-06_21h19_26\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2014-07-06_21h19_26_thumb.png\" width=\"1028\" height=\"552\" border=\"0\" /></a>\n\n\"Content\" というラベルが付いた列の横にあるボタンをクリックすると、次のようなポップアップが表示されます。\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/07/2014-07-06_21h22_17.png\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"2014-07-06_21h22_17\" alt=\"2014-07-06_21h22_17\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2014-07-06_21h22_17_thumb.png\" width=\"644\" height=\"272\" border=\"0\" /></a>\n\n[OK] をクリックすると、すべての列が読み込まれるようになります。 上部にある [閉じるの適用 &amp; ] ボタンをクリックすると、データ全体がワークシートに読み込まれます。\n\nこれで、\"課金対象ギガバイト\" という名前の列を追加し、InputAssetSize と OutputAssetSize を追加する数式を追加して、合計を 1024 * 1024 * 1024 (資産のサイズがバイト単位であるため) で除算できるようになりました。 \"Windows Azure Media Encoder\" メディアプロセッサを使用して送信されたタスクの請求のみが Media Services ため、残りの行をフィルターで除外することができます。\n<h2>考慮事項</h2>\n最後に、アプリケーションに対してこのサンプルコードを使用する場合は、次の点に注意してください。\n<ul>\n <li>Media Services アカウントには、ジョブ、資産、およびタスクの最大数が制限されています。 これらについては、MSDN ページの「<a href=\"https://msdn.microsoft.com/en-us/library/jj945161.aspx\">クォータと制限事項</a>」に記載されています。 上記のサンプルコードは、指定された Media Services アカウントから削除された資産、ジョブ、またはタスクがないことに依存していますが、アプリケーションが多数のジョブを送信した場合、維持するのが困難な場合があります。 このような場合は、ジョブや資産を削除する前に、上記のコードの <strong>ProcessTasks</strong> 関数を使用することを検討してください。</li>\n <li>ジョブの完了後にアプリケーションがアセットコンテナーからメディア blob を追加または削除した場合、課金対象のギガバイト数は不正確になります。 これを回避するには、指定されたジョブの完了後すぐに <strong>ProcessTasks </strong>関数を実行することをお勧めします。 \"<a href=\"https://msdn.microsoft.com/en-us/library/dn261241.aspx\">ジョブ通知</a>\" を使用する場合は、ジョブの \"完了\" メッセージを受信したときに <strong>ProcessTasks</strong> 関数を呼び出すことができます。</li>\n <li>このブログに記載されているサンプルコードは、すべての資産を1つのストレージアカウントに持つ Media Services アカウントで動作するように設計されていますが、複数のストレージアカウントで動作するように簡単に適応できます。</li>\n <li>上記のコードでは、InputAssetSize と OutputAssetSize をバイト単位で書き込みます。 サイズをギガバイト単位で書き込むようにコードを変更できます。また、 <strong>Jobandtaskmetadata</strong> テーブルに別の列を追加して、InputAssetSize と OutputAssetSize の合計を書き込むこともできます。</li>\n <li>テーブルをサポートする既存の<a href=\"https://blogs.msdn.com/b/windowsazurestorage/archive/2014/03/11/windows-azure-storage-explorers-2014.aspx\">Azure Storage Explorer</a>アプリケーションの1つを使用して、 <strong>jobandtaskmetadata</strong>テーブルのデータを表示できます。また、Excel を使用することもできますが Excel には、テーブル内のデータをさらに分析するために使用できるピボットテーブルなどの強力なデータ操作機能が用意されています。</li>\n <li>毎月の Azure の請求書は、お客様のアカウントに適用される請求日および割引 (ボリュームとコミットメント) の機能です。 月単位の Azure の請求書を使用して上記のコードを実行し、取得した結果を比較しようとしている場合は、を考慮してください。</li>\n <li>上記のコードの副次的な利点は、ワークシートに読み込まれたデータを使用して、他のメディアプロセッサで処理されているバイト数を確認できることです。</li>\n</ul>"
