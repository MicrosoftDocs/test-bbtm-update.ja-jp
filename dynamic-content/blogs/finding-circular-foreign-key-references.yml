### YamlMime:Yaml
ms.openlocfilehash: a792914ac388fada6c52b4dadb61211b1e2c7a83
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139895544"
Slug: finding-circular-foreign-key-references
Title: 循環外部キー参照の検索
Summary: '[この記事は、チームによってSQL Azureされました。]リレーショナル データベースの世界では、循環参照は、テーブルに関連する外部キーがループを作成するスキーマ構造です。 円形。。。'
Content: "<p>[この記事は、チームによってSQL Azureされました。]</p><p>リレーショナル データベースの世界では、循環参照は、テーブルに関連する外部キーがループを作成するスキーマ構造です。 外部キーが適用されている 2 つのリレーショナル データベースを同期しようとするときに、循環参照によって特殊な種類の問題が発生します。 この問題により、循環参照を含むデータベース スキーマは、データベースを同期およびレプリケートするときに使用できるツールで制限されます。 この記事では、循環参照について説明し、データベースに循環参照SQLする Transact-SQL スクリプトを示します。</p>  <h2>循環参照とは</h2>  <p>外部キーは、データベースによって適用される整合性制約を作成します。 これらの制約により、別のテーブルがデータを参照する前に、1 つのテーブルにデータ行が確実に存在します。 また、別の行が参照する依存行が削除されるのを防ぐ場合もあります。 図 1 では、Adventure Works データベースの <b>Address</b> テーブルと <b>StateProvince</b> テーブルの間に単純な外部キーが表示されています。</p>  <p><b>図 1</b></p>  <p><a href=\"\"><img style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"clip_image001[4]\" border=\"0\" alt=\"clip_image001[4]\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/1780.clip_5F00_image0014_5F00_thumb_5F00_193FA7C2.png\" width=\"527\" height=\"248\"></a></p>  <p>循環参照は、外部キーがループを作成する 1 つ以上のテーブルです。 図 2 は例です。</p>  <p><b>図 2</b></p>  <p><a href=\"\"><img style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"clip_image002[4]\" border=\"0\" alt=\"clip_image002[4]\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/1777.clip_5F00_image0024_5F00_thumb_5F00_51EA51CF.png\" width=\"212\" height=\"173\"></a></p>  <p>この場合、 <b>City テーブル</b> には作成者への参照が含まれている。都市の説明を書いたのは作成者です。 作成者 <b>テーブル</b> には、各作成者が都市に住んでいるため、都市への参照があります。 では、都市と作成者のどちらが最初に来たのでしょうか。 循環参照を使用する場合、外部キー列の 1 つが null 値を受け入れる必要があります。 これにより、データを 3 つのパスに挿入できます。</p>  <ol>   <li>キーが null に設定された null 許容外部キーによって参照されるテーブルへの挿入。</li>    <li>null 以外の外部キーを持つテーブルへの挿入。</li>    <li>手順 2. で挿入した行を参照するために null 許容外部キーを変更する更新。</li> </ol>  <p>循環参照は 2 つのテーブルに限定されるのではなく、多くのテーブルが含まれる場合があり、すべてが 1 つの大きな円にまとめられています。</p>  <h3>Self-Referencingテーブル</h3>  <p>特殊なケース循環参照は、自己参照テーブルです。 これは、独自の主キーを参照する外部キー列を持つテーブルです。 たとえば、従業員とその上司を追跡する人事スキーマがあります。 従業員テーブルには、employee テーブルの主キー列を参照する、\"上司\" という外部キー列があります。 自己参照テーブルには常に、null 許容の外部キー列が存在し、少なくとも 1 つの null が存在します。 上の例では、上司の列が null で、CEO になります。</p>  <h2>循環参照を使用したスキーマの同期</h2>  <p>循環参照に関係しないテーブルは簡単に同期できます。テーブルに依存せずにテーブルを完全に更新してから、外部キーに依存してテーブルを更新します。 図 1 では、 <b>StateProvince テーブル、</b> 次に Address テーブルを <b>更新</b> します。 この説明は簡略化されています。たとえば、削除は逆の順序で行われます。 テーブルに循環参照がない場合は、依存関係の順序がわかっている場合は、テーブル別にテーブルを同期できます。</p>  <p>循環参照を使用したテーブルの同期は非常に困難です。テーブルを行で更新し、テーブル間を移動し、null 許容外部キーを最初に null で挿入してから、後で更新する必要があります。 ここでも、これは簡単な説明です。ポイントは、循環参照がある場合、テーブルをシリアル順に更新できない点です。</p>  <p>循環参照を持つテーブルを含むデータベースを同期する方法は、実際には 2 つのみです。</p>  <ul>   <li>SQL Server レプリケーションと同様に、トランザクション ベースのレプリケーションを実行します。このレプリケーションでは、ソース データベースでデータが変更されたのと同じシリアル順序でデータを更新、挿入、削除します。</li>    <li>データベースを読み取り専用モードに設定し、check 制約を適用せずに、同じ主キーを持つコピー先データベースに行を一括コピーします。 すべてのテーブルを移動すると、ソース データベースを読み取り専用モードから取り出す可能性があります。 bcp ユーティリティでこれを行う方法については、こちらを参照してください。 </li>    <li>依存関係に基づいて行を挿入、更新、削除する順序を指定し、コピー先データベースで再作成します。 これは、データの更新、挿入、削除にかかったトランザクションを下位エンジニアリングする場合と同等です。</li> </ul>  <h2>循環参照の検出</h2>  <p>次の Transact-SQLスクリプトでは、再帰カーソルを使用して、データベース スキーマに循環参照が含まれる場合に検出します。 SQL Azure と同期する前に SQL Server データベースで実行するか、SQL Azure データベースで実行できます。 このファイルは、SQL Server Management Studio のクエリ ウィンドウで実行できます。出力は[メッセージ] セクションに と表示されます。</p>  <p>循環参照がある場合、出力は次のように表示されます。</p>  <pre class=\"csharpcode\">dbo.City -<span class=\"kwrd\">&gt;</span> dbo.Author -<span class=\"kwrd\">&gt;</span> dbo.City  dbo.Division -<span class=\"kwrd\">&gt;</span> dbo.Author -<span class=\"kwrd\">&gt;</span> dbo.City -<span class=\"kwrd\">&gt;</span> dbo.County -<span class=\"kwrd\">&gt;</span> dbo.Region -<span class=\"kwrd\">&gt;</span> dbo.Image -<span class=\"kwrd\">&gt;</span> dbo.Division  dbo.State -<span class=\"kwrd\">&gt;</span> dbo.Image -<span class=\"kwrd\">&gt;</span> dbo.Area -<span class=\"kwrd\">&gt;</span> dbo.Author -<span class=\"kwrd\">&gt;</span> dbo.City -<span class=\"kwrd\">&gt;</span> dbo.County -<span class=\"kwrd\">&gt;</span> dbo.Region -<span class=\"kwrd\">&gt;</span> dbo.State  dbo.County -<span class=\"kwrd\">&gt;</span> dbo.Region -<span class=\"kwrd\">&gt;</span> dbo.Author -<span class=\"kwrd\">&gt;</span> dbo.City -<span class=\"kwrd\">&gt;</span> dbo.County  dbo.Image -<span class=\"kwrd\">&gt;</span> dbo.Area -<span class=\"kwrd\">&gt;</span> dbo.Author -<span class=\"kwrd\">&gt;</span> dbo.City -<span class=\"kwrd\">&gt;</span> dbo.County -<span class=\"kwrd\">&gt;</span> dbo.Region -<span class=\"kwrd\">&gt;</span> dbo.Image  dbo.Location -<span class=\"kwrd\">&gt;</span> dbo.Author -<span class=\"kwrd\">&gt;</span> dbo.City -<span class=\"kwrd\">&gt;</span> dbo.County -<span class=\"kwrd\">&gt;</span> dbo.Region -<span class=\"kwrd\">&gt;</span> dbo.Image -<span class=\"kwrd\">&gt;</span> dbo.Location  dbo.LGroup -<span class=\"kwrd\">&gt;</span> dbo.LGroup  dbo.Region -<span class=\"kwrd\">&gt;</span> dbo.Author -<span class=\"kwrd\">&gt;</span> dbo.City -<span class=\"kwrd\">&gt;</span> dbo.County -<span class=\"kwrd\">&gt;</span> dbo.Region  dbo.Author -<span class=\"kwrd\">&gt;</span> dbo.City -<span class=\"kwrd\">&gt;</span> dbo.Author  dbo.Area -<span class=\"kwrd\">&gt;</span> dbo.Author -<span class=\"kwrd\">&gt;</span> dbo.City -<span class=\"kwrd\">&gt;</span> dbo.County -<span class=\"kwrd\">&gt;</span> dbo.Region -<span class=\"kwrd\">&gt;</span> dbo.Image -<span class=\"kwrd\">&gt;</span> dbo.Area</pre>      <p>各行は循環参照であり、circle.&#160; 循環参照を検出する Transact-SQL スクリプトを作成するテーブルのリンク リストが含まれていますが、このページからダウンロードすることもできます。&#160; このコードは SQL Azure と SQL Server で動作します。</p>    <pre class=\"csharpcode\"><span class=\"kwrd\">SET</span> NOCOUNT <span class=\"kwrd\">ON</span>    <span class=\"rem\">-- WWB: Create a Temp Table Of All Relationship To Improve Overall Performance</span>  <span class=\"kwrd\">CREATE</span> <span class=\"kwrd\">TABLE</span> #TableRelationships (FK_Schema nvarchar(<span class=\"kwrd\">max</span>), FK_Table nvarchar(<span class=\"kwrd\">max</span>),      PK_Schema nvarchar(<span class=\"kwrd\">max</span>), PK_Table nvarchar(<span class=\"kwrd\">max</span>))    <span class=\"rem\">-- WWB: Create a List Of All Tables To Check</span>  <span class=\"kwrd\">CREATE</span> <span class=\"kwrd\">TABLE</span> #TableList ([<span class=\"kwrd\">Schema</span>] nvarchar(<span class=\"kwrd\">max</span>), [<span class=\"kwrd\">Table</span>] nvarchar(<span class=\"kwrd\">max</span>))    <span class=\"rem\">-- WWB: Fill the Table List</span>  INSERT <span class=\"kwrd\">INTO</span> #TableList ([<span class=\"kwrd\">Table</span>], [<span class=\"kwrd\">Schema</span>])  <span class=\"kwrd\">SELECT</span> TABLE_NAME, TABLE_SCHEMA  <span class=\"kwrd\">FROM</span> INFORMATION_SCHEMA.TABLES   <span class=\"kwrd\">WHERE</span> Table_Type = <span class=\"str\">'BASE TABLE'</span>    <span class=\"rem\">-- WWB: Fill the RelationShip Temp Table</span>  INSERT <span class=\"kwrd\">INTO</span> #TableRelationships(FK_Schema, FK_Table, PK_Schema, PK_Table)  <span class=\"kwrd\">SELECT</span>      FK.TABLE_SCHEMA,      FK.TABLE_NAME,      PK.TABLE_SCHEMA,      PK.TABLE_NAME  <span class=\"kwrd\">FROM</span> INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS C        <span class=\"kwrd\">INNER</span> <span class=\"kwrd\">JOIN</span> INFORMATION_SCHEMA.TABLE_CONSTRAINTS FK <span class=\"kwrd\">ON</span>           C.CONSTRAINT_NAME = FK.CONSTRAINT_NAME        <span class=\"kwrd\">INNER</span> <span class=\"kwrd\">JOIN</span> INFORMATION_SCHEMA.TABLE_CONSTRAINTS PK <span class=\"kwrd\">ON</span>           C.UNIQUE_CONSTRAINT_NAME = PK.CONSTRAINT_NAME        <span class=\"kwrd\">INNER</span> <span class=\"kwrd\">JOIN</span> INFORMATION_SCHEMA.KEY_COLUMN_USAGE CU <span class=\"kwrd\">ON</span>           C.CONSTRAINT_NAME = CU.CONSTRAINT_NAME        <span class=\"kwrd\">INNER</span> <span class=\"kwrd\">JOIN</span> (              <span class=\"kwrd\">SELECT</span> i1.TABLE_NAME, i2.COLUMN_NAME              <span class=\"kwrd\">FROM</span> INFORMATION_SCHEMA.TABLE_CONSTRAINTS i1              <span class=\"kwrd\">INNER</span> <span class=\"kwrd\">JOIN</span> INFORMATION_SCHEMA.KEY_COLUMN_USAGE i2 <span class=\"kwrd\">ON</span>               i1.CONSTRAINT_NAME = i2.CONSTRAINT_NAME              <span class=\"kwrd\">WHERE</span> i1.CONSTRAINT_TYPE = <span class=\"str\">'PRIMARY KEY'</span>  ) PT <span class=\"kwrd\">ON</span> PT.TABLE_NAME = PK.TABLE_NAME    <span class=\"kwrd\">CREATE</span> <span class=\"kwrd\">TABLE</span> #Stack([<span class=\"kwrd\">Schema</span>] nvarchar(<span class=\"kwrd\">max</span>), [<span class=\"kwrd\">Table</span>] nvarchar(<span class=\"kwrd\">max</span>))    <span class=\"kwrd\">GO</span>    <span class=\"rem\">-- WWB: Drop SqlAzureRecursiveFind</span>  <span class=\"kwrd\">IF</span>  <span class=\"kwrd\">EXISTS</span> (<span class=\"kwrd\">SELECT</span> * <span class=\"kwrd\">FROM</span> sys.objects <span class=\"kwrd\">WHERE</span> object_id =       OBJECT_ID(N<span class=\"str\">'[dbo].[SqlAzureRecursiveFind]'</span>) <span class=\"kwrd\">AND</span> type <span class=\"kwrd\">in</span> (N<span class=\"str\">'P'</span>, N<span class=\"str\">'PC'</span>))  <span class=\"kwrd\">DROP</span> <span class=\"kwrd\">PROCEDURE</span> [dbo].[SqlAzureRecursiveFind]    <span class=\"kwrd\">GO</span>    <span class=\"rem\">-- WWB: Create a Stored Procedure that Recursively Calls Itself</span>  <span class=\"kwrd\">CREATE</span> <span class=\"kwrd\">PROC</span> SqlAzureRecursiveFind      @BaseSchmea nvarchar(<span class=\"kwrd\">max</span>),      @BaseTable nvarchar(<span class=\"kwrd\">max</span>),      @Schmea nvarchar(<span class=\"kwrd\">max</span>),      @<span class=\"kwrd\">Table</span> nvarchar(<span class=\"kwrd\">max</span>),      @Fail nvarchar(<span class=\"kwrd\">max</span>) <span class=\"kwrd\">OUTPUT</span>  <span class=\"kwrd\">AS</span>        <span class=\"kwrd\">SET</span> NOCOUNT <span class=\"kwrd\">ON</span>                      <span class=\"rem\">-- WWB: Keep Track Of the Schema and Tables We Have Checked</span>      <span class=\"rem\">-- Prevents Looping          </span>      INSERT <span class=\"kwrd\">INTO</span> #Stack([<span class=\"kwrd\">Schema</span>],[<span class=\"kwrd\">Table</span>]) <span class=\"kwrd\">VALUES</span> (@Schmea, @<span class=\"kwrd\">Table</span>)            <span class=\"kwrd\">DECLARE</span> @RelatedSchema nvarchar(<span class=\"kwrd\">max</span>)      <span class=\"kwrd\">DECLARE</span> @RelatedTable nvarchar(<span class=\"kwrd\">max</span>)            <span class=\"rem\">-- WWB: Select all tables that the input table is dependent on</span>      <span class=\"kwrd\">DECLARE</span> table_cursor <span class=\"kwrd\">CURSOR</span> <span class=\"kwrd\">LOCAL</span>  <span class=\"kwrd\">FOR</span>            <span class=\"kwrd\">SELECT</span> PK_Schema, PK_Table            <span class=\"kwrd\">FROM</span> #TableRelationships            <span class=\"kwrd\">WHERE</span> FK_Schema = @Schmea <span class=\"kwrd\">AND</span> FK_Table = @<span class=\"kwrd\">Table</span>        <span class=\"kwrd\">OPEN</span> table_cursor;        <span class=\"rem\">-- Perform the first fetch.</span>      <span class=\"kwrd\">FETCH</span> <span class=\"kwrd\">NEXT</span> <span class=\"kwrd\">FROM</span> table_cursor <span class=\"kwrd\">INTO</span> @RelatedSchema, @RelatedTable;        <span class=\"rem\">-- Check @@FETCH_STATUS to see if there are any more rows to fetch.</span>      <span class=\"kwrd\">WHILE</span> <span class=\"preproc\">@@FETCH_STATUS</span> = 0      <span class=\"kwrd\">BEGIN</span>                <span class=\"rem\">-- WWB: If We have Recurred To Where We Start This</span>          <span class=\"rem\">-- Is a Circular Reference</span>          <span class=\"rem\">-- Begin failing out of the recursions</span>          <span class=\"kwrd\">IF</span> (@BaseSchmea = @RelatedSchema <span class=\"kwrd\">AND</span>                   @BaseTable = @RelatedTable)              <span class=\"kwrd\">BEGIN</span>                  <span class=\"kwrd\">SET</span> @Fail = @RelatedSchema + <span class=\"str\">'.'</span> + @RelatedTable                  <span class=\"kwrd\">RETURN</span>              <span class=\"kwrd\">END</span>          <span class=\"kwrd\">ELSE</span>                      <span class=\"kwrd\">BEGIN</span>                        <span class=\"kwrd\">DECLARE</span> @<span class=\"kwrd\">Count</span> <span class=\"kwrd\">int</span>                        <span class=\"rem\">-- WWB: Check to make sure that the dependencies are not in the stack</span>              <span class=\"rem\">-- If they are we don't need to go down this branch</span>              <span class=\"kwrd\">SELECT</span>    @<span class=\"kwrd\">Count</span> = <span class=\"kwrd\">COUNT</span>(1)              <span class=\"kwrd\">FROM</span>    #Stack                  <span class=\"kwrd\">WHERE</span>    #Stack.[<span class=\"kwrd\">Schema</span>] = @RelatedSchema <span class=\"kwrd\">AND</span>                   #Stack.[<span class=\"kwrd\">Table</span>] = @RelatedTable                        <span class=\"kwrd\">IF</span> (@<span class=\"kwrd\">Count</span>=0)               <span class=\"kwrd\">BEGIN</span>                  <span class=\"rem\">-- WWB: Recurse</span>                  <span class=\"kwrd\">EXECUTE</span> SqlAzureRecursiveFind @BaseSchmea,                       @BaseTable,                       @RelatedSchema, @RelatedTable, @Fail <span class=\"kwrd\">OUTPUT</span>                  <span class=\"kwrd\">IF</span> (LEN(@Fail) &gt; 0)                  <span class=\"kwrd\">BEGIN</span>                      <span class=\"rem\">-- WWB: If the Call Fails, Build the Output Up</span>                      <span class=\"kwrd\">SET</span> @Fail = @RelatedSchema + <span class=\"str\">'.'</span> + @RelatedTable                           + <span class=\"str\">' -&gt; '</span> + @Fail                      <span class=\"kwrd\">RETURN</span>                  <span class=\"kwrd\">END</span>              <span class=\"kwrd\">END</span>         <span class=\"kwrd\">END</span>                      <span class=\"rem\">-- This is executed as long as the previous fetch succeeds.</span>      <span class=\"kwrd\">FETCH</span> <span class=\"kwrd\">NEXT</span> <span class=\"kwrd\">FROM</span> table_cursor <span class=\"kwrd\">INTO</span> @RelatedSchema, @RelatedTable;      <span class=\"kwrd\">END</span>        <span class=\"kwrd\">CLOSE</span> table_cursor;      <span class=\"kwrd\">DEALLOCATE</span> table_cursor;        <span class=\"kwrd\">GO</span>        <span class=\"kwrd\">SET</span> NOCOUNT <span class=\"kwrd\">ON</span>    <span class=\"kwrd\">DECLARE</span> @<span class=\"kwrd\">Schema</span> nvarchar(<span class=\"kwrd\">max</span>)  <span class=\"kwrd\">DECLARE</span> @<span class=\"kwrd\">Table</span> nvarchar(<span class=\"kwrd\">max</span>)  <span class=\"kwrd\">DECLARE</span> @Fail nvarchar(<span class=\"kwrd\">max</span>)    <span class=\"rem\">-- WWB: Loop Through All the Tables In the Database Checking Each One</span>  <span class=\"kwrd\">DECLARE</span> list_cursor <span class=\"kwrd\">CURSOR</span> <span class=\"kwrd\">FOR</span>        <span class=\"kwrd\">SELECT</span> [<span class=\"kwrd\">Schema</span>], [<span class=\"kwrd\">Table</span>]        <span class=\"kwrd\">FROM</span> #TableList    <span class=\"kwrd\">OPEN</span> list_cursor;    <span class=\"rem\">-- Perform the first fetch.</span>  <span class=\"kwrd\">FETCH</span> <span class=\"kwrd\">NEXT</span> <span class=\"kwrd\">FROM</span> list_cursor <span class=\"kwrd\">INTO</span> @<span class=\"kwrd\">Schema</span>, @<span class=\"kwrd\">Table</span>;    <span class=\"rem\">-- Check @@FETCH_STATUS to see if there are any more rows to fetch.</span>  <span class=\"kwrd\">WHILE</span> <span class=\"preproc\">@@FETCH_STATUS</span> = 0  <span class=\"kwrd\">BEGIN</span>        <span class=\"rem\">-- WWB: Clear the Stack (Don't you love Global Variables)</span>      <span class=\"kwrd\">DELETE</span> #Stack            <span class=\"rem\">-- WWB: Initialize the Input</span>      <span class=\"kwrd\">SET</span> @Fail = <span class=\"str\">''</span>        <span class=\"rem\">-- WWB: Check the Table</span>      <span class=\"kwrd\">EXECUTE</span> SqlAzureRecursiveFind @<span class=\"kwrd\">Schema</span>,           @<span class=\"kwrd\">Table</span>, @<span class=\"kwrd\">Schema</span>,           @<span class=\"kwrd\">Table</span>, @Fail <span class=\"kwrd\">OUTPUT</span>      <span class=\"kwrd\">IF</span> (LEN(@Fail) &gt; 0)      <span class=\"kwrd\">BEGIN</span>          <span class=\"rem\">-- WWB: Failed, Output</span>          <span class=\"kwrd\">SET</span> @Fail = @<span class=\"kwrd\">Schema</span> + <span class=\"str\">'.'</span> + @<span class=\"kwrd\">Table</span> + <span class=\"str\">' -&gt; '</span> + @Fail          <span class=\"kwrd\">PRINT</span> @Fail      <span class=\"kwrd\">END</span>                   <span class=\"rem\">-- This is executed as long as the previous fetch succeeds.</span>      <span class=\"kwrd\">FETCH</span> <span class=\"kwrd\">NEXT</span> <span class=\"kwrd\">FROM</span> list_cursor <span class=\"kwrd\">INTO</span> @<span class=\"kwrd\">Schema</span>, @<span class=\"kwrd\">Table</span>;  <span class=\"kwrd\">END</span>    <span class=\"rem\">-- WWB: Clean Up</span>  <span class=\"kwrd\">CLOSE</span> list_cursor;  <span class=\"kwrd\">DEALLOCATE</span> list_cursor;                            <span class=\"kwrd\">DROP</span> <span class=\"kwrd\">TABLE</span> #TableRelationships  <span class=\"kwrd\">DROP</span> <span class=\"kwrd\">TABLE</span> #Stack  <span class=\"kwrd\">DROP</span> <span class=\"kwrd\">TABLE</span> #TableList  <span class=\"kwrd\">DROP</span> <span class=\"kwrd\">PROC</span> SqlAzureRecursiveFind</pre>      <h2>まとめ</h2>    <p>質問、懸念事項、コメントはありますか? 以下に投稿すると、対処を試みることができます。</p>"
