### YamlMime:Yaml
ms.openlocfilehash: baa153b3cd2b8feaa38848a4d9f65dde3ccafbc9
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139890750"
Slug: in-memory-oltp-blog-update-q1-2017
Title: OLTP 更新の In-Memory
Summary: 2016年11月、Azure SQL Database 世界での OLTP テクノロジ In-Memory の一般提供 (GA) を発表しました。 その後、次の作業を行っています...
Content: >-
  <p>2016年11月に、世界中の Azure SQL Database における<a href="https://docs.microsoft.com/en-us/sql/relational-databases/in-memory-oltp/in-memory-oltp-in-memory-optimization" target="_blank">インメモリ OLTP</a>テクノロジの一般提供 (GA) が発表されました。 次に、いくつかの便利な機能のロックを解除するために取り組んできました。これにより、このテクノロジをアプリケーションでより効率的に活用できるようになります。</p>


  <p>本日は、Azure SQL Database で In-Memory OLTP テクノロジを改善するための文字列を発表しました。これは複数の手段にまたがり、引き続き T SQL の領域をロック解除して拡張し、全体的な管理の容易性を向上させます。</p>


  <p>新機能の改善点は次のとおりです。<u>現時点</u>では Azure SQL Database で提供されており、 <a href="https://docs.microsoft.com/en-us/sql/sql-server/what-s-new-in-sql-server-vnext" target="_blank">SQL Server vnext</a>でも利用できます。&nbsp;&nbsp;</p>


  <h2>メモリ最適化テーブルのインデックス数の増加</h2>


  <p>メモリ最適化テーブルの8つのインデックスの制限が解消されました。 これで、ディスクベーステーブルで作成できるように、メモリ最適化テーブルに対して複数のインデックスを作成できるようになりました。</p>


  <p>この制限のために以前に移行できなかったデータベースのディスクベーステーブルは、メモリ最適化されているため、In-Memory OLTP テクノロジのパフォーマンス上の利点を活用できるようになりました。&nbsp;&nbsp;</p>


  <h2>OLTP スキーマ管理の In-Memory</h2>


  <p>Azure SQL Database の OLTP In-Memory の GA には、メモリ最適化オブジェクトに対する ALTER 操作のサポートが含まれていました。 これにより、列の追加や削除、インデックスの管理、ネイティブコンパイルストアドプロシージャの更新など、ほとんどのスキーマ管理操作を実行できるようになりました。 その時点で、まだサポートされていない操作は、オブジェクトの名前の変更でした。</p>


  <p>ここでは、メモリ最適化テーブルとネイティブコンパイル SQL t-sql モジュールに<a href="https://docs.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/sp-rename-transact-sql" target="_blank">sp_rename</a>システムストアドプロシージャのサポートを追加することで、これに対処しました。 これにより、Azure SQL Database は、In-Memory OLTP のすべての主要なスキーマ管理操作をサポートするようになりました。</p>


  <ul>
      <li><strong>sp_rename</strong> - sp_rename は、現在のデータベース内のユーザーオブジェクトの名前を変更するために使用します。 このストアドプロシージャを使用すると、テーブル、テーブル列、ネイティブコンパイルプロシージャなどの OLTP オブジェクトの名前をすべて変更できるようになります。 In-Memory</li>
  </ul>


  <blockquote>

  <p><em>ネイティブコンパイルの T SQL モジュールは、スキーマバインドモジュールとして作成する必要があることに注意してください。スキーマバインドモジュールから参照されるテーブル、列、およびモジュールの名前を変更することはできません。したがって、ネイティブコンパイル T SQL モジュールから参照されるテーブルまたは列の名前を変更するには、まずモジュールを削除してから、名前変更を実行し、最後に新しい名前を参照するモジュールを作成し直します。</em></p>

  </blockquote>


  <h2>コミット依存関係の最大制限を排除</h2>


  <p>特定のトランザクションが依存するトランザクションの最大数の制限は、特定のトランザクションに依存するトランザクションの数が削除されます。&nbsp;</p>


  <p>そのため、対応するエラーメッセージ &quot; が表示されなくなります。 41839: &nbsp; <em>トランザクションがコミット依存関係</em> &quot; の最大数を超えました。</p>


  <h2>In-Memory OLTP の拡張 T SQL サポート</h2>


  <p>In-Memory OLTP は、Azure SQL Database SQL Server 2016 で完全にパリティされていた一般公開されている SQL のセキュリティではありませんでした。これには、DISTINCT、サブクエリ、in、EXISTS、OR、NOT、OUTER JOIN などの構成要素のサポートが含まれます。</p>


  <p>さらに、T SQL サポートを拡張し、次のものを追加しました。</p>


  <ul>
      <li><strong>ケース</strong> &ndash;ネイティブコンパイル T SQL モジュール内の SELECT ステートメントで CASE 式が完全にサポートされるようになりました。 この前に、1つの結果セットを作成するテーブル変数を作成し、このテーブル変数から、ケースを定義する述語に基づいて選択する必要があります。</li>
      <li><strong>計算列</strong> &ndash; 計算列、および計算列のインデックスが、メモリ最適化テーブルでサポートされるようになりました。 さらに、メモリ最適化テーブルの計算列にインデックスを作成できるようになりました。</li>
      <li><strong>クロス適用と JSON</strong> &ndash;相互適用演算子が、ネイティブコンパイルの T SQL モジュールでサポートされるようになりました。 さらに、すべての<a href="https://docs.microsoft.com/en-us/azure/sql-database/sql-database-json-features" target="_blank">JSON 関数</a>と句が、ネイティブコンパイルの T SQL モジュールとメモリ最適化テーブルの制約でサポートされるようになりました。 計算列のインデックスでは、JSON データのインデックスを作成できます。 <a href="https://docs.microsoft.com/en-us/sql/relational-databases/json/optimize-json-processing-with-in-memory-oltp">In-Memory OLTP を使用した JSON 処理の最適化</a>について説明します。</li>
  </ul>


  <p>言及すべき別の機能として、 <a href="https://docs.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/sp-spaceused-transact-sql" target="_blank">sp_spaceused</a>のサポートがあります。 ストレージがプラットフォームによって管理されている Azure SQL Database でも、sp_spaceused によって、メモリ最適化テーブルに格納されているデータのストレージ特性についての十分な洞察を得ることができます。</p>


  <ul>
      <li><strong>sp_spaceused</strong> - sp_spaceused を使用して、In-Memory OLTP に関連付けられているストレージフットプリントを把握できるようになりました。 新しいパラメーター &#39;@include_total_xtp_storage&#39; が同じに対してストアドプロシージャに追加されました。 Sp_spaceused の詳細については、こちらを<a href="https://docs.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/sp-spaceused-transact-sql#a-namebkmk2016a-includesssql15includessssql15-mdmd-and-later">参照して &nbsp; </a>ください。</li>
  </ul>


  <p>現在、アプリケーションで In-Memory OLTP テクノロジを利用している場合、または今後使用する予定がある場合は、このような改善によって新しいシナリオが可能になり、アプリケーションでこのテクノロジを活用しやすくなることを whilemaking に切ことを願っています。</p>
