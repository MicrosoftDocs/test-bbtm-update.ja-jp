### YamlMime:Yaml
ms.openlocfilehash: c1a0c05065af753cd73ded3b5215b990a6163a59
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139895265"
Slug: using-explain-to-profile-slow-queries-in-azure-database-for-mysql
Title: EXPLAIN を使用して、パフォーマンスの低下したクエリをAzure Database for MySQL
Summary: Azure Database for MySQLは、Microsoft が Azure で提供する PaaS (サービスとしてのプラットフォーム) ソリューションです。 Azure マネージド サービス for MySQL (および PostgreSQL) を使用すると、インテリジェントで安全なアプリケーションを簡単に構築できます。
Content: >-
  <p><a href="https://azure.microsoft.com/en-us/services/mysql/">Azure Database for MySQL</a> は、Microsoft が Azure で提供する PaaS (サービスとしてのプラットフォーム) ソリューションです。 Azure マネージド サービス for MySQL (および <a href="https://azure.microsoft.com/en-us/services/postgresql/">PostgreSQL</a>) を使用すると、インテリジェントで安全なアプリケーションを簡単に構築できます。</p>


  <p>Microsoft はデータベースのパフォーマンスを最適化するために多くの作業を行っていますが、単純なクエリが、データベースの全体的なパフォーマンスに影響を与える可能性がある場合があります。 幸いにも、MySQL &ndash; には、クライアント クエリをプロファイルし、低速クエリの根本原因を特定するのに役立つ便利なツール EXPLAIN &ndash; ステートメントが統合されています。 EXPLAIN ステートメントを使用すると、ステートメントの実行方法SQL情報を取得できます。 この情報を使用すると、実行速度が遅いクエリと、その理由をプロファイルできます。</p>


  <p>次の出力は、EXPLAIN ステートメントの実行例を示しています。</p>


  <pre class="prettyprint">

  mysql&gt; EXPLAIN SELECT * FROM tb1 WHERE id=100\G

  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: tb1
     partitions: NULL
           type: ALL
  possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
           rows: 995789
       filtered: 10.00
          Extra: Using where
  </pre>


  <p>この例から見て、キーの値は NULL です。 つまり、MySQL はクエリ用に最適化されたインデックスを見つけ出すので、完全なテーブル スキャンを実行します。 ID&#39;インデックスを追加して、このクエリを最適化します。</p>


  <pre class="prettyprint">

  mysql&gt; ALTER TABLE tb1 ADD KEY (id);

  mysql&gt; EXPLAIN SELECT * FROM tb1 WHERE id=100\G

  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: tb1
     partitions: NULL
           type: ref
  possible_keys: id
            key: id
        key_len: 4
            ref: const
           rows: 1
       filtered: 100.00
          Extra: NULL
  </pre>


  <p>新しい EXPLAIN ステートメントでは、MySQL でインデックスが使用され、行数が 1 に制限され、検索時間が大幅に短縮されます。</p>


  <h2>カバリング インデックス</h2>


  <p>カバー インデックスは、データ テーブルからの値の取得を減らすために、インデックス内のクエリのすべての列で構成されます。 これを説明するには、次の GROUP BY ステートメントを参照してください。</p>


  <pre class="prettyprint">

  mysql&gt; EXPLAIN SELECT MAX(c1), c2 FROM tb1 WHERE c2 LIKE &#39;%100&#39; GROUP BY c1\G

  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: tb1
     partitions: NULL
           type: ALL
  possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
           rows: 995789
       filtered: 11.11
          Extra: Using where; Using temporary; Using filesort
  </pre>


  <p>出力に示す通り、MySQL では適切なインデックスが使用できないので、インデックスは使用されません。 出力には、一時の使用 &quot;も示されます。filesort を使用&quot;すると、MySQL は GROUP BY 句を満たす一時テーブルを &quot;作成&quot; します。</p>


  <p>c2&quot; だけでインデックス&quot;を作成する場合でも違いはありません。MySQL では一時テーブルを作成する必要があります。</p>


  <pre class="prettyprint">

  mysql&gt; ALTER TABLE tb1 ADD KEY (c2);

  mysql&gt; EXPLAIN SELECT MAX(c1), c2 FROM tb1 WHERE c2 LIKE &#39;%100&#39; GROUP BY c1\G

  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: tb1
     partitions: NULL
           type: ALL
  possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
           rows: 995789
       filtered: 11.11
          Extra: Using where; Using temporary; Using filesort
  </pre>


  <p>この場合、&quot;c1&quot; &quot;と c2 の両方で、c2&quot; &quot;&quot; の値をインデックスに直接追加して、さらにデータ参照を排除することで、対象となるインデックスを作成できます。</p>


  <pre class="prettyprint">

  mysql&gt; ALTER TABLE tb1 ADD KEY covered(c1,c2);

  mysql&gt; EXPLAIN SELECT MAX(c1), c2 FROM tb1 WHERE c2 LIKE &#39;%100&#39; GROUP BY c1\G

  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: tb1
     partitions: NULL
           type: index
  possible_keys: covered
            key: covered
        key_len: 108
            ref: NULL
           rows: 995789
       filtered: 11.11
          Extra: Using where; Using index
  </pre>


  <p>上の EXPLAIN プランが示すように、MySQL では、対象のインデックスが使用され、一時テーブルの作成が回避されます。</p>


  <h2>結合インデックス</h2>


  <p>結合インデックスは複数の列の値で構成され、インデックス付き列の値を連結して並べ替えられる行の配列と見なされます。 これは、GROUP BY ステートメントで役立ちます。</p>


  <pre class="prettyprint">

  mysql&gt; EXPLAIN SELECT c1, c2 from tb1 WHERE c2 LIKE &#39;%100&#39; ORDER BY c1 DESC LIMIT 10\G

  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: tb1
     partitions: NULL
           type: ALL
  possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
           rows: 995789
       filtered: 11.11
          Extra: Using where; Using filesort
  </pre>


  <p>MySQL は、特&quot;&quot;に多くの行を並べ替える必要がある場合に、多少遅いファイルソート操作を実行します。 このクエリを最適化するには、並べ替え中の両方の列に結合インデックスを作成します。</p>


  <pre class="prettyprint">

  mysql&gt; ALTER TABLE tb1 ADD KEY my_sort2 (c1, c2);

  mysql&gt; EXPLAIN SELECT c1, c2 from tb1 WHERE c2 LIKE &#39;%100&#39; ORDER BY c1 DESC LIMIT 10\G

  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: tb1
     partitions: NULL
           type: index
  possible_keys: NULL
            key: my_sort2
        key_len: 108
            ref: NULL
           rows: 10
       filtered: 11.11
          Extra: Using where; Using index
  </pre>


  <p>EXPLAIN プランでは、インデックスが既に並べ替え済みであるから、MySQL で結合インデックスを使用して追加の並べ替えを回避できると示されました。</p>


  <h2>まとめ</h2>


  <p>EXPLAIN とさまざまな種類のインデックスを使用すると、パフォーマンスが大幅に向上する可能性があります。 テーブルにインデックスを作成しても、&rsquo;MySQL でクエリに使用できるとは限りません。 常に EXPLAIN を使用して前提条件を検証し、インデックスを使用してクエリを最適化してください。</p>


  <h2>こちらもご覧ください</h2>


  <ul>
      <li><a href="https://azure.microsoft.com/en-us/blog/performance-best-practices-for-using-azure-database-for-postgresql/">Azure Database for PostgreSQL でのパフォーマンスのベスト プラクティス</a></li>
  </ul>
