### YamlMime:Yaml
ms.openlocfilehash: 5a347bfef6dc95179b66d7922e2c973258c4ccf2
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139891400"
Slug: the-real-cost-of-indexes
Title: インデックスの実際のコスト
Summary: '[この記事は、チームによってSQL Azureされました。]前のブログ記事では、パフォーマンスを向上し、I/O の使用量を減らすために、対象となるインデックスを作成する方法について説明しました。 対象となるインデックスは、一種の非-...'
Content: "<p>[この記事は、チームによってSQL Azureされました。]</p><p>前のブログ記事では、パフォーマンスを向上し、I/O の使用量を減らすために、対象となるインデックスを作成する方法について説明しました。 対象となるインデックスは、すべてのデータのテーブル スキャンよりも優れたパフォーマンスを作成するために、クエリ内のすべての列を \"カバー\" する非クラスター化インデックスの一種です。 観察者は、カバーされたインデックスの作成に関連する財務コストがある、と指摘しました。 彼は正しいSQL Azure、対象となるインデックスをサーバーに格納するために必要な部屋の料金を請求しました。 対象となるインデックスのコストを決定するために、いくつかの Transact-SQL クエリを記述すると興味深いと思いました。これは、このブログ記事で行う予定です。</p>  <h2>対象となるインデックスがリソースを消費する</h2>  <p>無料の対象となるインデックスなどはありません。対象となるインデックスがリソースを消費するSQL ServerまたはSQL Azureに関係なく。 このSQL Server、SQL Server を実行するためにマシンを購入するときに、コストの一部を前払いします。インデックス用の RAM とハード ドライブ領域を追加購入します。 保証、バックアップ、電源、冷却、メンテナンスなどSQL Serverオンプレミスのサービスに関連するその他のコストがあります。 これらはすべて月単位で計算するのは難しく、時間のと共にマシンを減価償却する必要があります。また、ハード ドライブの障害など、一部の費用は変動し、計画外です。 これらはサーバーの全体的な運用コストであり、1 つの対象となるインデックスのコストをドリルダウンして決定する方法はありません。 ある場合は、Transact-SQL ステートメントを実行して、インデックスの月額コストを計算すると良いでしょうか。 このSQL Azure、それを実行できます。</p>  <h2>SQL Azure価格</h2>  <p>現時点ではSQL Azure月あたり 9.99 ドルのデータが課金されます (公式の価格については、こちらを参照してください)。 これは、データベースの上限サイズではなく、格納するデータの実際のサイズが下がる範囲のコストです。 つまり、1 GB の Web エディション データベースに数メガバイトしか格納していない場合、コストは月額 9.99 ドルになります。 範囲は 1、5、10、20、30、40、50 ギガバイトです。データを格納するバイトあたりのコストを削減するサイズに近くなります。 次に示すのは、SQLコストを計算する Transact-SQL ステートメントです。</p>  <pre class=\"csharpcode\"><span class=\"kwrd\">DECLARE</span> @SizeInBytes bigint  <span class=\"kwrd\">SELECT</span> @SizeInBytes =  (<span class=\"kwrd\">SUM</span>(reserved_page_count) * 8192)      <span class=\"kwrd\">FROM</span> sys.dm_db_partition_stats    <span class=\"kwrd\">DECLARE</span> @Edition sql_variant  <span class=\"kwrd\">SELECT</span>  @Edition =DATABASEPROPERTYEX ( DB_Name() , <span class=\"str\">'Edition'</span> )    <span class=\"kwrd\">SELECT</span>    (<span class=\"kwrd\">CASE</span>       <span class=\"kwrd\">WHEN</span> @SizeInBytes/1073741824.0 &lt; 1 <span class=\"kwrd\">THEN</span> (<span class=\"kwrd\">CASE</span> @Edition <span class=\"kwrd\">WHEN</span> <span class=\"str\">'Web'</span> <span class=\"kwrd\">THEN</span> 9.99 <span class=\"kwrd\">ELSE</span> 99.99 <span class=\"kwrd\">END</span>)      <span class=\"kwrd\">WHEN</span> @SizeInBytes/1073741824.0 &lt; 5 <span class=\"kwrd\">THEN</span> (<span class=\"kwrd\">CASE</span> @Edition <span class=\"kwrd\">WHEN</span> <span class=\"str\">'Web'</span> <span class=\"kwrd\">THEN</span> 49.95 <span class=\"kwrd\">ELSE</span> 99.99 <span class=\"kwrd\">END</span>)       <span class=\"kwrd\">WHEN</span> @SizeInBytes/1073741824.0 &lt; 10 <span class=\"kwrd\">THEN</span> 99.99        <span class=\"kwrd\">WHEN</span> @SizeInBytes/1073741824.0 &lt; 20 <span class=\"kwrd\">THEN</span> 199.98      <span class=\"kwrd\">WHEN</span> @SizeInBytes/1073741824.0 &lt; 30 <span class=\"kwrd\">THEN</span> 299.97                   <span class=\"kwrd\">WHEN</span> @SizeInBytes/1073741824.0 &lt; 40 <span class=\"kwrd\">THEN</span> 399.96                    <span class=\"kwrd\">WHEN</span> @SizeInBytes/1073741824.0 &lt; 50 <span class=\"kwrd\">THEN</span> 499.95                        <span class=\"kwrd\">END</span>)  / @SizeInBytes</pre>    <h2>対象となるインデックスのコスト</h2>    <p>1 バイトあたりの真のコストがわかったので、各インデックス のコストを把握しましょう。 Transact-SQL では、クラスター化されていないすべてのインデックスの対象となるインデックスを確認できません。インデックスが作成された理由はインデックス作成者だけが知る点に注意してください。</p>    <p>クラスター化されていない各インデックスSQL月あたりのコストを取得する Transact-SQLを次に示します。</p>    <pre class=\"csharpcode\"><span class=\"kwrd\">DECLARE</span> @SizeInBytes bigint  <span class=\"kwrd\">SELECT</span> @SizeInBytes =  (<span class=\"kwrd\">SUM</span>(reserved_page_count) * 8192)      <span class=\"kwrd\">FROM</span> sys.dm_db_partition_stats    <span class=\"kwrd\">DECLARE</span> @Edition sql_variant  <span class=\"kwrd\">SELECT</span>  @Edition =DATABASEPROPERTYEX ( DB_Name() , <span class=\"str\">'Edition'</span> )    <span class=\"kwrd\">DECLARE</span> @CostPerByte <span class=\"kwrd\">float</span>    <span class=\"kwrd\">SELECT</span>    @CostPerByte = (<span class=\"kwrd\">CASE</span>       <span class=\"kwrd\">WHEN</span> @SizeInBytes/1073741824.0 &lt; 1 <span class=\"kwrd\">THEN</span> (<span class=\"kwrd\">CASE</span> @Edition <span class=\"kwrd\">WHEN</span> <span class=\"str\">'Web'</span> <span class=\"kwrd\">THEN</span> 9.99 <span class=\"kwrd\">ELSE</span> 99.99 <span class=\"kwrd\">END</span>)      <span class=\"kwrd\">WHEN</span> @SizeInBytes/1073741824.0 &lt; 5 <span class=\"kwrd\">THEN</span> (<span class=\"kwrd\">CASE</span> @Edition <span class=\"kwrd\">WHEN</span> <span class=\"str\">'Web'</span> <span class=\"kwrd\">THEN</span> 49.95 <span class=\"kwrd\">ELSE</span> 99.99 <span class=\"kwrd\">END</span>)       <span class=\"kwrd\">WHEN</span> @SizeInBytes/1073741824.0 &lt; 10 <span class=\"kwrd\">THEN</span> 99.99        <span class=\"kwrd\">WHEN</span> @SizeInBytes/1073741824.0 &lt; 20 <span class=\"kwrd\">THEN</span> 199.98      <span class=\"kwrd\">WHEN</span> @SizeInBytes/1073741824.0 &lt; 30 <span class=\"kwrd\">THEN</span> 299.97                   <span class=\"kwrd\">WHEN</span> @SizeInBytes/1073741824.0 &lt; 40 <span class=\"kwrd\">THEN</span> 399.96                    <span class=\"kwrd\">WHEN</span> @SizeInBytes/1073741824.0 &lt; 50 <span class=\"kwrd\">THEN</span> 499.95                        <span class=\"kwrd\">END</span>)  / @SizeInBytes</pre>    <pre class=\"csharpcode\"><span class=\"kwrd\">SELECT</span> idx.name, <span class=\"kwrd\">SUM</span>(reserved_page_count) * 8192 <span class=\"str\">'bytes'</span>,    (<span class=\"kwrd\">SUM</span>(reserved_page_count) * 8192) * @CostPerByte <span class=\"str\">'cost'</span>  <span class=\"kwrd\">FROM</span> sys.dm_db_partition_stats <span class=\"kwrd\">AS</span> ps      <span class=\"kwrd\">INNER</span> <span class=\"kwrd\">JOIN</span> sys.indexes <span class=\"kwrd\">AS</span> idx <span class=\"kwrd\">ON</span> idx.object_id = ps.object_id <span class=\"kwrd\">AND</span> idx.index_id = ps.index_id  <span class=\"kwrd\">WHERE</span> type_desc = <span class=\"str\">'NONCLUSTERED'</span>  <span class=\"kwrd\">GROUP</span> <span class=\"kwrd\">BY</span> idx.name  <span class=\"kwrd\">ORDER</span> <span class=\"kwrd\">BY</span> 3 <span class=\"kwrd\">DESC</span></pre>    <p>    <p>Adventure Works データベースの結果は次のように表示されます。</p>    <p><a href=\"\"><img style=\"border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px\" title=\"clip_image001\" border=\"0\" alt=\"clip_image001\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2806.clip_5F00_image001_5F00_thumb_5F00_53B6D7BE.png\" width=\"518\" height=\"294\"></a></p>    <p>最も経費インデックスは次 <b>IX_Address_AddressLine1_AddressLine2_City_StateProvince_PostalCode_CountryRegion </b>アドレス テーブルの参照時間を増やす対象となるインデックスです。 1 か月あたり約 50 セントのコストがかかります。 この情報を使用すると、この対象となるインデックスを持つことのパフォーマンス上の利点とコスト比較を行い、保持する必要があるかどうかを判断できます。 </p>    <h2>すべてのデータをパースペクティブに保持する</h2>    <p>自分のインデックスを <b>削除IX_Address_AddressLine1_AddressLine2_City_StateProvince_PostalCode_CountryRegion </b>すると、お金が節約されますか? 該当する範囲が変更されない場合はそうではありません。 Adventure Works データベースは 1 ギガバイト未満なので、1 か月あたり 9.99 ドルを支払います。範囲の上側を越えない限り、別のクラスター化インデックスを作成してもコストはかからなくなります。 そう見た場合、データベースを完全に埋め込まなかったカバー付きインデックスの作成は基本的に無料です。 データに必要な範囲に対して費用を費やすことにコミットしたら、最大サイズ内に収まる限り、カバーされたインデックス (パフォーマンスを向上させる) を作成する必要があります。</p>    <p>これは基本的にオンプレミスの SQL Server と同じです。サーバーにコストを費やした後、マシン リソース内にクラスター化インデックスを追加してもコストはかからなくなります。</p>    <h2>免責情報</h2>    <p>SQL Azure の価格と最大データベース サイズは、将来変更される可能性があります。インデックス コストが正確な状態を確認するために、提供されているクエリと現在のコストを比較してください。</p>    <h2>まとめ</h2>    <p>同じことを実現するより良い方法はありますか? 以下のコメントに投稿してください。 質問、懸念事項、コメントはありますか? 以下に投稿すると、対処を試みることができます。</p>"
