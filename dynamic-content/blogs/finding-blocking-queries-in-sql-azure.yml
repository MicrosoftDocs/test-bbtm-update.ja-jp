### YamlMime:Yaml
ms.openlocfilehash: 6c33d0a9018373838d9c8301429f0e885f3ec1f4
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139909013"
Slug: finding-blocking-queries-in-sql-azure
Title: SQL Azure でブロッキング クエリを探す
Summary: '[この記事は、チームによってSQL Azureされました。]低速または実行時間の長いクエリは、リソースの過剰な消費に寄与し、ブロックされたクエリの結果になる可能性があります。言い換えると、悪い...'
Content: <p>[この記事は、チームによってSQL Azureされました。]</p><p>クエリが低速であるか実行時間が長いと、大量のリソースが消費され、結果としてクエリがブロックされる可能性があります。つまり、パフォーマンスが低下します。 ブロックの概念は、その後、SQL Azureで異SQL Server。 ブロッキングは、ロックベースのコンカレンシーが行われているリレーショナル データベース管理システムの回避不可能な特性です。</p>  <p>次のクエリでは、合計経過時間が最も長く、他のクエリがブロックされている上位 10 個の実行中のクエリが表示されます。 </p>  <pre class="csharpcode"><span class="kwrd">SELECT</span> <span class="kwrd">TOP</span> 10 r.session_id, r.plan_handle,      r.sql_handle, r.request_id,      r.start_time, r.status,      r.command, r.database_id,      r.user_id, r.wait_type,      r.wait_time, r.last_wait_type,      r.wait_resource, r.total_elapsed_time,      r.cpu_time, r.transaction_isolation_level,      r.row_count, st.text  <span class="kwrd">FROM</span> sys.dm_exec_requests r  <span class="kwrd">CROSS</span> APPLY sys.dm_exec_sql_text(r.sql_handle) <span class="kwrd">as</span> st  <span class="kwrd">WHERE</span> r.blocking_session_id = 0       <span class="kwrd">and</span> r.session_id <span class="kwrd">in</span>       (<span class="kwrd">SELECT</span> <span class="kwrd">distinct</span>(blocking_session_id)           <span class="kwrd">FROM</span> sys.dm_exec_requests)  <span class="kwrd">GROUP</span> <span class="kwrd">BY</span> r.session_id, r.plan_handle,      r.sql_handle, r.request_id,      r.start_time, r.status,      r.command, r.database_id,      r.user_id, r.wait_type,      r.wait_time, r.last_wait_type,      r.wait_resource, r.total_elapsed_time,      r.cpu_time, r.transaction_isolation_level,      r.row_count, st.text  <span class="kwrd">ORDER</span> <span class="kwrd">BY</span> r.total_elapsed_time <span class="kwrd">desc</span></pre>      <p>ブロックの原因には、不適切なアプリケーション設計、不適切なクエリ プラン、有効なインデックスの欠如などがあります。 </p>    <h4>ブロックについて</h4>    <p>このSQL Azure、1 つの接続が特定のリソースのロックを保持し、2 つ目の接続が同じリソースで競合するロックの種類を取得しようとするときにブロックが発生します。 通常、最初の接続がリソースをロックする時間枠は非常に小さいです。 ロックを解放すると、2 番目の接続はリソースに対する独自のロックを取得し、処理を続行できます。 これは通常の動作であり、システムのパフォーマンスに顕著な影響を与えることなく、日に何度も発生する可能性があります。</p>    <p>    <br>クエリの期間とトランザクション コンテキストによって、そのロックが保持される期間と、それによって他のクエリへの影響が決されます。 クエリがトランザクション内で実行されない (およびロック ヒントが使用されていない) 場合、SELECT ステートメントのロックは、クエリの実行中ではなく、実際に読み取り中のリソースにのみ保持されます。 INSERT、UPDATE、および DELETE ステートメントの場合、データの整合性と必要に応じてクエリのロールバックを許可するために、クエリの期間中はロックが保持されます。</p>    <p>    <br>トランザクション内で実行されるクエリの場合、ロックが保持される期間は、クエリの種類、トランザクション分離レベル、およびクエリでロック ヒントが使用されるかどうかによって決まります。 ロック、ロック ヒント、およびトランザクション分離レベルの説明については、オンライン ブックの次のトピックSQL Server参照してください。 </p>    <ul>    <li><a href="https://msdn.microsoft.com/en-us/library/ms190615.aspx">データベース エンジンのロック</a></li>      <li><a href="https://msdn.microsoft.com/en-us/library/ms187101.aspx">ロックおよび行のバージョン管理のカスタマイズ</a></li>      <li><a href="https://msdn.microsoft.com/en-us/library/ms175519.aspx">ロック モード</a></li>      <li><a href="https://msdn.microsoft.com/en-us/library/ms186396.aspx">ロックの互換性</a></li>      <li><a href="https://msdn.microsoft.com/en-us/library/ms177404.aspx">データベース エンジンでの行のバージョン管理に基づく分離レベル</a></li>      <li><a href="https://msdn.microsoft.com/en-us/library/ms175523.aspx">トランザクションの制御 (データベース エンジン)</a></li>  </ul>    <h4>まとめ</h4>    <p>短くてシンプルな方法は、短いクエリが多い場合、実行時間の長いクエリよりもブロックする可能性が低くなります。 実行している作業を小さな単位に分割し、トランザクションの量を減らし、実行時間の速いクエリを記述すると、最適なパフォーマンスが得されます。 注意してください。書き込み速度の低いクエリが 1 つでも、より高速で効率的なクエリをブロックして、低速化する可能性があります。 質問、懸念事項、コメントはありますか? 以下に投稿すると、対処を試みることができます。</p>
