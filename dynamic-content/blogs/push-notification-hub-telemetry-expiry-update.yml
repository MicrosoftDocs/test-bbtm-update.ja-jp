### YamlMime:Yaml
ms.openlocfilehash: bc8244e3d48f79c3517724d5466e4b1346440e02
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139895790"
Slug: push-notification-hub-telemetry-expiry-update
Title: メッセージごとのテレメトリとデバイスの有効期限のNotification Hubs
Summary: Notification Hubsのテレメトリ機能でスケジュールされた送信がサポートされ、許可されているデバイスの有効期限 (有効期間) が無限大に拡張されました。
Content: >-
  <p>メッセージごとのテレメトリ機能とデバイスの有効期限に関する一部の更新プログラムを発表します。</p>


  <h2>メッセージごとのテレメトリ</h2>


  <p><a href="https://msdn.microsoft.com/en-us/library/azure/mt608135.aspx">メッセージごとのテレメトリがスケジュール</a>された通知で<a href="https://msdn.microsoft.com/en-us/library/azure/dn790626.aspx"></a>使用できる状態にし、追加のプッシュ要求処理の状態を理解するために改善されました。 既存の Enqueued、Processing、Completed、Abandoned の状態に加え、次の項目を追加しました。</p>


  <ul>
      <li>スケジュール済み (スケジュールされた通知の場合): メッセージはキューに入り、スケジュールされた時刻に送信されます</li>
      <li>取り消されました (スケジュールされた通知の場合): スケジュールされたメッセージはユーザーによって取り消されました</li>
      <li>NoTargetFound: プッシュ要求のターゲット デバイスが見つかりませんでした</li>
  </ul>


  <p>Rest または .NET SDK を使用して、<font style="line-height: 1.46em; font-family: &quot;andale mono&quot;, &quot;lucida console&quot;, monospace; font-size: 13px; font-style: normal; font-weight: normal; white-space: pre;">GetNotificationOutcomeDetailsAsyncAPI</font>&#39;メッセージごとのテレメトリを使用<span style="line-height: 20px; font-family: tahoma, &quot;Helvetica Neue&quot;, arial, helvetica, sans-serif; font-size: 13px; font-style: normal; font-weight: normal;">&nbsp;</span><span style="line-height: 20px; font-family: tahoma, &quot;Helvetica Neue&quot;, arial, helvetica, sans-serif; font-size: 13px; font-style: normal; font-weight: normal; white-space: pre;">できます。</span></p>


  <pre class="prettyprint" style="font-size: 13px;">

  <font style="font-size: 13px;">//Notification will be sent after an hour

  NotificationHubClient notificationHubClient;

  DateTimeOffset scheduledTime = new DateTimeOffset(DateTime.UtcNow).AddHours(1);

  var scheduledNotification = notificationHubClient.ScheduleNotificationAsync(&lt;Notification&gt;, scheduledTime);


  //Query the status of this send request

  var outcome = notificationHubClient.GetNotificationOutcomeDetailsAsync(scheduledNotification.NotificationId);</font>

  </pre>


  <h2>Time To Live (デバイスの有効期限)</h2>


  <p>多くのお客様は、このシナリオで過去に私たちに来ました。エンド ユーザーがアプリを開いることはほとんどないが、アプリによって提供される通知に大きく依存している場合は、どうでしょうか。 Notification Hubs には最大 90 日間のデバイスの Time To Live &ndash; が設定され、デバイスがアプリの起動時にハブに登録されたので、このソリューションは、各デバイスを最新の状態に保つために、以前は顧客が開始したエクスポート/更新インポート プロセスでした。 その&rsquo;理由として、デバイス モデル 、登録とインストール <a href="https://azure.microsoft.com/en-us/documentation/articles/notification-hubs-registration-management/">(推奨)</a> の両方で許可されるデバイス<a href="https://azure.microsoft.com/en-us/documentation/articles/notification-hubs-registration-management/"></a>の有効期限を無限大 (正確には 9999-12-31T23:59:59) に拡張することを決定しました。</p>


  <p>&rsquo;アプリの起動時にデバイスの登録とインストールを更新することをお勧めしますが、カスタマイズした Time To Live &ldquo;&rdquo; にデバイスが到達しない限り、またはサービスが送信試行時にプラットフォーム通知システムからトークンの有効期限切れエラーを受け取らない限り、登録またはインストールの削除を開始しません。 カスタマイズされていない限り、ハブの Time To Live は既定でシステムの最大 DateTime 値に設定されます。 そのため、最近その通知ハブ&ldquo;を作成した場合は、<a href="https://manage.windowsazure.com">10M</a> 以上のクラシック Azure portal に [登録の Time To Live&rdquo;] と表示されるのが正解です。</p>


  <p>この有効期限の変更を利用するには、通知ハブの&rsquo; [ <a href="https://msdn.microsoft.com/en-us/library/azure/microsoft.azure.notificationhubs.notificationhubdescription.registrationttl.aspx">Time To Live] プロパティを更新</a> します。 これは、REST または .NET SDK を使用して実行できます。</p>


  <pre class="prettyprint" style="font-size: 13px;">

  <font style="font-size: 13px;">var namespaceManager = NamespaceManager.CreateFromConnectionString(&quot;connectionstring&quot;);

  NotificationHubDescription hub = namespaceManager.GetNotificationHub(&quot;foo&quot;);

  hub.RegistrationTtl = TimeSpan.MaxValue;

  namespaceManager.UpdateNotificationHub(hub);</font>

  </pre>


  <p>試してみてください。以下のコメント セクションで、ご意見をお寄せください。</p>
