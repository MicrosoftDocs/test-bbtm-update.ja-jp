### YamlMime:Yaml
ms.openlocfilehash: d873aecd86477328cc8da0d341dd3636f18b6888
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139910284"
Slug: uniqueidentifier-and-clustered-indexes
Title: Uniqueidentifier とクラスター化インデックス
Summary: '[この記事は、チームによってSQL Azureされました。]GUID が気に入っています。つまり、ID の uniqueidentifier データ型SQL Server。 すべて、ドメイン名、一意のエラー メッセージ、主キーに使用します。'
Content: <p>[この記事は、チームによってSQL Azureされました。]</p><p>GUID が気に入っています。つまり、ID の <a href="https://msdn.microsoft.com/en-us/library/ms190215.aspx" mce_href="https://msdn.microsoft.com/en-us/library/ms190215.aspx"><b>uniqueidentifier</b></a> データ型SQL Server。 すべて、ドメイン名、一意のエラー メッセージ、およびデータベース テーブル内の主キーなどに使用します。 -- 開始しない。 約 2 年前に、マージする独自の機能のために、主キーに <b>uniqueidentifier</b> を使用し始めました。 </p>  <h2>マージ</h2>  <p>NewId() コマンドをSQL Server GUID を作成すると、それが宇宙全体で一意になる保証があります。 つまり、2 つのデータベース (同じスキーマを持つ) が完全に切断され、同じテーブルへの行の追加が切断されている場合、 <b>uniqueidentifier</b> の主キーを使用すると、主キーが競合しな "ない" 状態になります。 一方、2 つのデータベースにテーブルの主キーとして ID 整数列がある場合、両方のテーブルに同じ主キーが挿入される可能性が非常に高い可能性があります。</p>  <p>これはマージと何を行う必要がありますか? プライマリ キーとして uniqueidentifier を使用している場合、切断されたデータベースのテーブルを互いにマージするのはとんでもなく簡単です。 一方、ID 整数主キー間でマージし、それらの主キーへの外部キー参照を更新する場合、競合を解決するのがはるかに困難です。</p>  <h2>クラスタリングと uniqueidentifier</h2>  <p><b>uniqueidentifier</b> 列にクラスター化インデックスを作成し、<a href="https://msdn.microsoft.com/en-us/library/ms190348.aspx" mce_href="https://msdn.microsoft.com/en-us/library/ms190348.aspx">NEWID()</a> を使用して GUID を生成することはできません。 その理由は、<b>NEWID() </b>によって GUID が連続しない順序で生成され、クラスター化SQL Server順序付けされる可能性が高いという理由です。 これは機能します。SQL Server uniqueidentifier 列を中心にクラスター化インデックスを作成できます。ただし、SQL Server が不要な作業を実行し、パフォーマンスの低下を引き起こします。 その理由は、クラスター化インデックスの中央に (順次順に) データを挿入すると、SQL Server がクラスターの並び替えによってデータの部屋を作り出す原因です。</p>  <p>それでは、それが良い考えではない場合、なぜ人がそれを行うのでしょうか。 SQL Server では、SQL Server Management Studio で主キーとして列を割り当てると、その列のデータ型に関係なく、自動的にクラスター化インデックスが生成されます。 したがって、uniqueidentifier データ型のテーブルを主キーとして使用する場合は、そのインデックスを非クラスター化インデックスに変更する必要があります。</p>  <p>非クラスター化インデックスは、行がテーブルに挿入される場合にデータの順序を変更しないので、非順次データの挿入に対するクラスター化インデックスのパフォーマンスへの影響はありません。</p>  <h2>一緒にSQL Azure</h2>  <p>私のような主キーに <b>uniqueidentifier</b> データ型が好きであり、主キーに非クラスター化インデックスを作成している場合は、テーブルのクラスター化インデックスも選択する必要があります。 その理由は、SQL Azureテーブルに対して 1 つの (および 1 つのみ) クラスター化インデックスが必要な場合です。 ただし、クラスター化SQL Azureが必要なからといって、主キー列である必要があるわけではありません。</p>  <h2>クラスター化インデックスの選択</h2>  <p>クラスター化インデックスを選択するには、いくつかの戦略があります。最も簡単で最適な方法の 1 つは、データ型 <b>datetime</b> の別の列を追加し、その列をクラスター化インデックスに使用することです。 実行する必要がある操作を次に示します。</p>  <p>1. 列をデータ型 <b>datetime として追加する</b></p>  <p>2. 通常は Date と呼 <b>ばれる</b></p>  <p>3. [既定値] を GetDate() に設定します。 </p>  <p>4. null 以外にしてください。</p>  <p>5. データを挿入する前に、クラスター化インデックスを作成します。</p>  <p>列に既定値 <b>GetDate()</b> を追加すると、行が列に自動的に挿入された日時が書き込みます。 これにより、行のデータがテーブル データの末尾に挿入されます。クラスターの並び変更はありません。 データを最後に追加すると、挿入のパフォーマンスが最適です。</p>  <p>クラスター化インデックスのもう 1 つの適切な選択肢は、選択ステートメントの大部分のテーブルの順序を反映する列です。 たとえば、categories という名前のテーブルがある場合、 <b>ordervalue</b> という整数列を使用し、常に SELECT ... を使用してテーブルを呼 <b>び出します。ORDER BY [ordervalue] を選択</b> すると、 <b>クラスター化インデックスの ordervalue</b> が理にかなっています。 その理由は次の理由です。非シーケンシャルな順序値を<b></b>クラスターに挿入するとパフォーマンスが低下しますが、データを呼び出す場合、ワークロードの特性に応じて行がクラスターから順次読み取りされるので、パフォーマンス上のメリットがあります。</p>  <h2>NEWSEQUENTIALID()</h2>  <p>この関数でサポートされていない <a href="https://msdn.microsoft.com/en-us/library/ms189786.aspx" mce_href="https://msdn.microsoft.com/en-us/library/ms189786.aspx"><b>NEWSEQUENTIALID()</b></a> 関数について言及しなかった場合は、SQL Azure。 <b>NEWID()</b> 関数が <b>NEWSEQUENTIALID()</b> 関数よりも一意の非シーケンシャル <b>uniqueidentifier</b> を生成する場合、一意のシーケンシャル <b>uniqueidentifier が生成</b>されます。 <b>NEWSEQUENTIALID()</b> 関数の唯一の方法は、GUID がコンピューターのネットワーク カードに基づいて部分的に生成されるという方法です。</p>  <p>つまり、主キー列として <strong>uniqueidentifier</strong> を正常に作成し、その主キー列を使用して、SQL Server。 <b>NEWSEQUENTIALID() 関数</b>列を使用してその列を埋める限り。 </p>  <p>プライバシーを重視する場合は、この関数は使用しないでください。 次に生成される GUID 値を推測できるため、その GUID に関連付けられているデータにアクセスできることになります。 たとえば、Web ブラウザーのクエリ文字列でテーブルに主キーを渡す場合などです。 詳細 <a href="https://msdn.microsoft.com/en-us/library/ms189786.aspx" mce_href="https://msdn.microsoft.com/en-us/library/ms189786.aspx">については、MSDN</a> を参照してください。</p>  <p>ただし、<b>NEWSEQUENTIALID() 関数は</b>、この関数のSQL Azure。 これを使用すると、次のエラーが発生します。</p>  <p><font color="#ff0000">Msg 40511、レベル 15、状態 1、行 1</font></p>  <p><font color="#ff0000">組み込み関数 'NEWSEQUENTIALID' は、このバージョンの SQL Server。</font></p>  <h4>移行</h4>  <p>既存の SQL Server データベースを SQL Azure に移行する場合は、これらの操作を実行して<b>、主キーとして uniqueidentifier</b> データ型を正常に操作する必要があります。</p>  <ul>  <li>GUID の生成を <b>NEWSEQUENTIALID() から </b><b>NEWID() に変換</b>する</li>  <li><b>uniqueidentifier</b> データ型の列からすべてのクラスター化インデックスを削除します。これにより、移行が妨げるわけではありませんが、パフォーマンスが向上します。</li>  <li>列を選択 (または列を追加) して、クラスター化インデックスを作成します (上記の推奨事項を参照してください)。</li></ul>  <p>質問、懸念事項、コメントはありますか? 以下に投稿すると、対処を試みることができます。</p>
