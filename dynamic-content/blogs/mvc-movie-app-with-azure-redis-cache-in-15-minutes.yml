### YamlMime:Yaml
ms.openlocfilehash: 490cbea7557c6ecd1be2e3d68054681ec39fb4b9
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139904038"
Slug: mvc-movie-app-with-azure-redis-cache-in-15-minutes
Title: Azure Redis Cache が15分の MVC ムービーアプリ
Summary: 新しいプレビュー Azure Redis Cache は、Azure web アプリに簡単にプラグインできます。 MVC ムービーサンプルアプリにプラグインし、Azure にデプロイし、17分以内に実行していました (これは15分で実行され、ローカルでテストできます)。
Content: "<strong>更新日: 2014 年10月25日-REDIS CACHE GA</strong> 新しい <a href=\"https://azuremicrosoftcom/en-us/documentation/services/cache/\" target=\"_blank\">Azure Redis Cache</a> は、azure web アプリに接続して、azure にデプロイ <a href=\"https://wwwaspnet/mvc/tutorials/mvc-5/introduction/getting-started\">し、azure</a>にデプロイした後、17分以内に実行していた azure web アプリに簡単にプラグインできます (接続してローカルでテストするには15分)。\n\n<a href=\"https://acomazurecomcdnnet/80C57D/blogmedia/blogmedia/2014/05/p1png\"><img style=\"border-width: 0px\" title=\"p1\" alt=\"p1\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/p1_thumb.png\" width=\"493\" height=\"525\" border=\"0\" /></a>\n\nキャッシュからホットデータをフェッチすることによってデータベースの打ちつけるよりも約100倍高速にキャッシュされます。アプリを高速化するだけでなく、DB の負荷を軽減し、他のクエリの応答性を向上させることもできます。\n\n完成したサンプルはこちらからダウンロードできます。\n\nここでは、Redis cache を MVC ムービーサンプルに接続しました。\n<ol>\n <li><a href=\"https://portalazurecom/\" target=\"_blank\">Azure portal</a>にログオンし、[新しいキャッシュの作成] を選択します。\n<img alt=\"\" src=\"\" />\nこの手順には最大15分かかることがありますが、手順を完了するために必要な手順については、「Azure Redis Cache   の<a href=\"https://azuremicrosoftcom/en-us/documentation/articles/cache-dotnet-how-to-use-azure-redis-cache/\" target=\"_blank\">使用方法</a>」を参照してください。キャッシュを作成することが重要なのは、web サイトを別の場所に移動してテストした web サイトを作成するのと同じ場所 (データセンター) です。 詳細な手順については、キャッシュの待機時間が25倍増加しています。詳細な手順については、「サンプルを<a href=\"https://msdnmicrosoftcom/en-us/library/dn690516aspx\" target=\"_blank\">Redis Cache 作成</a>する」を参照してください。このサンプルをダウンロードすると、完全なサンプルをダウンロードしてキャッシュエンドポイント (URL) と資格情報を更新し、次に従うことができます。</li>\n <li>キャッシュ名<span style=\"font-family: lucida console\"> &lt; yourName &gt; rediscachewindowsnet</span>とパスワードをコピーします (ポータルの [プロパティ] ブレードの [<strong>キー</strong> ] ボタンをクリックして、キャッシュ名とパスワードを確認します)。</li>\n <li>NuGet パッケージ<strong>StackExchangeRedis</strong>を追加します。これを使用している場合は、サンプルの NuGet パッケージも復元する必要があります。</li>\n <li>パッケージマネージャーコンソールで、NuGet パッケージを復元して<strong>データベースの更新</strong>コマンドを確認<strong>した後</strong>、Visual Studio を終了して再起動する必要がある場合があります。</li>\n <li>接続情報をコントローラーに接続します。</li>\n</ol>\n<pre class=\"prettyprint\">public class MoviesController : Controller\n{\n   private MovieDBContext db = new MovieDBContext();\n   private static Lazy&lt;ConnectionMultiplexer&gt; lazyConnection = new Lazy&lt;ConnectionMultiplexer&gt;(() =&gt;\n   {\n      return ConnectionMultiplexerConnect(KeysconStr);\n   });\n\n   public static ConnectionMultiplexer Connection\n   {\n      get\n      {\n         return lazyConnectionValue;\n      }\n   }</pre>\n&nbsp;\n\n<span style=\"background: white;color: black\"><strong>警告</strong>: 資格情報を保存しないでください。このサンプルを簡単にするために、ソースコードには、「Azure websites の Windows」を参照してください。資格情報を格納する方法については、「<a href=\"https://azuremicrosoftcom/blog/2013/07/17/windows-azure-web-sites-how-application-strings-and-connection-strings-work/\">アプリケーション文字列と接続文字列の動作</a>」を参照してください。</span>接続は静的変数として格納されるので、接続が\n\n<span style=\"background: white;color: black\">有効であること 接続が切断されている場合は、接続が再確立</span>されます。\n\n<strong>SampleStackExchangeRedisExtensions</strong>クラスを含む新しいクラスを作成します。\n<pre class=\"prettyprint\">public static class SampleStackExchangeRedisExtensions\n{\n   public static T Get&lt;T&gt;(this IDatabase cache, string key)\n   {\n      return Deserialize&lt;T&gt;(cacheStringGet(key));\n   }\n\n   public static object Get(this IDatabase cache, string key)\n   {\n      return Deserialize&lt;object&gt;(cacheStringGet(key));\n   }\n\n   public static void Set(this IDatabase cache, string key, object value)\n   {\n      cacheStringSet(key, Serialize(value));\n   }\n\n   static byte[] Serialize(object o)\n   {\n      if (o == null)\n      {\n         return null;\n      }\n      BinaryFormatter binaryFormatter = new BinaryFormatter();\n      using (MemoryStream memoryStream = new MemoryStream())\n      {\n         binaryFormatterSerialize(memoryStream, o);\n         byte[] objectDataAsStream = memoryStreamToArray();\n         return objectDataAsStream;\n      }\n   }\n\n   static T Deserialize&lt;T&gt;(byte[] stream)\n   {\n      BinaryFormatter binaryFormatter = new BinaryFormatter();\n      if (stream == null)\n         return default(T);\n\n      using (MemoryStream memoryStream = new MemoryStream(stream))\n      {\n         T result = (T)binaryFormatterDeserialize(memoryStream);\n         return result;\n      }\n   }\n}</pre>\n&nbsp;\n\n<strong>SampleStackExchangeRedisExtensions</strong>クラスを使用すると、 <a href=\"https://msdnmicrosoftcom/en-us/library/systemserializableattributeaspx\">[serializable]</a>属性をモデルに追加するために必要なシリアル化可能な型を簡単にキャッシュできます。\n<pre class=\"prettyprint\">[Serializable]\npublic class Movie</pre>\n  <span style=\"background: white;color: #2b91af\">Movie </span>movie のすべてのインスタンスを検索する<span style=\"background: white;color: black\">= dbMoviesFind (id);</span>\n\n次のように置き換えます。\n<pre class=\"prettyprint\">//Movie movie = dbMoviesFind(id);\nMovie movie = getMovie((int)id);</pre>\nPOST Edit および Delete メソッドで、次の呼び出しを使用してキャッシュを削除します。\n<pre class=\"prettyprint\">ClearMovieCache(movieID);</pre>\nムービーコントローラーに次のコードを追加します。 <strong>Getmovie</strong> メソッドは、標準のオンデマンドキャッシュを使用する方法を使用します。\n<pre class=\"prettyprint\">Movie getMovie(int id)\n{\n   Stopwatch sw = StopwatchStartNew();\n   IDatabase cache = ConnectionGetDatabase();\n   Movie m = (Movie)cacheGet(idToString()); \n\n   if (m == null)\n   {\n      Movie movie = dbMoviesFind(id);\n      cacheSet(idToString(), movie);\n      StopWatchMiss(sw);\n      return movie;\n   }\n   StopWatchHit(sw); \n\n   return m;\n} \n\nprivate void ClearMovieCache(int p)\n{\n   IDatabase cache = connectionGetDatabase();\n   if (cacheKeyExists(pToString()))\n      cacheKeyDelete(pToString());\n} \n\nvoid StopWatchEnd(Stopwatch sw, string msg)\n{\n   swStop();\n   double ms = swElapsedTicks / (StopwatchFrequency / (10000));\n   ViewBagcacheMsg = msg + msToString() +\n       ” PID: ” + ProcessGetCurrentProcess()IdToString();\n} \n\nvoid StopWatchMiss(Stopwatch sw)\n{\n   StopWatchEnd(sw, “Miss – MS:”);\n} \n\nvoid StopWatchHit(Stopwatch sw)\n{\n   StopWatchEnd(sw, “Hit – MS:”);\n}</pre>\n<strong>ViewBagcacheMsg</strong>コードを<em>Views\\Shared \\_ Layoutcshtml</em>ファイルに追加して、すべてのページでタイミングの情報を取得します。\n<pre class=\"prettyprint\">&lt;div class=\"container body-content\"&gt;\n        @RenderBody()\n        &lt;hr /&gt;\n        &lt;footer&gt;\n           &lt;h2&gt;@ViewBagcacheMsg&lt;/h2&gt;\n        &lt;/footer&gt;\n    &lt;/div&gt;\n\n    @ScriptsRender(\"~/bundles/jquery\")\n    @ScriptsRender(\"~/bundles/bootstrap\")\n    @RenderSection(\"scripts\", required: false)\n&lt;/body&gt;\n&lt;/html&gt;</pre>\nローカルでテストし、時間情報を取得できるようになりました。ムービーがキャッシュされた後は、キャッシュに保持されます (メモリ不足のため、DB が小さすぎてすべてのデータを削除できません)。サンプルダウンロードでは、[ <strong>Clearcache</strong> ] ボタンをクリックして各キャッシュエントリを削除できます。\n<h2>ポータルからのキャッシュの監視</h2>\nポータルから、キャッシュのヒット/ミスの統計情報を取得できます。\n\n<a href=\"https://acomazurecomcdnnet/80C57D/blogmedia/blogmedia/2014/05/stpng\"><img style=\"border-width: 0px\" title=\"st\" alt=\"st\" src=\"https://azurecomcdnazureedgenet/mediahandler/acomblog/media/Default/blog/st_thumbpng\" width=\"381\" height=\" it to your dashboard – that way you’ll see it each time you log into the portal You can also add other metrics such as <em>evicted keys, expired keys, used memory</em> and <em>CPU</em>\n\n最新のデータを取得して監視対象を選択するには、[ <strong>監視</strong> ] ボックスを右クリックし、[ <strong>クエリの編集</strong>] を選択して、監視するデータを確認します。\n\n<a href=\"https://acomazurecomcdnnet/80C57D/blogmedia/blogmedia/2014/05/ed2png\"><img style=\"border-width: 0px\" title=\"ed2\" alt=\"ed2\" src=\"https://azurecomcdnazureedgenet/mediahandler/acomblog/media/Default/blog/ed2_thumbpng\" width=\"315\" height=\"573\" border=\"0\" /></a>\n\nオンにした項目に対してのみ <、アラートを設定することができます。 [ <strong>アラートの追加</strong> ] ボタンをクリックして、次の画像で監視している項目に対してアラートを設定することができます。15分間のキーの削除を監視しています。 stronick が大きい場合は、大きなキャッシュを使用するとよいでしょう\n\n<a href=\"https://acomazurecomcdnnet/80C57D/blogmedia/blogmedia/2014/05/metpng\"><img style=\"border-width: 0px\" title=\"適応\" alt=\"met\" src=\"https://azurecomcdnazureedgenet/mediahandler/acomblog/media/Default/blog/met_thumbpng\" width=\"594\" height=\"843\" border=\"0\" /></a>\n\nVisual Studio を使用すると、web アプリを右クリックして [発行] を選択するだけで、キャッシュを作成したのと同じ web サイトのリージョンを選択できます。この場合、クライアントをキャッシュするのとは別のリージョンにあるキャッシュ (この場合は web アプリ) でもデータ転送コストが発生する可能性があります。 <strong>Code First Migrations</strong>\n\n<a href=\"https://acomazurecomcdnnet/80C57D/blogmedia/blogmedia/2014/05/pwpng\"><img style=\"border-width: 0px\" title=\"pw\" alt=\"pw\" src=\"https://azurecomcdnazureedgenet/mediahandler/acomblog/media/Default/blog/pw_thumbpng\" width=\"652\" height=\"513\" border=\"0\" /></a>\n\nこれで、クラウドでアプリをテストし、キャッシュの待機時間を大幅に短縮できます (キャッシュと web サイトが同じデータセンターにあることを前提としています)。\n<h2>キャッシュのストレステスト</h2>\nキャッシュ操作の既定のタイムアウトは1000ミリ秒 (1 秒) です。次のコードを使用すると、コードが NotTestingTimeOut がコメントアウトされ <strong>#define</strong> たときに、タイムアウトが150ミリ秒に短縮され、負荷が高いときにタイムアウト例外が発生しやすくなります。\n<pre class=\"prettyprint\">#else\n   #region StressTest\n       private static Lazy&lt;ConnectionMultiplexer&gt; lazyConnection = new Lazy&lt;ConnectionMultiplexer&gt;(() =&gt;\n      {\n\n      var config = new ConfigurationOptions();\n            configEndPointsAdd(KeysURL);\n            configPassword = Keyspasswd;\n            configSsl = true;\n            configSyncTimeout = 150;\n\n           return ConnectionMultiplexerConnect(config);\n      });\n   #endregion\n#endif</pre>\nセッションキャッシュを無効にすることをお勧めしますが、 <em>webconfig</em> ファイル内のフロー要素を使用して、アプリ全体に対して実行できるストレステストを行います。\n<pre class=\"prettyprint\">&lt;sessionState mode=\"Off\" /&gt;</pre>\nまたは、コントローラーで <a href=\"https://msdnmicrosoftcom/en-us/library/systemwebmvcsessionstateattributeaspx\" target=\"_blank\">[SessionState (SessionStateBehaviorDisabled)]</a> を使用することもできます。更新された <span style=\"font-family: lucida console\">getmovie</span> メソッドはより堅牢で、タイムアウト例外によって最大3回再試行されます。\n<pre class=\"prettyprint\">      Movie getMovie(int id, int retryAttempts = 0)\n      {\n         IDatabase cache = ConnectionGetDatabase();\n         if (retryAttempts &gt; 3)\n         {\n            string error = \"getMovie timeout with \" + retryAttemptsToString()\n               + \" retry attempts Movie ID = \" + idToString();\n            Logger(error);\n\n            ViewBagcacheMsg = error + \" Fetch from DB\";\n            // Cache unavailable, get data from DB\n            return dbMoviesFind(id);\n         }\n         Stopwatch sw = StopwatchStartNew();\n         Movie m;\n\n         try\n         {\n            m = (Movie)cacheGet(idToString());\n         }\n\n         catch (TimeoutException tx)\n         {\n            Logger(\"getMovie fail, ID = \" + idToString(), tx);\n            return getMovie(id, ++retryAttempts);\n         }\n\n         if (m == null)\n         {\n            Movie movie = dbMoviesFind(id);\n            cacheSet(idToString(), movie);\n            StopWatchMiss(sw);\n            return movie;\n         }\n         StopWatchHit(sw);\n\n         return m;\n      }</pre>\nサンプルアプリには、キャッシュをロードテストするために呼び出すことができる方法がいくつかあります。\n\n<a href=\"https://acomazurecomcdnnet/80C57D/blogmedia/blogmedia/2014/06/qqpng\"><img style=\"border-width: 0px\" title=\"qq\" alt=\"qq\" src=\"https://azurecomcdnazureedgenet/mediahandler/acomblog/media/Default/blog/qq_thumbpng\" width=\"549\" height=\"526\" border=\"0\" /></a>\n\n<span style=\"font-family: lucida console\">WriteCache</span>メソッドと<span style=\"font-family: lucida console\">readcache</span>メソッドは、1 k 個の項目の書き込みまたは読み取りを行うために、必要に応じて \"/n\" を URL に追加して n * k 項目を書き込みまたは読み取ります。たとえば、サイト &gt; Azurewebwebsites Net/映画/readcache/3 は、 &lt; キャッシュされた 3 k の項目を読み取ります。\n\n150ミリ秒のタイムアウトでキャッシュを使用すると、\"background: 白色; color: black >\" スタイルを取得できました。 getMovie </span> メソッドによってキャッシュエラーが正しく処理され、db からムービーが返され、\"<span style=\"font-family: lucida console\"><strong>getmovie timeout with 4 Retry RETRY movie ID = 3 FETCH from db</strong></span>\" という警告メッセージがログに書き込まれます。\n\n運用アプリでキャッシュエラーを処理できるようにする必要がある (スレーブまたはフェールオーバーがない) 基本キャッシュを選択した場合は、ホストされている VM が1か月に1回使用できなくなることが保証されます。この場合、標準キャッシュには、非ブロッキング最初の同期と自動再接続が非常に高速なマスターと キャッシュエラーを正しく処理するには、コードを記述する必要があります\n\n&nbsp;\n<h2>Azure Redis Cache ASPNET セッション状態プロバイダー</h2>\nセッション状態を使用しないようにすることをお勧めしますが、一部のアプリケーションでは、セッションデータを使用することによって<strong>パフォーマンスや複雑さ</strong>が向上しますが、他のアプリではセッション状態が必要になりますが、セッション状態の既定のメモリプロバイダーの既定では、(web サイトの複数のインスタンスを実行している SQL Server) セッション状態プロバイダーでは、複数の web サイトでセッション状態を使用できますが、メモリ内のプロバイダーに比べて、待機時間が長くなります。 Redis セッション状態キャッシュプロバイダーは低待機時間で、アプリが限られた量のセッション状態のみを使用している場合に、構成とセットアップが非常に簡単になります。 キャッシュの大部分を使用してデータをキャッシュし、セッション状態の量を抑えることができます。\n\n<strong>RedisSessionStateProvider</strong> NuGet パッケージを web アプリに追加します (<em>プレリリース</em>を指定します。詳細については、こちら<a href=\"https://msdnmicrosoftcom/en-us/library/dn690522aspx\" target=\"_blank\">の記事を</a>参照してください)。ホストの URL とキーを使用してルート<em>webconfig</em>ファイルに追加されたマークアップを編集し、SSL を true に設定します。\n<pre class=\"prettyprint\"> &lt;systemweb&gt;\n     &lt;customErrors mode=\"Off\" /&gt;\n     &lt;!--&lt;sessionState mode=\"Off\" /&gt;--&gt;\n    &lt;authentication mode=\"None\" /&gt;\n    &lt;compilation debug=\"true\" targetFramework=\"45\" /&gt;\n    &lt;httpRuntime targetFramework=\"45\" /&gt;\n  &lt;sessionState mode=\"Custom\" customProvider=\"RedisSessionProvider\"&gt;\n               &lt;add name=\"RedisSessionProvider\" \n              type=\"MicrosoftWebRedisRedisSessionStateProvider\" \n              port=\"6380\"\n              host=\"movie2rediscachewindowsnet\" \n              accessKey=\"m7PNV60CrvKpLqMUxosC3dSe6kx9nQ6jP5del8TmADk=\" \n              ssl=\"true\" /&gt;\n      &lt;!--&lt;add name=\"MySessionStateStore\" type=\"MicrosoftWebRedisRedisSessionStateProvider\" host=\"127001\" accessKey=\"\" ssl=\"false\" /&gt;--&gt;\n      &lt;/providers&gt;\n    &lt;/sessionState&gt;\n  &lt;/systemweb&gt;\n  &lt;systemwebServer&gt;</pre>\nWeb アプリでセッション状態を使用できるようになりました。サンプルでは、WriteCache および ReadCache アクションメニュー (および UI) を提供しています。書き込みキャッシュでは、文字列ルートデータを提供するオプションが用意されています。たとえば、 <span style=\"font-family: lucida console\"><em>https:// &lt; your site &gt; azurewebwebsites Net/Sessiontest/writesession/Hello_joe</em></span> が \"Hello_joe\" をセッション状態に そのため、固定セッションを使用する必要はありません。\n\nこのトピックの内容と、Redis cache について次に説明する内容をお知らせください\n\nツイート quality のスパム保証がない twitter でのフォロー ( <a href=\"https://twittercom/RickAndMSFT\">@RickAndMSFT</a> )\n<h2>その他のリソース</h2>\n<ul>\n <li><a href=\"https://msdnmicrosoftcom/en-us/library/dn690521aspx\" target=\"_blank\">Azure Redis Cache でのデータのキャッシュ</a></li>\n <li><a href=\"https://wacelcodeplexcom/\">Azure Cache Extension Library</a> wacel Windows、サービスとアプリケーションの間で共有できる高レベルのデータ構造を実装します。</li>\n <li><a href=\"https://msdnmicrosoftcom/en-us/library/dn690523aspx\">MSDN Azure Redis Cache</a></li>\n</ul>"
