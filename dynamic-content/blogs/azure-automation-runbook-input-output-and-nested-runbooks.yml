### YamlMime:Yaml
ms.openlocfilehash: fffc02c0e657387d4f531a2277b9a68b46d803b6
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139909346"
Slug: azure-automation-runbook-input-output-and-nested-runbooks
Title: 'Azure Automation: Runbook の入力、出力、入れ子になった Runbook'
Summary: この投稿では、この記事で高品質の Runbook を作成するための基本的な概念について説明Azure Automation。  この記事で説明する概念は、入力パラメーターの定義、出力の種類の定義、Runbook 内から子 Runbook を呼び出す方法です。
Content: "<a href=\"https://azure.microsoft.com/en-us/services/automation/\" target=\"_blank\">Azure Automation、</a><a href=\"https://azure.microsoft.com/\" target=\"_blank\">Microsoft Azure</a>、Dev/Ops、IT プロフェッショナルの新機能により、Runbook を作成して実行し、Azure リソースに対する反復的で複雑なタスクを自動化できます。Azure Automation PowerShell ワークフロー エンジンを使用して Runbook を実行します。つまり、Runbook は PowerShell ワークフローとして作成されます (概要については、 <a href=\"https://technet.microsoft.com/en-us/library/dn469257.aspx\" target=\"_blank\">Runbook</a> の概念に関する記事を参照してください)。\n\nRunbook Azure Automation作成する場合は、システムを十分に利用するためにベスト プラクティスに注意して従う必要があります。Runbook の作成には、PowerShell、PowerShell Workflow、および Azure Automation に関する知識が含Azure Automation。一日の終わりには、PowerShell に精通している場合は、Runbook の作成Azure Automation簡単です。\n\nこの投稿では、高品質の Runbook の作成に役立つ基本的な概念について説明します。このシリーズの他の投稿では、Runbook の作成と管理に関するその他の便利な側面について説明します。この投稿で説明する概念は次のとおりです。\n<ul>\n <li>入力パラメーターの定義</li>\n <li>出力の種類の定義</li>\n <li>Runbook 内からの子 Runbook の呼び出し</li>\n</ul>\n&nbsp;\n<h2>入力パラメーターの定義</h2>\nほとんどの Runbook では、実行前に入力データを提供する必要があります。そのため、Runbook の作成中に、必要な入力パラメーターを定義するのが一般的です。入力パラメーターを定義する主な属性は次のとおりです。\n<ul>\n <li>名前</li>\n <li>型 (.Net 型)</li>\n <li>必須 (または必須)</li>\n <li>既定値 (指定されている場合)</li>\n</ul>\n&nbsp;\n\nAzure Automationは、Runbook の入力パラメーターのこれらの属性をサポートしています。PowerShell では、検証、エイリアス、パラメーター セットなどの入力パラメーターの属性がサポートされています。ただし、Azure Automationは現在、上記の一覧のみをサポートしています。\n\n次のコード スニペットは、Runbook で定義されているパラメーターを示しています。(詳細については、<a href=\"https://gallery.technet.microsoft.com/scriptcenter/site/search?f%5b0%5d.Type=User&amp;f%5b0%5d.Value=SC%20Automation%20Product%20Team&amp;f%5b0%5d.Text=SC%20Automation%20Product%20Team&amp;f%5b1%5d.Type=RootCategory&amp;f%5b1%5d.Value=WindowsAzure&amp;f%5b1%5d.Text=Windows%20Azure\" target=\"_blank\">ScriptCenter の Automation</a> ギャラリーから利用できる <a href=\"https://gallery.technet.microsoft.com/scriptcenter/How-to-use-runbook-8ddee029\" target=\"_blank\">Use-RunbookParameterSample Runbook</a> を参照してください)。\n\n&nbsp;\n<pre class=\"prettyprint\">workflow Add-User\n{\n    param (\n        [Parameter(Mandatory=$true)]\n        [PSCredential] \n        $Credential,\n\n        [Parameter(Mandatory=$true)]\n        [object] \n        $FullName,\n\n        [Parameter(Mandatory=$true)]\n        [string] \n        $Alias,\n\n        [Parameter(Mandatory=$false)]\n        [string]\n        $Company=\"Contoso\",\n\n        [Parameter(Mandatory=$false)]\n        [boolean]\n        $HasAdminRights = $false            \n    )\n    # Do work to add the user to the system...\n}</pre>\n&nbsp;\n\nRunbook 内で Runbook をインラインで呼び出す場合は、入力パラメーターについて次のことを念頭に置きます。\n<ul>\n <li>入力パラメーターが単純型または複合オブジェクト ([PSCredential] など) の場合は、必要に応じて、単純型の値または複合オブジェクトを入力値として直接渡します。</li>\n <li>[object] 型は、PowerShell ハッシュテーブルとして渡し、オブジェクト プロパティの名前と値のペアを指定できます。次の例では、パラメーター \"FullName\" がハッシュテーブルとして渡されています。</li>\n</ul>\n&nbsp;\n<pre class=\"prettyprint\">    $name = @{\"FirstName\"=\"Joe\";\"MiddleName\"=\"Bob\";\"LastName\"=\"Smith\"}\n    Add-User -FullName $name -Alias \"jsmith\" -HasAdminRights $true -Credential $cred</pre>\n&nbsp;\n\n場合によっては、[switch] パラメーターの型は、Runbook のAzure Automation役立ちます。ただし、一般に、[boolean] 型を使用する方が予測可能です。1 つ以上を使用する理由については、このブログ <a href=\"https://www.powershellmagazine.com/2013/12/20/using-powershell-switch-vs-boolean-parameters-in-sma-runbooks/\" target=\"_blank\">記事で説明されています</a>。PowerShell ワークフロー <strong>での</strong> 使用は複雑ではないので、[switch] ではなく [boolean] を使用するのがベスト プラクティスです。\n\nアクティビティまたは別のワークフロー (Runbook) を呼び出す場合、PowerShell ワークフローでは、すべてのパラメーターを位置ではなく名前で参照する必要があります。安全を確保するために、別の Runbook、アクティビティ、またはコマンドレットを呼び出す場合は、常に名前付きパラメーターを使用するワークフローを使用してください。\n\n<strong>ベスト プラクティス:</strong>  ベスト プラクティスとして、Runbook に入力パラメーターを宣言する場合は、非常に明示的である必要があります。上記のAdd-User例をガイドとして使用し、常にパラメーター Type、Name、およびそれが必須かどうかが含まれます。パラメーターの既定値を設定した場合、必須属性の設定方法に関係なく、PowerShell では省略可能なパラメーターと見なされます。Mandatory 属性を省略した場合、既定では パラメーターは省略可能です。ただし、これを明示的に宣言する方が常に最適です。パラメーターに名前を付ける場合は、英字、数字、アンダースコア文字を使用します (ハイフンを含むパラメーター名には避けたい特別な処理が必要なので、ハイフン文字は使用しないでください)。\n\nRunbook の開始ウィザード UI を使用して Azure Automation ポータルから Runbook を開始できる場合は、入力パラメーターについて次のことを念頭に置きます。\n<ul>\n <li>ウィザード UI を使用すると、数値、文字列、datetime、switch、boolean、Azure Automation 資格情報資産名、JSON 配列、または JSON オブジェクトで表される Runbook パラメーターの値を入力できます。</li>\n <li>Runbook に既定値のパラメーターがある場合、この既定値は UI に表示されます。この値を使用するか、変更することができます。</li>\n <li>Runbook パラメーターが [array] または [object] 型を受け取る場合は、Runbook の開始ダイアログで <a href=\"https://en.wikipedia.org/wiki/JSON\" target=\"_blank\">JSON</a> 形式で渡す必要があります。次に例を示します。</li>\n</ul>\n<ul>\n <li>プロパティ バッグを必要とする型 [object] のパラメーターは、{\"StringParam\":\"Joe\",\"IntParam\":42,\"BoolParam\":true} のような形式の JSON 文字列を使用して UI で渡されます。</li>\n <li>型 [array] のパラメーターは、[\"Joe\",42,true] のように書式設定された JSON 文字列で入力できます。</li>\n</ul>\n<ul>\n <li>Runbook パラメーターが PSCredential 型を受け取る場合は、資格情報資産の文字列Azure Automation渡す必要があります。背後では、そのAzure Automation付いた資格情報資産が取得され、Runbook に渡されます。</li>\n</ul>\n&nbsp;\n\n&nbsp;\n\n<img style=\"float: none;margin-left: auto;margin-right: auto;border-width: 0px\" title=\"Runbook を開始する UX\" alt=\"UX for Start Runbook\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/UXStartRunbook.png\" width=\"480\" height=\"415\" border=\"0\" />\n\n&nbsp;\n\nPowerShell コンソールまたは Runbook 内で Runbook を非同期的に開始する場合は、Start-AzureAutomationRunbook コマンドレットを使用します (この後の記事でこのコマンドレットの詳細を参照してください)。入力パラメーターについては、次のことを念頭に置いておきます (次のコード例を参照してください)。\n<ul>\n <li>Start-AzureAutomationRunbook アクティビティによって開始される Runbook への入力パラメーターは、キーと値のペアとしてハッシュテーブルで渡されます。ここで、key はパラメーター名、value はパラメーターの値です。</li>\n <li>Start-AzureAutomationRunbook によって開始される Runbook には、数値、文字列、datetime、switch、boolean、Azure Automation 資格情報資産名、JSON 配列、または JSON オブジェクトで表す入力パラメーターが必要です。</li>\n <li>入力パラメーターが PSCredential 型の場合は、資格情報資産の文字列Azure Automation渡す必要があります。背後では、その名前の資格情報資産が取得され、Runbook に渡されます。</li>\n <li>入力パラメーターがスイッチ型の場合、パラメーターはハッシュテーブルでブール値 ($true または $false) を使用して宣言する必要があります。たとえば、HasAdminRights が [switch] パラメーターの場合は、次の例のように宣言されます。ブール型パラメーターの場合も同様に宣言されます。</li>\n <li>入力パラメーターがプロパティ バッグの場合は、呼び出された Runbook で [object] 型として定義し、PowerShell ハッシュテーブル オブジェクトを入力値として渡します。たとえば、次の $nameを参照してください。</li>\n <li>入力パラメーターが複合オブジェクト ([System.Diagnostics.Process] など) の場合は、呼び出された Runbook で [object] 型として定義し、複合オブジェクトを入力値として渡します。</li>\n</ul>\n&nbsp;\n<pre class=\"prettyprint\">    $name = @{\"FirstName\"=\"Joe\";\"MiddleName\"=\"Bob\";\"LastName\"=\"Smith\"}\n    $params = @{\"Credential\"=\"MyCred\";\"Alias\"=\"jsmith\";\"FullName\"=$name;\"HasAdminRights\"=$true}\n    $job = Start-AzureAutomationRunbook `\n                -Name \"Add-User\" `\n                -Parameters $params `\n                -AutomationAccountName $account</pre>\n入力パラメーターに複合型を割り当て中に留意する必要があるのは、Runbook が別の Runbook から呼び出されるかどうか、およびそれがインラインで呼び出されるか、Start-AzureAutomationRunbook を使用して開始されるかです。インラインでのみ呼び出されると思う場合は、複合型である入力パラメーターを割り当てできます。Runbook をインラインで呼び出すと、複合型を直接渡すことができるためです。ただし、Runbook が UI を介して手動で開始される場合、または Start-AzureAutomationRunbook を使用して子 Runbook として開始される場合は、Web サービスを介して JSON 配列または JSON ハッシュテーブルのみを渡すので、任意の複合型の型を [object] に設定する必要があります。ベスト プラクティス <strong>として、</strong>Runbook の起動方法が分からない場合は、複雑な入力パラメーターを型 [object] として定義します。\n\n&nbsp;\n<h2>出力の種類の定義</h2>\nPowerShell では長い間、OutputType 属性を使用した関数とコマンドレットでの出力型の定義 <a href=\"https://technet.microsoft.com/en-us/library/hh847785.aspx\" target=\"_blank\">がサポートされています</a>。この属性は実行時には効果がありません。代わりに、ツールがデザイン時に、それらを実行せずにコマンドレットによって出力されるオブジェクトの種類を学習する方法として提供されています。\n\nOutputType は PowerShell ワークフローで使用できます。出力がある Runbook には OutputType を含める必要があります。パラメーター宣言の直前に、Runbook の上部付近に OutputType 属性を配置します。Runbook での OutputType の使用例を次に示します。\n\n&nbsp;\n<pre class=\"prettyprint\">workflow Get-UserNames\n{\n    [OutputType([string])]\n\n    $names = @()\n    # Do work here to get the names...\n\n    Write-Output $names\n}</pre>\nAzure Automationが進化し、Runbook を作成するためのツールセットが拡張および強化されるにつれて、コマンドレットと Runbook に OutputType 定義が含まれると、そのコントラクトに準拠することが重要になります。\n\n<strong>ベスト プラクティス:</strong>  出力を含むコマンドレットと Runbook には、常に OutputType を含める必要があります。\n\n&nbsp;\n<h2>Runbook からの他の Runbook の呼び出し</h2>\nあらゆる種類のコードを作成する際のベスト プラクティスの 1 つは、モジュール化です。個別の再利用可能なコード ユニットを作成します。たとえばAzure Automation、コマンドレットと Runbook 内に自己実装型のタスクを格納し、その機能を必要とする Runbook でこれらのコマンドレットと Runbook を呼び出します。したがって、親 Runbook は、実行されるプロセスの一部として 1 つ以上の子 Runbook を呼び出すのが一般的な方法です。\n\n次の 2 つの方法で子 Runbook を呼び出Azure Automation。\n<ul>\n <li>インラインで呼び出す</li>\n <li>コマンドレットを使用Start-AzureAutomationRunbook開始する</li>\n</ul>\n&nbsp;\n\nサイド ノートとして、親 Runbook から呼び出される子 Runbook には、\"入れ子になった\" または \"子\" という一般的な用語を使用します。PowerShell では、同期的に開始および実行される操作には \"invoke\" という用語が使用され、非同期的に開始および実行される操作には \"start\" という用語が使用されます。この前例に従い、同期および非同期の子 Runbook に対して \"invoke\" と \"start\" という用語をそれぞれ使用します。\n\n&nbsp;\n<h3>Runbook をインラインで呼び出す</h3>\nインラインで呼び出される Runbook は、親 Runbook と同じジョブで実行されます。つまり、親ワークフローは、子 Runbook が完了するまで待機 (同期) してから、プロセスの次の部分に進む必要があります。また、子 Runbook によってスローされた例外と、子 Runbook によって生成されたストリーム出力はすべて、親ジョブに関連付けられるという意味です。したがって、子 Runbook の実行と出力のすべての追跡は、親 Runbook に関連付けられているジョブを介して行います。\n\n子 Runbook がインラインで呼び出される Runbook を開始すると、子 Runbook (およびすべての子孫) は、実行が開始される前に親 Runbook にコンパイルされます。このコンパイル フェーズでは、子 Runbook の名前に対して親 Runbook が解析されます。この解析は、すべての子孫 Runbook を介して再帰的に行います。Runbook の完全な一覧が取得されると、これらの Runbook のスクリプトがストレージから取得され、PowerShell ワークフロー エンジンに渡される 1 つのファイルにアセンブルされます。このため、Runbook ジョブが送信された時点で、親 Runbook と子孫 Runbook は既に発行されている必要があります。そうしないと、コンパイル中に例外が発生します。  <strong>現在、発行の順序も重要です</strong>。最初に子 Runbook を発行してから、親を発行する必要があります。  同様に、Azure Automation 作成ページで親 Runbook をテストする場合は、まず子 Runbook を発行してから、親をテストする必要があります。もう 1 つの結果として、インラインで呼び出される子 Runbook の名前を渡す変数を使用することはできません。親 Runbook 内で子 Runbook に必ず明示的に名前を付けなければならないという結果です。\n\n2 つの子 Runbook をインラインで呼び出す Runbook の例を次に示します。1 つの子 Runbook は出力を返し、もう 1 つの子 Runbook は出力を返します。\n\n&nbsp;\n<pre class=\"prettyprint\">workflow Process-VMs\n{\n    param (\n        [Parameter(Mandatory=$true)]\n        [string]\n        $ScaleUnit\n    )\n\n    # Invoke a child runbook that has a return object\n    $vms = Get-VMs -scaleunit $ScaleUnit\n\n    # Invoke a child runbook that has no return object\n    Do-StuffToVMs -vm $vms\n}</pre>\n&nbsp;\n<h3>Start-AzureAutomationRunbook コマンドレットを使用して Runbook を開始する</h3>\n別のジョブで Runbook を開始するには、Start-AzureAutomationRunbook コマンドレット (Azure PowerShell モジュールの Azure Automation コマンドレットの 1 つで、Azure Automation に事前にインポートされています) を使用します。を使用して子 Runbook を開始Start-AzureAutomationRunbook Runbook に対して新しいジョブが作成されます。\n\nこの方法で子 Runbook が開始された場合、親 Runbook は子 Runbook が完了するまで待機してから続行 (非同期) します。この方法は、親 Runbook がプロセスをスピンオフしてから忘れたい場合に便利です。ただし、システムでジョブを作成するコストが高く、トラブルシューティングが多少複雑な場合があります。また、子 Runbook から出力を取得する必要がある場合にも、より複雑です。\n\n次に示すのは、Start-AzureAutomationRunbook を使用して子 Runbook を開始し、ジョブが完了して出力を取得するまで待機するオプションを提供する <a href=\"https://gallery.technet.microsoft.com/scriptcenter/Start-Azure-Automation-1ac858a9\" target=\"_blank\">Runbook の Start-AutomationChildRunbook</a> のコードです。 この Runbook では、他の Azure Automation コマンドレット (Get-AzureAutomationJob Get-AzureAutomationJobOutput など) も使用します。このユーティリティ Runbook は、子 Runbook を開始するときに Runbook で非常に便利です。子 Runbook を開始し、出力を返すすべての作業をカプセル化します。 このヘルパー <a href=\"https://gallery.technet.microsoft.com/scriptcenter/Start-Azure-Automation-1ac858a9\" target=\"_blank\">Runbook は、スクリプト センターからダウンロード</a> し、一般的に使用Azure Automationアカウントにインポートできます。\n\n&nbsp;\n<pre class=\"prettyprint\">workflow Start-AutomationChildRunbook\n{\n    [OutputType([object])]\n\n    param (\n        [Parameter(Mandatory=$true)]\n        [string] \n        $ChildRunbookName,\n\n        [Parameter(Mandatory=$false)]\n        [hashtable] \n        $ChildRunbookInputParams,\n\n        [Parameter(Mandatory=$true)]\n        [PSCredential] \n        $AzureOrgIdCredential,\n\n [Parameter(Mandatory=$true)]\n [string]\n $AzureSubscriptionName\n\n        [Parameter(Mandatory=$true)]\n        [string] \n        $AutomationAccountName,\n\n        [Parameter(Mandatory=$false)]\n        [boolean] \n        $WaitForJobCompletion = $false,\n\n        [Parameter(Mandatory=$false)]\n        [boolean] \n        $ReturnJobOutput = $false,\n\n        [Parameter(Mandatory=$false)]\n        [int] \n        $JobPollingIntervalInSeconds = 10,\n\n        [Parameter(Mandatory=$false)]\n        [int] \n        $JobPollingTimeoutInSeconds = 600\n    )\n\n   # Determine if parameter values are incompatible\n   if(!$WaitForJobCompletion -and $ReturnJobOutput) {\n       $msg = \"The parameters WaitForJobCompletion and ReturnJobOutput must both \"\n       $msg += \"be true if you want job output returned.\"\n       throw ($msg)\n   }\n\n    # Connect to Azure so that this runbook can call the Azure cmdlets\n    Add-AzureAccount -Credential $AzureOrgIdCredential | Write-Verbose\n\n    # Select the Azure subscription we will be working against\n    Select-AzureSubscription -SubscriptionName $AzureSubscriptionName | Write-Verbose\n\n    # Assure not null for this param\n    if ($ChildRunbookInputParams -eq $null) { $ChildRunbookInputParams = @{} }\n\n    # Start the child runbook and get the job returned\n    $job = Start-AzureAutomationRunbook `\n                -Name $ChildRunbookName `\n                -Parameters $ChildRunbookInputParams `\n                -AutomationAccountName $AutomationAccountName `\n                -ErrorAction \"Stop\"\n    \n    # Determine if there is a job and if the job output is wanted or not\n    if ($job -eq $null) {\n        # No job was created, so throw an exception\n        throw (\"No job was created for runbook: $ChildRunbookName.\")\n    }\n    else {\n        # There is a job\n        \n        # Log the started runbook’s job id for tracking\n        Write-Verbose \"Started runbook: $ChildRunbookName. Job Id: $job.Id\"\n        \n        if (-not $WaitForJobCompletion) {\n            # Don't wait for the job to finish, just return the job id\n            Write-Output $job.Id\n        }\n        else {\n            # Monitor the job until finish or timeout limit has been reached\n            $maxDateTimeout = InlineScript{(Get-Date).AddSeconds($using:JobPollingTimeoutInSeconds)}\n            \n            $doLoop = $true\n            \n            while($doLoop) {\n                Start-Sleep -s $JobPollingIntervalInSeconds\n                \n                $job = Get-AzureAutomationJob `\n                    -Id $job.Id `\n                    -AutomationAccountName $AutomationAccountName\n                \n                if ($maxDateTimeout -lt (Get-Date)) {\n                    # timeout limit reached so exception\n                    $msg = \"The job for runbook $ChildRunbookName did not \"\n                    $msg += \"complete within the timeout limit of \"\n                    $msg += \"$JobPollingTimeoutInSeconds seconds, so polling \"\n                    $msg += \"for job completion was halted. The job will \"\n                    $msg += \"continue running, but no job output will be returned.\"\n                    throw ($msg)\n                }\n                \n                $doLoop = (($job.Status -notmatch \"Completed\") `\n                          -and ($job.Status -notmatch \"Failed\") `\n                          -and ($job.Status -notmatch \"Suspended\") `\n                          -and ($job.Status -notmatch \"Stopped\"))\n            }\n            \n            if ($job.Status -match \"Completed\") {\n                if ($ReturnJobOutput) {\n                    # Output\n                    $jobout = Get-AzureAutomationJobOutput `\n                                    -Id $job.Id `\n                                    -AutomationAccountName $AutomationAccountName `\n                                    -Stream Output\n                    if ($jobout) {Write-Output $jobout.Text}\n                    \n                    # Error\n                    $jobout = Get-AzureAutomationJobOutput `\n                                    -Id $job.Id `\n                                    -AutomationAccountName $AutomationAccountName `\n                                    -Stream Error\n                    if ($jobout) {Write-Error $jobout.Text}\n                    \n                    # Warning\n                    $jobout = Get-AzureAutomationJobOutput `\n                                    -Id $job.Id `\n                                    -AutomationAccountName $AutomationAccountName `\n                                    -Stream Warning\n                    if ($jobout) {Write-Warning $jobout.Text}\n                    \n                    # Verbose\n                    $jobout = Get-AzureAutomationJobOutput `\n                                    -Id $job.Id `\n                                    -AutomationAccountName $AutomationAccountName `\n                                    -Stream Verbose\n                    if ($jobout) {Write-Verbose $jobout.Text}\n                }\n                else {\n                    # Return the job id\n                    Write-Output $job.Id\n                }\n            }\n            else {\n                # The job did not complete successfully, so throw an exception\n                $msg = \"The child runbook job did not complete successfully.\"\n                $msg += \"  Job Status: \" + $job.Status + \".\"\n                $msg += \"  Runbook: \" + $ChildRunbookName + \".\"\n                $msg += \"  Job Id: \" + $job.Id + \".\"\n                $msg += \"  Job Exception: \" + $job.Exception\n                throw ($msg)\n            }\n        }\n    }\n}</pre>\n&nbsp;\n\nを使用して子 Runbook を開始Start-AzureAutomationRunbook戻り値は Job オブジェクトです。子 Runbook からデータを返す場合は、ジョブの完了を確認するためにジョブを監視し、出力を抽出する必要があります。上記の Runbook の例では、Get-AzureAutomationJob コマンドレットと Get-AzureAutomationJobOutput コマンドレットを使用してジョブを監視し、子 Runbook ジョブから出力を取得する方法を確認できます。予期した時間内にジョブが完了しない場合にループからの終了を保証するために、タイムアウト要因が含まれています。また、複数の子ジョブを開始した場合、システムはジョブの開始順序を保証しない点にも注意してください。\n\n&nbsp;\n<h2>インラインで呼び出される子 Runbook と、呼び出された子 Runbook のStart-AzureAutomationRunbook</h2>\n<h3></h3>\n<h3>インラインで呼び出される</h3>\n<ul>\n <li>Pro\n<ul>\n <li>親 Runbook と子 Runbook は同じジョブで実行されます。そのため、システム内のジョブが少ないので、ジョブの追跡が容易になります。</li>\n <li>親 Runbook は、子 Runbook が完了するまで待機してから続行し、親 Runbook は子から任意の戻りデータを直接取得できます。</li>\n <li>子 Runbook によってスローされた例外と、子によって生成されたストリーム出力は親ジョブに関連付けられているため、調査するジョブは 1 つしかないので、トラブルシューティングが容易になります。</li>\n <li>Runbook の入力パラメーターには、プリミティブから複合まで、任意の型を指定できます。</li>\n <li>子 Runbook は親と同じジョブで実行されているので、1 つのジョブのランタイムに対して課金されます。</li>\n</ul>\n</li>\n <li>短所\n<ul>\n <li>親 Runbook は、子 Runbook が完了するまで待機する必要があります。この場合、親 Runbook が完了するまでの全体的な時間が長くなる可能性があります。</li>\n <li>インライン子 Runbook の名前を渡す場合、親 Runbook で変数またはパラメーターを使用することはできません。</li>\n <li>親 Runbook を発行する前に、子 Runbook を発行する必要があります。</li>\n <li>親 Runbook と子 Runbook は、同じ Automation アカウントに含む必要があります。</li>\n</ul>\n</li>\n</ul>\n&nbsp;\n<h3>Start-AzureAutomationRunbook</h3>\n<ul>\n <li>Pro\n<ul>\n <li>親 Runbook と子 Runbook は異なるジョブで実行されます。これにより、親は並列で実行できる複数のジョブをスピンオフできます。</li>\n <li>親 Runbook は子 Runbook を待機しないので、子 Runbook の実行中に処理を続行できます。</li>\n <li>親 Runbook でパラメーターまたは変数を使用して、呼び出す Runbook の名前を渡します。</li>\n <li>その Azure サブスクリプションへの Automation 接続資産がある限り、同じサブスクリプション内の異なる Automation アカウント、および異なる Azure サブスクリプションに格納されている Runbook を開始できます。</li>\n</ul>\n</li>\n <li>短所\n<ul>\n <li>親 Runbook と子 Runbook は異なるジョブで実行されます。そのため、例外とストリーム出力は個別に格納され、個別に追跡する必要があります。そのため、トラブルシューティングが困難になる可能性があります。</li>\n <li>より多くのジョブがシステムに作成され、ジョブが開始前にキューで待機する時間が長くなる可能性があります。</li>\n <li>子 Runbook ジョブから返されるデータの取得は簡単ではありません。</li>\n <li>Runbook Start-AzureAutomationRunbookを開始し、その Runbook が完了するまで待機して出力を取得すると、両方の Runbook の実行時間に対して課金されます。しかし、Start を使用する場合はそうではありません</li>\n <li>AzureAutomationRunbook を使用して Runbook を開始し、ジョブ ID をすぐに返します。</li>\n <li>Runbook の入力パラメーターは、プリミティブ型、配列、およびオブジェクトに制限されています。これは、Web サービスを介した呼び出しで発生するオブジェクトの JSON シリアル化を存続する必要があります。</li>\n</ul>\n</li>\n</ul>\n&nbsp;\n<h2>まとめ</h2>\nAzure Automationは、PowerShell ワークフロー エンジンの多くの有益な機能を利用する Runbook を作成できる便利なツールです。Azure Automation と PowerShell ワークフローの内部動作の一部といくつかのベスト プラクティスを理解すると、高品質で信頼性が高く、保守容易な Runbook を作成できます。\n\nこの投稿では、入力パラメーターの定義、Runbook 出力の定義、および子 Runbook の呼び出しに関するベスト プラクティスについて説明しました。情報を読み取ったので、サンプルを使用して Azure Automation でいくつかの簡単な Runbook を試して、Runbook と自動化の機能を自分で確認します。読んでいて、この新しい知識を実践して、Azure リソースの管理をより簡単で、より予測可能で、信頼性を高め、楽しく過ごしてください。\n\nまだAzure Automationユーザーではありませんか? <a href=\"https://account.windowsazure.com/PreviewFeatures?fid=automation\" target=\"_blank\">プレビューにサインアップし</a> 、次のガイド <a href=\"https://azure.microsoft.com/en-us/documentation/articles/automation-create-runbook-from-samples/\" target=\"_blank\">はじめにしてください</a>。"
