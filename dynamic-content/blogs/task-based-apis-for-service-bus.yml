### YamlMime:Yaml
ms.openlocfilehash: e474692f1457a5e04dccce55e8a918ed8b9146e2
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139891983"
Slug: task-based-apis-for-service-bus
Title: タスク ベースの api for Service Bus
Summary: '編集者注: この投稿は、Azure Service Bus Team の開発者 Scott Seely 氏Windows投稿です。  最近、新しいバージョンの Azure Windows Client SDK をService BusしてリリースNuGet。 現在は。。。'
Content: '<p><strong>エディターの注: </strong>この投稿は、Azure Service Bus Team の開発者である Scott Seely Windows提供しています。</p>  <p>最近、新しいバージョンの Azure Windows Client SDK をService BusしてリリースNuGet。 現在、v2.0.0-beta としてマークされている SDK API は、すべての非同期 API の System.Threading.Tasks.Task ベースのバージョンを提供するために改善されています。 つまり、単なる事的な人が読み取り可能な非同期コードを記述できます。 どのクラスが治療を受けたかについて興味がある場合は、答えは単純です。すべてを更新しました。 Begin/End ペアを見た場所に、非同期バージョンの メソッドも表示されます。 更新された SDK は .NET 4.0 に対してコンパイルされます。そのため、Visual Studio 2010 および Visual Studio 2012 で動作します。</p>  <p>この短い投稿では、いくつかの基本的なことを説明します。</p>  <ol>  <li>SDK を取得する方法</li>  <li>Async/await で SDK を使用する方法</li>  <li>タスクで例外が発生した場合について少し話します</li>  </ol>  <p>SDK のユーザーにとって大きな問題は、非同期で読み取り可能なコードを sdk で記述Service Busです。</p>  <h4>ベータ SDK の取得</h4>  <p>現在、2.0 SDK は最終的な製品とは見なされません。 しかし、Windows Azure Service Bus のアプリケーションを使用してビルドする場合に、現在プロジェクトで使用できる多くのことが含まれています。 パッケージは、NuGet 経由でのみ使用できます。 このパッケージをプロジェクトに追加するには、次の 2 つの方法のいずれかを実行します。</p>  <ol>  <li>次の手順で NuGet GUI を使用してインストールVisual Studio</li>  <li>コンソールの パッケージ マネージャー を使用してインストールVisual Studio</li>  </ol>  <p>これらの手順では、プロジェクトが Visual Studio で開かService Bus SDK をそのプロジェクトに追加する必要があります。 マウスが好きなユーザーの場合は、プロジェクト ノード&lsquo;または [参照] ノードを右クリックし、[ パッケージの管理] <em>NuGet選択します&hellip;&rsquo;</em>。 [プレリリースを含める] <em>(既定値は</em> [安定のみ]) が選択 <em>済みである必要があります</em>。 次に、 <em>servicebus を検索します</em>。 [Windows Azure Service Bus] を選択し、[インストール] を<em>クリックします</em>。</p>  <p><img src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/8156.taskbase.png" alt="" border="0"></p>  <p>パッケージ マネージャー <em>コンソール</em> (<em>ViewOther</em>&agrave; <em>Windows</em>&agrave;<em>パッケージ マネージャー Console</em> から使用できます)、次のように入力して新しいビットをインストールできます。</p>  <p>Install-Package -Id WindowsAzure.ServiceBus &ndash;IncludePrerelease</p>  <p>-IncludePrelease フラグを必ず含めるか、タスク ベースの API でバージョンを取得できません。</p>  <h4>Async/await で SDK を使用する方法</h4>  <p>Microsoft.ServiceBus.NamespaceManager&rsquo; と Microsoft.ServiceBus.Messaging.QueueClient を使用する単純なメソッドを記述します。 キュー&rsquo;が存在するかどうかを確認し、キューが存在しない場合はキューを作成します。 次に、&rsquo;キューからメッセージを送受信します。 その&rsquo;通り、Hello&rsquo;<em>, World Service Busを記述します</em>。 単純な非同期プログラミング&rsquo;の利点の一部を示すには、メッセージが送信された約 5 秒後に配信されます。 コード内のコメントは、何が起こっているのかを説明しています。</p>  <p><img src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2500.Screen-Shot-2013_2D00_04_2D00_11-at-12.13.12-PM.png" alt="" border="0"></p>  <p>ここで確認できるのは、送受信の完了を待っている間に約 9 秒待ったという点です。 その間、クライアントは、メッセージが表示され、戻るのを待つのではなく、CPU で他の操作を行う可能性があります。 非同期コードが同期コードと同じほど読みやすくなっているのも確認できます。 非同期プログラミング モデル のコードが既存のキューを確認するだけの方法の例については、次を参照してください。</p>  <p><img src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/7345.Screen-Shot-2013_2D00_04_2D00_11-at-12.13.54-PM.png" alt="" border="0"></p>  <h4>例外と明示的なタスクの使用</h4>  <p>非同期プログラミング モデル (すべての Begin/End ペア) の既存のユーザーは、Begin メソッドがパラメーター検証を実行する場合があります。 パラメーターに問題がある場合は、例外がスローされる可能性があります。 処理が完了すると、他のエラーが発生した可能性があります。 このような状況のため、Begin メソッドと End メソッドの両方で例外をキャッチする必要がありました。 開発を簡略化するために、タスクが完了した場合にのみすべての例外がスローされるのを選択しました。 これはユーザーにとって何を意味しますか? つまり、2 つ以上ではなく、1 つの場所で例外をキャッチします。 たとえば、非同期プログラミング モデルで次のようなコードがある場合は、次のようになります。</p>  <p><img src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/8105.Screen-Shot-2013_2D00_04_2D00_11-at-12.14.32-PM.png" alt="" border="0"></p>  <p>タスク ベースの API を使用すると、ContinueWith ブロック内のすべての例外を処理するためにコードが変更されます。</p>  <p><img src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/6574.Screen-Shot-2013_2D00_04_2D00_11-at-12.15.09-PM.png" alt="" border="0"></p>  <p>または、タスクを保持し、完了するまで待つ場合があります。その場合、コードは次の状態になります。</p>  <p><img src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/5621.Screen-Shot-2013_2D00_04_2D00_11-at-12.15.50-PM.png" alt="" border="0"></p>  <p>幸せなパスに従う場合、同等の async/await 例外処理コードは、読み取り (および書き込み) がより簡単になります。</p>  <p><img src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/8764.Screen-Shot-2013_2D00_04_2D00_11-at-12.16.20-PM.png" alt="" border="0"></p>  <h4>閉じる単語</h4>  <p>これは、お客様に提供できる機能です。 開発がはるかに簡単になり、チームの誰もが自分のチームと一緒に作業する必要がある人に笑顔Service Bus。&nbsp;</p>'
