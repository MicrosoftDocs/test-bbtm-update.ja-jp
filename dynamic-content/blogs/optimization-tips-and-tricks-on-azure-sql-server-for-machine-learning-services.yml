### YamlMime:Yaml
ms.openlocfilehash: c58b3eb6c4263013ce72a9244281d6a8aef94d98
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139890078"
Slug: optimization-tips-and-tricks-on-azure-sql-server-for-machine-learning-services
Title: azure SQL Server for Machine Learning Services の最適化に関するヒントとテクニック
Summary: 2016 SQL Server、R Services という新しい関数が導入されました。 Microsoft は最近、Python に高度な分析機能を拡張する SQL Server の次のバージョンのプレビューを発表しました。 R または Python を大規模にデータベース内で実行するこの新しい機能を使用すると、分析サービスをデータの近くに保持し、データ移動の負担を排除できます。
Content: >-
  <h1>まとめ</h1>


  <p>2016 SQL Server、R Services という新しい関数が導入されました。 Microsoft は<a href="https://blogs.technet.microsoft.com/dataplatforminsider/2017/04/19/sql-server-2017-community-technology-preview-2-0-now-available/" target="_blank">最近、高度な分析</a>機能を Python に拡張する SQL Server の次のバージョンのプレビューを発表しました。 R または Python を大規模にデータベース内で実行するこの新しい機能を使用すると、分析サービスをデータの近くに保持し、データ移動の負担を排除できます。 また、インテリジェント アプリケーションの開発とデプロイも簡素化されます。 SQL サーバーを活用するには、インテリジェンス モデル自体を微調整する方法を知っているのは十分ではありません。パフォーマンス要件を満たしていまだに失敗する場合もあります。 パフォーマンスを大幅に向上させるのに役立つ最適化のヒントとテクニックが非常に多くある。 この投稿では、再開照合シナリオにいくつかの最適化手法を適用します。これは、大量の予測のワークフローを模倣し、それらの手法によってデータ分析をより効率的かつ強力にする方法を示します。 このブログで紹介する 3 つの主な最適化手法は次のとおりです。</p>


  <ul>
   <li>完全な永続メモリ最適化テーブル</li>
   <li>CPU アフィニティとメモリ割り当て</li>
   <li>リソース ガバナンスと同時実行</li>
  </ul>


  <p>このブログ投稿では、上記の最適化のヒントとテクニックが Azure 上の R Services でどのように機能SQL Server。 これらの最適化手法は、R Services だけでなく、R Services と統合Machine LearningサービスにもSQL Server。 サンプル コードと <a href="https://gallery.cortanaintelligence.com/Tutorial/SQL-Server-Optimization-Tips-and-Tricks-for-Analytics-Services" target="_blank">詳細な</a> チュートリアルについては、完全なチュートリアルを参照してください。</p>


  <h1>サンプルの使用例の説明</h1>


  <p>このブログと関連するチュートリアルの両方のサンプル の使用例は、再開一致の例です。 職位に最適な候補を見つけることは、長い間、労力を要し、検索エージェントからの多くの手動作業を必要とするアートでした。 さまざまなソースから収集された大量の情報から、特定の技術的または特殊な品質を持つ候補を見つける方法は、新しい大きな課題となっています。 何百万もの履歴書の中で良い一致を検索して、指定の位置を検索するモデルを開発しました。 二項分類の問題として作成される機械学習モデルは、再開とジョブの説明の両方を入力として受け取り、各再開ジョブ ペアに対して一致する確率を生成します。 その後、ユーザー定義の確率しきい値を使用して、すべての良い一致をさらにフィルターでフィルター処理します。</p>


  <p>この使用例の重要な課題は、新しいジョブごとに、妥当な時間内に何百万もの再開と一致する必要があるという点です。 何千もの機能 (この場合は 2600) を生成する特徴エンジニアリング ステップは、スコアリング中のパフォーマンスのボトルネックとして大きくなっています。 そのため、この使用例では、低い照合 (スコア付け) 待機時間を実現する方法が主な目的です。</p>


  <h1>最適化</h1>


  <p>最適化手法にはさまざまな種類があります。再開照合シナリオを使用して、そのいくつかについて説明します。 このブログでは、これらの最適化手法が高いレベルから動作する理由と方法について説明します。 詳細な説明と背景知識については、付属のリファレンス リンクを参照してください。 このチュートリアル<a href="https://gallery.cortanaintelligence.com/Tutorial/SQL-Server-Optimization-Tips-and-Tricks-for-Analytics-Services" target="_blank">では</a>、同様のハードウェア構成と新しいスクリプトを使用して、結果が再現可能SQLされます。</p>


  <h2>メモリ最適化テーブル</h2>


  <p>今日では、サイズと速度の観点から、メモリは最新のマシンでは問題ではなくなりました。 ユーザーは、ハードウェア &lsquo;の進歩に合って RAM&rsquo; の価値を得る可能性があります。 その間、データはこれまでよりもはるかに迅速に生成され、一部のタスクでは待機時間の短いデータを処理する必要があります。 メモリ最適化テーブルでは、ハードウェアの進歩を利用してこの問題に取り組む可能性があります。 メモリ最適化テーブルは主にメモリ内に存在し、データの読み取りおよびメモリへの書き込み [1] を行います。 ただし、耐久性のために、テーブルの 2 番目のコピーはディスク上に保持され、データはデータベースの回復中にのみディスクから読み取まれます。 パフォーマンスは、特にテーブルの読み取り/書き込みを頻繁に行う必要がある場合に、メモリを使用して高いスケーラビリティと低待機時間で最適化できます [2]。 メモリ最適化テーブルの詳細な概要については、このブログ <a href="https://docs.microsoft.com/en-us/sql/relational-databases/in-memory-oltp/introduction-to-memory-optimized-tables" target="_blank">[1] を参照してください</a>。 また、このビデオ <a href="https://www.youtube.com/watch?v=l5l5eophmK4" target="_blank">[3]</a> を見て、OLTP を使用するパフォーマンス上の利点In-Memory確認できます。</p>


  <p>再開一致のシナリオでは、データベースからすべての再開機能を読み取り、そのすべてと新しいジョブの開始を照合する必要があります。 メモリ最適化テーブルを使用すると、再開機能がメイン メモリに格納され、ディスク IO が大幅に削減される可能性があります。 さらに、さまざまなバッチから同時にすべての予測をデータベースに書き戻す必要があります。また、メモリ最適化テーブルを使用することで、パフォーマンスの向上を実現できます。 SQL Server でのメモリ最適化テーブルのサポートにより、テーブルへの読み取り/書き込み時の待機時間が短く、開発中のシームレスなエクスペリエンスを実現しました。 完全な永続メモリ最適化テーブルが、データベースの作成と共に作成されました。 開発の残りの部分は、データが格納されている場所を知らなくても、以前とまったく同じです。</p>


  <h2>CPU アフィニティとメモリ割り当て</h2>


  <p>SQL Server 2014 SP2 以降のバージョンでは、SQL Server サービス [4, 5, 6] を開始すると、データベース インスタンス レベルでソフト NUMA が自動的に有効になります。 データベース エンジン サーバーが NUMA ノードまたはソケットごとに 8 つ以上の物理コアを検出すると、理想的には 8 コアを含むソフト NUMA ノードが自動的に作成されます。 ただし、ノードあたり最大 5 つ、または最大 9 つの論理コアまで下がる可能性があります。 ログ情報は、各ソケットで 8 SQL Serverを検出すると確認できます。</p>


  <p><img alt="SQL log of auto Soft-NUMA" border="0" height="97" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/b9bda84d-47b1-4939-94af-d4ca8559ca8c.png" style="border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="SQL Soft-NUMA のログ" width="891"></p>


  <p align="center"><strong>図 1: SQL</strong>ソフト NUMA のログを作成し、4 つのソフト NUMA ノードが作成された</p>


  <p>図 1 に示すように、テストは 20 の物理コアで構成され、各ノードに 5 コアが含まれる 4 つのソフト NUMA ノードが自動的に作成されました。 ソフト NUMA を使用すると、ノードごとにサービス スレッドをパーティション分割できます。これにより、一般に、IO と遅延ライターのボトルネックを減らすことでスケーラビリティとパフォーマンスが向上します。 さらに、4 つのリソース SQL と 4 つの外部リソース プール [7] を作成し、各ノードで同じ CPU セットを使用する CPU アフィニティを指定しました。 これにより、プロセスが同SQL Server NUMA ノード内に含まれるので、このプロセスと R プロセスの両方で外部メモリ アクセスを排除できます。 そのため、メモリ アクセスの待機時間が短縮される可能性があります。 その後、これらのリソース プールをさまざまなワークロード グループに割り当て、ハードウェア リソースの消費を強化します。</p>


  <p>ソフト NUMA と CPU アフィニティでは、各物理 NUMA ノードで物理メモリを分割できません。 同じ物理 NUMA ノード内のすべてのソフト NUMA ノードは、同じ OS メモリ ブロックからメモリを受け取り、メモリとプロセッサのアフィニティはありません。 ただし、メモリと R プロセスの間のメモリSQL Server注意する必要があります。 既定では、R サービスに割り当てられるメモリの 20% だけが、ほとんどのデータ分析タスクでは十分ではありません。 詳細については <a href="https://docs.microsoft.com/en-us/sql/advanced-analytics/r/how-to-create-a-resource-pool-for-r" target="_blank">、「方法: R のリソース プールを作成する [7]</a> 」を参照してください。 これらの 2 つの間のメモリ割り当てを微調整する必要があります。もちろん、最適な構成はケースによって異なります。 再開照合の使用例では、外部メモリ リソースの割り当てを 70% に増やしました。これは最適な構成でした。</p>


  <h2>リソース ガバナンスと同時スコアリング</h2>


  <p>スコアリングの問題をスケールアップするには、数百万の履歴書を複数のバッチに分割し、複数のスコアリングを同時に実行する map-reduce アプローチを採用する方法をお使いください。 並列処理フレームワークを図 2 に示します。</p>


  <p><img alt="Parallel processing" border="0" height="262" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/d6e2a8aa-61c1-4bad-9064-56d2aaab0522.png" style="border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="並列処理" width="610"></p>


  <p align="center"><strong>図 2:</strong> 複数のバッチでの並列処理の図</p>


  <p>これらのバッチは異なる CPU セットで処理され、結果が収集され、データベースに書き戻されます。 リソース ガバナンスはSQL Serverこのアイデアを実装するように設計されています。 R サービスのリソース ガバナンスを SQL Server [8] で作成するには、それらのスコアリング バッチを異なるワークロード グループにルーティングします (図。 3). リソース ガバナーの詳細については、このブログ <a href="https://docs.microsoft.com/en-us/sql/relational-databases/resource-governor/resource-governor" target="_blank">[9] を参照してください</a>。</p>


  <p><img alt="Resource governer" border="0" height="522" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/234f97ea-43af-471e-932c-7df682979e70.gif" style="border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="リソース 管理者" width="452"></p>


  <p align="center"><strong>図 3:</strong> リソース ガバナー (<em>提供: <a href="https://docs.microsoft.com/en-us/sql/relational-databases/resource-governor/resource-governor" target="_blank">https://docs.microsoft.com/en-us/sql/relational-databases/resource-governor/resource-governor</a></em>)</p>


  <p>リソース ガバナーは、SQL Server で使用可能なリソース (CPU とメモリ) を分割し、分類子関数 [10, 11] を使用してワークロードの競合を最小限に抑えるのに役立ちます。 実行を改善し、予測可能なパフォーマンスを提供SQL Serverタスクに対して、マルチテナントとリソースの分離を提供します。</p>


  <h2>その他のテクニック</h2>


  <p>R の 1 つの問題は、特徴エンジニアリングを実施すると、通常は 1 つの CPU で処理される点です。 これは、ほとんどのデータ分析タスクのパフォーマンス上の大きなボトルネックです。 履歴書照合の使用例では、2,500 の製品間機能を生成する必要があります。その後、元の 100 の機能と組み合わせる必要があります (図 4)。 1 つの CPU ですべてが行われた場合、このプロセス全体にかなりの時間が必要になります。</p>


  <p><img alt="Feature engineering" border="0" height="275" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/60dbc136-0d96-44a3-9b2f-4403263ca6bc.png" style="border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="機能エンジニアリング" width="610"></p>


  <p align="center"><strong>図 4:</strong> 履歴書照合の使用例の特徴エンジニアリング</p>


  <p>ここでの 1 つのコツは、特徴エンジニアリング用の R 関数を作成し、トレーニング中に <em><strong>rxTransform</strong></em> 関数として渡す方法です。 機械学習アルゴリズムは、並列処理を使用して実装されます。 トレーニングの一環として、特徴エンジニアリングは複数の CPU でも処理されます。 トレーニングとスコア付け前に特徴エンジニアリングを実行する通常のアプローチと比較して、スコアリング時間の観点から <strong>パフォーマンスが 16%</strong> 向上しました。</p>


  <p>パフォーマンスを向上させるもう 1 つの方法は、R [12] 内SQLコンテキストを使用する方法です。 バッチ実行ごとにリソースが分離されたので、バッチごとにSQLクエリも分離する必要があります。 コンピューティング コンテキストSQL使用することで、SQL クエリを並列化してテーブルからデータを抽出し、同じワークロード グループ上のデータを制約できます。</p>


  <h1>結果と結論</h1>


  <p>これらのヒントとテクニックを完全に説明するために、非常に詳細なステップ バイ ステップ チュートリアルを公開 <a href="https://gallery.cortanaintelligence.com/Tutorial/SQL-Server-Optimization-Tips-and-Tricks-for-Analytics-Services" target="_blank">しました</a>。 110 万行のデータをスコア付けするベンチマーク テストもいくつか実施されました。 <strong><em>RevoScaleR</em></strong> パッケージと MicrosoftML パッケージの両方を<strong><em>使用して</em></strong>、予測モデルを個別にトレーニングしました。 その後、これらの最適化を使用する場合と最適化を使用しない場合のスコアリング時間を比較しました。 図 5 と図 6 は、RevoScaleR パッケージと MicrosoftML パッケージを使用した最適なパフォーマンス結果をまとめたものにしています。 テストは、同じクエリと R コードをSQL Server同じ Azure SQL VM で実行されました。 1 つの一致するジョブに対して 8 つのバッチがすべてのテストで使用されました。</p>


  <p><img alt="RevoScaleR results" border="0" height="288" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/63e281b3-76aa-40f8-9acd-6d31a332c0e1.png" style="border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="RevoScaleR の結果" width="480"></p>


  <p align="center"><strong>図 5:</strong> RevoScaleR スコアリングの結果</p>


  <p><img alt="MicrosoftML results" border="0" height="288" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/d98ad558-6fc9-44a5-a5ff-fd0d4f399508.png" style="border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="MicrosoftML の結果" width="480"></p>


  <p align="center"><strong>図 6:</strong> MicrosoftML スコアリングの結果</p>


  <p>結果は、特徴の数がスコアリング時間に大きな影響を与えたことを示しました。 また、これらの最適化のヒントとテクニックを使用すると、スコアリング時間の観点からパフォーマンスが大幅に向上する可能性があります。 予測モデルで使用される特徴が多い場合、改善はさらに顕著でした。</p>


  <h1>Acknowledgement</h1>


  <p>最後に、このブログの投稿に付随する優良なディスカッション、プアリン リン、Katherine Lin、および Chenyu Chen に感謝します。このブログに付随するチュートリアルには、Umachanran  、Amit Banerjee、Ramvanr Chandrasekaran、Wee Hyong Tok、Wee Hyong Tok、Wee Hyong Xue、James Ren、Lixin 、 Ivan Popivanov、Costin Eseanu、Katherine Lin、および Chenyu Chen に感謝します。</p>


  <h1>リファレンス</h1>


  <p><br>

  [1] <a href="https://docs.microsoft.com/en-us/sql/relational-databases/in-memory-oltp/introduction-to-memory-optimized-tables" target="_blank">テーブルのMemory-Optimized概要</a></p>


  <p>[2] <a href="https://docs.microsoft.com/en-us/sql/relational-databases/in-memory-oltp/demonstration-performance-improvement-of-in-memory-oltp" target="_blank">デモンストレーション: OLTP のIn-Memory向上</a></p>


  <p>[3] OLTP の機能とパフォーマンス<a href="https://www.youtube.com/watch?v=l5l5eophmK4" target="_blank">のIn-Memory示す 17</a> 分間のビデオ</p>


  <p>[4] <a href="https://technet.microsoft.com/en-us/library/ms178144(v=sql.105).aspx" target="_blank">非一様メモリ アクセスについて</a></p>


  <p>[5] <a href="https://technet.microsoft.com/en-us/library/ms180954(v=sql.105).aspx" target="_blank">NUMA SQL Serverサポートする方法</a></p>


  <p>[6] <a href="https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/soft-numa-sql-server" target="_blank">ソフト NUMA (SQL Server)</a></p>


  <p>[7] <a href="https://docs.microsoft.com/en-us/sql/advanced-analytics/r/how-to-create-a-resource-pool-for-r" target="_blank">方法: R 用のリソース プールを作成する</a></p>


  <p>[8] <a href="https://docs.microsoft.com/en-us/sql/advanced-analytics/r/resource-governance-for-r-services" target="_blank">R Services のリソース ガバナンス</a></p>


  <p>[9] <a href="https://docs.microsoft.com/en-us/sql/relational-databases/resource-governor/resource-governor" target="_blank">Resource Governor</a></p>


  <p>[10] <a href="https://technet.microsoft.com/en-us/library/bb895232(v=sql.105).aspx" target="_blank">Resource Governor</a></p>


  <p>[11] <a href="https://blog.sqlauthority.com/2012/06/04/sql-server-simple-example-to-configure-resource-governor-introduction-to-resource-governor/" target="_blank">SQL SERVER &ndash; Simple Example to Configure Resource Governor &ndash; Introduction to Resource Governor</a></p>


  <p>[12] <a href="https://docs.microsoft.com/en-us/sql/advanced-analytics/tutorials/deepdive-define-and-use-compute-contexts" target="_blank">コンピューティング コンテキストの定義と使用</a></p>
