### YamlMime:Yaml
ms.openlocfilehash: 1dba1012fea22d763bb006eb479f7ef7f318f75c
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139894928"
Slug: an-end-to-end-prototype-of-playready-protection-with-acs-authentication-and-acs-token-authorization
Title: ACS 認証と ACS トークン承認を使用した PlayReady Protection のエンドツーエンドプロトタイプ
Summary: Azure Media Services の動的 PlayReady 保護機能により、"ワンクリック DRM" が現実になります。
Content: "&nbsp;\n<h1>はじめに</h1>\nこのエンドツーエンドのプロトタイプは、アジアとヨーロッパの顧客からの要求に応じて行いました。\n\n<a href=\"https://azure.microsoft.com/blog/2014/09/10/announcing-public-availability-of-azure-media-services-content-protection-services/\">Azure Media Services Content Protection</a>には、次の情報が含まれます。\n<ul>\n <li>PlayReady ライセンス配信サービス</li>\n <li>AES 128 クリア キー配信サービス。</li>\n <li>配信時間中の動的 PlayReady 保護または AES 暗号化。</li>\n <li>メディア処理ワークフローでの静的 PlayReady 保護または AES 暗号化。</li>\n</ul>\nAzure Media Services の動的 PlayReady 保護機能を使用すると、\"ワンクリック DRM\" が実現されます。顧客またはパートナーは、\"従来の DRM\" で必要な次の手順を実行する必要はありません。\n<ol>\n <li>Secure PlayReady サーバー ライセンス、</li>\n <li>PlayReady ライセンス サーバー ファームを立ち上げ、</li>\n <li>PlayReady パッケージ化ワークフローを実行して資産を保護します。</li>\n</ol>\n\"シングル クリック\" で資産を保護または保護解除できます。これは、Web ページの更新の速度で行われます。\n\n通常、DRM ソリューションには複数の構成要素が含まれます。次のブログでは、DRM ソリューションの構成要素の概要を示します。「<a href=\"https://blogs.msdn.com/b/playready4/archive/2014/08/18/solution-design-considerations-in-using-playready-license-delivery-service-of-azure-media-services.aspx\">Azure Media Services の PlayReady ライセンス</a>配信サービスの使用に関するソリューション設計上の考慮事項」。 この取り組みの目的は、完全なエンドツーエンドのプロトタイプが望ましいことです。\n\n&nbsp;\n<h2><span style=\"font-size: xx-large\">エンド to エンド プロトタイプ</span></h2>\n<h2>設計と機能</h2>\nこの取り組みの目的は、以下をカバーするエンドツーエンドのプロトタイプを提供する方法です。\n<ul>\n <li>AMS での資産のトークン制限を使用した PlayReady 動的保護 (または静的保護)。</li>\n <li>Azure Media Services PlayReady ライセンスを配信するライセンス配信サービス。</li>\n <li><a href=\"https://msdn.microsoft.com/en-us/library/azure/hh147631.aspx\">SWT</a> 承認トークンMicrosoft Azure Active Directory Access Control発行する STS としての Azure ACS (Microsoft Azure Active Directory Access Control)</li>\n <li>Silverlight プレーヤー\n<ol>\n <li>は ACS サービス ID によって認証されます。</li>\n <li>ACS から承認トークンを取得します。</li>\n <li>ACS トークンを使用して AMS ライセンス配信サービスから PlayReady ライセンスを取得します。</li>\n <li>は、Smooth Streamingビデオ再生のために、MPEG-DASH アセットをダウンロードします。</li>\n</ol>\n</li>\n</ul>\nSilverlight プレーヤーを使用する理由は次のとおりです。\n<ol>\n <li>IE、Chrome、Firefox などの一般的なブラウザーからプレーヤーにアクセス可能にするには、</li>\n <li><a href=\"https://www.microsoft.com/en-us/download/details.aspx?id=42080\" target=\"_blank\">Smooth Streamingクライアント v2.5</a> には、PlayReady クライアント ライセンスを必要としない PlayReady クライアント サポートが付属しています。</li>\n <li><a href=\"https://www.microsoft.com/en-us/download/details.aspx?id=42080\" target=\"_blank\">Smooth Streaming Client v2.5</a> では MPEG-DASH もサポートされます。 このエンドツーエンドプロトタイプは、スムーズ ストリーミングに加えて MPEG-DASH をカバーします。</li>\n</ol>\n&nbsp;\n\nこのエンドツーエンドプロトタイプの設計を次の図に示します。 これは、Azure Media Services の <a href=\"https://blogs.msdn.com/b/playready4/archive/2014/08/18/solution-design-considerations-in-using-playready-license-delivery-service-of-azure-media-services.aspx\">PlayReady ライセンス</a>配信サービスの使用に関する記事のブログ「ソリューション設計に関する考慮事項」で説明されている一般的な DRM ソリューション図の特殊化です。\n\n&nbsp;\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/11/14/Blog_Secure_Delivery_Prototype.jpg\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"Blog_Secure_Delivery_Prototype\" alt=\"Blog_Secure_Delivery_Prototype\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/Blog_Secure_Delivery_Prototype_thumb.jpg\" width=\"636\" height=\"473\" border=\"0\" /></a>\n\n&nbsp;\n\nエンドツーエンドのプロトタイプは、Azure でホストされ、Azure Media Services。 プロトタイプに関連する情報を次に示します。\n<ul>\n <li>PlayReady 動的保護下のスムーズ ストリーミング資産の URL。</li>\n <li>PlayReady 動的保護下の MPEG-DASH 資産の URL。</li>\n <li><a href=\"https://willzhanmediaservice.keydelivery.mediaservices.windows.net/PlayReady/\" target=\"_blank\">PlayReady ライセンス取得の URL</a>。</li>\n <li>PlayReady ライセンスの種類: 非永続的 (任意の時間枠内でテストを任意の回数繰り返し実行できます)</li>\n <li><a href=\"https://willzhanacs.accesscontrol.windows.net\" target=\"_blank\">SWT 承認トークンを発行する Azure ACS 名前空間の URL</a>。</li>\n <li>Silverlight プレーヤーの URL。</li>\n <li>承認ポリシーの制限:</li>\n</ul>\n<blockquote>\n<pre class=\"prettyprint\">&lt;TokenRestrictionTemplate xmlns:i=\"https://www.w3.org/2001/XMLSchema-instance\" xmlns=\"\"&gt;\n  &lt;AlternateVerificationKeys&gt;\n    &lt;TokenVerificationKey i:type=\"SymmetricVerificationKey\"&gt;\n      &lt;KeyValue&gt;(portion deleted) Yw1z2wxh6ZkX4tRl/WVhBTvM6T/vUo=&lt;/KeyValue&gt;\n    &lt;/TokenVerificationKey&gt;\n  &lt;/AlternateVerificationKeys&gt;\n  &lt;Audience&gt;urn:test&lt;/Audience&gt;\n  &lt;Issuer&gt;https://willzhanacs.accesscontrol.windows.net/&lt;/Issuer&gt;\n  &lt;PrimaryVerificationKey i:type=\"SymmetricVerificationKey\"&gt;\n    &lt;KeyValue&gt;(portion deleted) A8RlVMrPNhukYBF2sW04UMpuD8bw=&lt;/KeyValue&gt;\n  &lt;/PrimaryVerificationKey&gt;\n  &lt;RequiredClaims /&gt;\n&lt;/TokenRestrictionTemplate&gt;</pre>\n</blockquote>\n&nbsp;\n<h2></h2>\n<h2>実行方法</h2>\nテスト プレーヤーを使用してこのプロトタイプを実行する簡単な手順を次に示します。\n<ol>\n <li>プレーヤーを参照する</li>\n <li>[URL の追加] チェック マークをオンにし、URL を入力します。</li>\n <li>[AuthN ACS トークンの追加] チェック マークをオンにして、ACS 承認トークンが最初に要求され、LA_URL テキスト ボックスで指定されたライセンス取得 URL からの PlayReady ライセンス取得で使用されます。</li>\n <li>スムーズ ストリーミング資産の URL または MPEG-DASH アセット URL をコピーし、テキスト ボックスのSRC_URLします。 次に、[プレイリストに追加] ボタンを押して再生します。</li>\n</ol>\n&nbsp;\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/11/15/Player.jpg\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"プレーヤー\" alt=\"Player\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/Player_thumb.jpg\" width=\"636\" height=\"249\" border=\"0\" /></a>\n\nボタンをクリックすると、プレーヤーは次の操作を行います。\n<ol>\n <li>PlayReady 動的保護で資産のクライアント マニフェストをダウンロードします。</li>\n <li>サービス ID を介して ACS 2.0 名前空間によって認証されます。</li>\n <li>ACS から承認トークンを要求する。</li>\n <li>ACS トークンを使用してLA_URL PlayReady ライセンスを要求します。</li>\n <li>暗号化を解除し、[PlayReady の制限] をオンにし、右クリックしてビデオを再生します。</li>\n</ol>\nもちろん、[AuthN ACS トークンの追加] チェック マークをオフにし、ボタンをクリックすると、ACS 名前空間からの承認トークンが見つからないので、PlayReady ライセンスの取得で失敗します。\n\n&nbsp;\n<h1></h1>\n<h1>実装</h1>\n実装には次が含まれます。\n<ol>\n <li>.NET API を使用してスムーズ ストリーミング資産の PlayReady 動的保護Azure Media Services構成します。\n<ul>\n <li>コンテンツ キー ID とコンテンツ キーを生成する。</li>\n <li>キー配信サービスを構成する。</li>\n <li>資産配信ポリシーを使用して動的 PlayReady 保護を構成する。</li>\n <li>資産を発行します。</li>\n</ul>\n</li>\n <li>プレーヤー クライアントを認証し、承認トークンを発行するように Azure ACS 2.0 名前空間を設定します。</li>\n <li>認証、承認、ライセンス取得、ビデオ再生を処理する Silverlight プレーヤーを開発します。</li>\n</ol>\n<h2></h2>\n&nbsp;\n<h2>コンテンツ キーの生成</h2>\nコンテンツ キーの ID とコンテンツ キーの生成には、さまざまな方法があります。 詳細については、作成者のブログ (「キーの生成と <a href=\"https://blogs.msdn.com/b/playready4/archive/2014/08/18/solution-design-considerations-in-using-playready-license-delivery-service-of-azure-media-services.aspx\" target=\"_blank\">管理</a> 」セクション) を参照してください。 たとえば、次の方法があります。\n<blockquote>\n<pre class=\"prettyprint\">string keySeedB64, contentKeyB64;\nGuid keyId = Guid.NewGuid();\n//Guid keyId = new Guid(\"09a2212a-a803-4989-9a6e-6cd2e69500e7\");</pre>\n&nbsp;\n<pre class=\"prettyprint\">   \n//Method 1: Without using key seed, generete content key directly\n//contentKeyB64 = GeneratePlayReadyContentKey();</pre>\n&nbsp;\n<pre class=\"prettyprint\">//Method 2: With a given key seed and generated key ID (Key Identifiers are unique in the system and there can only be one key with a given Guid within a cluster (even across accounts for now although that may change to be account scoped in the future).  If you try to submit a protection job with a keyId that already exists but a different key value that will cause the PlayReady protection job to fail (the same keyId and keyValue is okay). \nkeySeedB64 = \"XVBovsmzhP9gRIZxWfFta3VVRPzVEWmJsazEJ46I\";\ncontentKeyB64 = GetPlayReadyContentKeyFromKeyIdKeySeed(keyId.ToString(), keySeedB64);</pre>\n&nbsp;\n<pre class=\"prettyprint\">//Method 3: With a randomly generated key seed, create content key from the key ID and key seed\n//keySeedB64 = GeneratePlayReadyKeySeed();\n//contentKeyB64 = GetPlayReadyContentKeyFromKeyIdKeySeed(keyId.ToString(), keySeedB64);</pre>\n&nbsp;\n<pre class=\"prettyprint\">//Method 4: Reuse an existing key ID (only once, for test)\n//keyId = new Guid(\"a7586184-40ff-4047-9edd-6a8273ac50fc\");\n//keySeedB64 = \"XVBovsmzhP9gRIZxWfFta3VVRPzVEWmJsazEJ46I\";\n//contentKeyB64 = GetPlayReadyContentKeyFromKeyIdKeySeed(keyId.ToString(), keySeedB64);\nConsole.WriteLine(string.Format(\"STEP 1: Key ID = {0}, Content Key = {1}, Key Seed = {2}\", contentKeyB64, keyId.ToString(), keySeedB64));</pre>\n</blockquote>\nキー ID とキー シードの生成には、次のユーティリティ メソッドが使用されます。\n<blockquote>\n<pre class=\"prettyprint\">public static byte[] GenerateCryptographicallyStrongRandomBytes(int length)\n{\n    byte[] bytes = new byte[length];\n    //This type implements the IDisposable interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its Dispose method in a try/catch block. To dispose of it indirectly, use a language construct such as using (in C#) \n    using (var rng = new System.Security.Cryptography.RNGCryptoServiceProvider())\n    {\n        rng.GetBytes(bytes);\n    }\n    return bytes;\n}</pre>\n&nbsp;\n<pre class=\"prettyprint\">//generate a PlayReady content key: cryptographically strong random byte[16]\npublic static string GeneratePlayReadyContentKey()\n{\n    byte[] bytes = GenerateCryptographicallyStrongRandomBytes(16);\n    return Convert.ToBase64String(bytes);\n}</pre>\n&nbsp;\n<pre class=\"prettyprint\">public static string GeneratePlayReadyKeySeed()\n{\n    byte[] bytes = GenerateCryptographicallyStrongRandomBytes(30);   //30 for key seed: https://msdn.microsoft.com/en-us/library/hh973610.aspx\n    return Convert.ToBase64String(bytes);\n}</pre>\n&nbsp;\n<pre class=\"prettyprint\">public static string GenerateSymmetricHashKey()\n{\n    byte[] bytes = GenerateCryptographicallyStrongRandomBytes(32);  \n    return Convert.ToBase64String(bytes);\n}</pre>\n&nbsp;\n<pre class=\"prettyprint\">//This API works the same as AESContentKey constructor in PlayReady Server SDK \npublic static string GetPlayReadyContentKeyFromKeyIdKeySeed(string keyIdString, string keySeedB64)\n{\n    Guid keyId = new Guid(keyIdString);\n    byte[] keySeed = Convert.FromBase64String(keySeedB64);\n\n    byte[] contentKey = CommonEncryption.GeneratePlayReadyContentKey(keySeed, keyId);\n\n    string contentKeyB64 = Convert.ToBase64String(contentKey);\n\n    return contentKeyB64;\n}</pre>\n</blockquote>\n&nbsp;\n<h2>コードのAzure Media Services</h2>\nたとえばAzure Media Services、保護されていないスムーズ ストリーミング資産がある場合を示します。 手順は次のとおりです。\n<ol>\n <li>この資産に含まれる可能性があるロケーターを削除します。 ロケーターが存在する場合、次の手順は続行できないので、これは重要です。</li>\n <li>資産配信ポリシーが含む可能性があるすべての資産配信ポリシーを削除します。</li>\n <li>ライセンス配信サービスを構成する。</li>\n <li>トークン制限を使用して動的 PlayReady 保護を構成します。</li>\n <li>資産を発行します。</li>\n</ol>\nPlayReady キー配信サービスを設定し、入力資産を動的に保護するコードは、<a href=\"https://github.com/Azure/azure-media-services-samples/blob/master/PlayReadyACSE2E/PlayReadyACSE2E_AMS_Code\" target=\"_blank\">GitHub Azure/azure-media-services-samples/</a> にあります。\n\n&nbsp;\n<h2>ACS セットアップ</h2>\nAzure ACS v 2.0 名前空間を構成する手順については、Mingfei <a title=\"のブログ「Media Services\" href=\"https://mingfeiy.com/acs-with-key-services\"> キー サービスを使用して ACS を構成する方法」の「Media Services</a> キー サービスを使用して ACS を構成する方法」をご覧ください。\n\n一般に、次の 2 つの認証があります。\n<ol>\n <li>エンド ユーザーは ID プロバイダーによって認証され、プレーヤー (いわゆる証明書利用者) をホストする Web アプリケーションにアクセスできます。 このプロトタイプでは、ユーザー認証を必要とせずに Web アプリケーションを開いたままにしておくことを選択しました。 そのため、Web アプリケーション用の ID プロバイダーは必要はありません。</li>\n <li>クライアント/自律アプリケーションは、アクセスを取得してトークンを取得するために ACS 2.0 名前空間によって認証されます。 このためには、ID <a href=\"https://msdn.microsoft.com/en-us/library/gg185945.aspx\" target=\"_blank\">プロバイダーを使用</a> する代わりに、ACS で直接認証するサービス ID を指定します。 このサービス ID は、ACS 名前空間から承認トークンを要求するために、ACS によって認証されるクライアントによって使用されます。</li>\n</ol>\n&nbsp;\n\nこの ACS 2.0 名前空間によって発行されるトークンの例を次に示します。\n<pre class=\"prettyprint\">http%3a%2f%2fschemas.xmlsoap.org%2fws%2f2005%2f05%2fidentity%2fclaims%2fnameidentifier=willzhan&amp;http%3a%2f%2fschemas.microsoft.com%2faccesscontrolservice%2f2010%2f07%2fclaims%2fidentityprovider=https%3a%2f%2fwillzhanacs.accesscontrol.windows.net%2f&amp;Audience=urn%3atest&amp;ExpiresOn=1415800463&amp;Issuer=https%3a%2f%2fwillzhanacs.accesscontrol.windows.net%2f&amp;HMACSHA256=ylYe9U18Ea1OfGJ%2fn2hzYfsm3XcM9X1HI2pBgUk54Eo%3d</pre>\n&nbsp;\n\n<strong>メモ：</strong> ACS 2.0 名前空間 <strong>で使用</strong> されているのと同じ (プライマリ) 対称ハッシュ キーが PlayReady 動的保護の構成にも使用されます。 具体的には、PlayReady 動的保護をプログラムで設定する場合は、次に示すように、IContentKeyAuthorizationPolicy で使用される制限要件を作成する必要があります。\n<blockquote>\n<pre class=\"prettyprint\">public static string CreateRestrictionRequirements()\n{\n    string primarySymmetricKey   = System.Configuration.ConfigurationManager.AppSettings[\"PrimarySymmetricKey\"];\n    string secondarySymmetricKey = System.Configuration.ConfigurationManager.AppSettings[\"SecondarySymmetricKey\"];\n    string scope                 = System.Configuration.ConfigurationManager.AppSettings[\"AcsScope\"];\n    string issuer                = System.Configuration.ConfigurationManager.AppSettings[\"AcsIssuer\"];\n\n    TokenRestrictionTemplate objTokenRestrictionTemplate = new TokenRestrictionTemplate();\n\n    objTokenRestrictionTemplate.PrimaryVerificationKey = new SymmetricVerificationKey(Convert.FromBase64String(primarySymmetricKey));\n    objTokenRestrictionTemplate.AlternateVerificationKeys.Add(new SymmetricVerificationKey(Convert.FromBase64String(secondarySymmetricKey)));\n    objTokenRestrictionTemplate.Audience               = new Uri(scope);\n    objTokenRestrictionTemplate.Issuer                 = new Uri(issuer);\n\n    return TokenRestrictionTemplateSerializer.Serialize(objTokenRestrictionTemplate);\n}</pre>\n</blockquote>\n&nbsp;\n\nprimarySymmetricKey 変数には、次に示すように ACS 2.0 から取得したのと同じ対称ハッシュ キー管理ポータル含まれている必要があります。\n\n&nbsp;\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/11/14/SymmetricHashKey.jpg\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"SymmetricHashKey\" alt=\"SymmetricHashKey\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/SymmetricHashKey_thumb.jpg\" width=\"632\" height=\"371\" border=\"0\" /></a>\n\nACS 名前空間でサービス ID を作成する場合は、パスワードまたは対称キーの資格情報の種類を選択できます。 トークン要求コードは、両方のケースをサポートするために強化されました。\n\n&nbsp;\n<h2>クライアント側のコード</h2>\nACS から認証トークンを要求するためのクライアント側コードと、Silverlight 内のカスタムライセンス acquirer については、「 <a href=\"https://github.com/Azure/azure-media-services-samples/blob/master/PlayReadyACSE2E/PlayReadyACSE2E_Client_Code\" target=\"_blank\">GitHub Azure/azure-</a>」を参照してください。\n\nプレーヤーアプリケーションは、次の処理を実行します。\n<ol>\n <li>まず、PlayReady 保護の下に smooth streaming 資産のマニフェストを要求し、マニフェストの保護ヘッダーを確認します。</li>\n <li>PlayReady ライセンスを要求するには、プレーヤーは、最後のセクションで作成された ACS 名前空間から認証トークンを取得する必要があります。 Silverlight 固有のコードがあまり書き込まれないようにするには、このコードを (WCF または REST) サービスに配置し、Silverlight アプリがサービスを呼び出して ACS トークンを取得することを検討します。 ACS トークンを取得したら、そのトークンをプロパティ (AcsToken) に格納して、の直後にライセンス acquirer が使用できるようにすることができます。</li>\n <li>ACS トークンは、前のセクションで構成した AMS ライセンス配信サービスから PlayReady ライセンスを取得するために、カスタムライセンス acquirer によって使用されます。</li>\n</ol>\n&nbsp;\n<h2>デプロイ</h2>\n上のシステム図と <a href=\"https://blogs.msdn.com/b/playready4/archive/2014/08/18/solution-design-considerations-in-using-playready-license-delivery-service-of-azure-media-services.aspx\" target=\"_blank\">作成者のブログ</a>で説明したように、このエンドツーエンドプロトタイプには次の物理コンポーネントが含まれています。\n<ol>\n <li>コンテンツキーとコンテンツキー ID。</li>\n <li>Azure Media Services のビデオ資産 (保護されていない) と Azure Media Services でのストリーミングオリジン</li>\n <li>Azure Media Services の資産に対して構成された PlayReady 動的保護</li>\n <li>PlayReady ライセンス配信サービスが Azure Media Services で構成されました。</li>\n <li>Azure ACS 2.0 名前空間で構成された STS</li>\n <li>ASP.NET アプリケーションの Silverlight ビデオプレーヤー。</li>\n</ol>\nソリューションは Azure Media Services 上に構築されているため、デプロイする必要があるのは、ビデオプレーヤーをホストしている ASP.NET web アプリケーションのみです。 これを展開するためのオプションがあります。\n<ul>\n <li>Azure の web サイト</li>\n <li>Azure IaaS VM、または</li>\n <li>オンプレミスのサーバー。</li>\n</ul>\nHTTP プロセスのアクティブ化がサーバーにインストールされていることを確認してください。そうしないと、WCF サービスが正常に機能しません。 また、ストリーミング配信元で PlayReady 動的保護を使用するには、少なくとも 1 RU を構成してください。\n\n&nbsp;\n<h1>ライブ ストリーミングの場合</h1>\nプログラムに関連付けられている資産を \"VOD 資産\" として扱うことにより、Azure Media Services でライブストリーミングを保護するためにまったく同じ設計と実装を使用できます。\n\n具体的には、Azure Media Services でライブ ストリーミングを行うには、チャネルを作成した後、チャネルの下にプログラムを作成する必要があることはよく知られています。 プログラムを作成するには、プログラムのライブ アーカイブを含む資産を作成する必要があります。 必要なのは、プログラムを開始する前に、資産に \"VOD 資産\" と同じセットアップ/処理を適用することだけです。 次のコードは、正確なフローを示しています。\n\n<a href=\"https://github.com/Azure/azure-media-services-samples/blob/master/PlayReadyACSE2E/PlayReadyACSE2E_AMS_Code\" target=\"_blank\">Azure Media Services のコード</a>に示されているように、次の方法を使用して VOD 資産の動的 PlayReady 保護を設定します。\n<pre class=\"prettyprint\">public static void SetupDynamicPlayReadyProtection(CloudMediaContext objCloudMediaContext, IAsset objIAsset)</pre>\nライブストリーミングに対して動的 PlayReady 保護を設定するには、通常どおり、チャネル、プログラム、アセットを作成しますが、プログラムを開始する前に、次に示すように、資産に対して上記のメソッドを実行します。\n<pre class=\"prettyprint\">public static void SetupLiveDynamicPlayReadyProtection(CloudMediaContext objCloudMediaContext, string channelName, string programName, string manifestFileName)\n        {\n            //get channel\n            IChannel objIChannel = objCloudMediaContext.Channels.Where(c =&gt; c.Name == channelName).FirstOrDefault();\n            Console.WriteLine(string.Format(\"IChannel.IngestUrl = {0}\",  objIChannel.Input.Endpoints.FirstOrDefault().Url.ToString()));\n            Console.WriteLine(string.Format(\"IChannel.PreviewUrl = {0}\", objIChannel.Preview.Endpoints.FirstOrDefault().Url.ToString()));\n\n            //create program asset\n            IAsset objIAsset = objCloudMediaContext.Assets.Create(string.Format(\"{0}_Program_Asset_PR\", channelName), AssetCreationOptions.None);\n\n            //set up dynamic PlayReady protection for the asset exactly as VOD\n            SetupDynamicPlayReadyProtection(objCloudMediaContext, objIAsset);\n\n            //create a program using this asset \n            ProgramCreationOptions options = new ProgramCreationOptions()\n            {\n                Name                = programName,\n                Description         = \"Dynamic PlayReady protection for live\",\n                ArchiveWindowLength = TimeSpan.FromMinutes(120.0),\n                ManifestName        = manifestFileName, //manifest file name to be duplicated (without .ism suffix)\n                AssetId             = objIAsset.Id\n            };\n            IProgram objIProgram = objIChannel.Programs.Create(options);\n\n            //publish the asset\n            Program.GetStreamingOriginLocator(objIAsset.Id, Program.MediaContentType.SmoothStreaming, true);\n\n            //start the program\n            objIProgram.Start();\n            Console.WriteLine(\"Program {0} has started\", programName);\n        }</pre>\n&nbsp;\n\nもちろん、これはいわゆる \"スケーラブルなライブテレビ\" PlayReady 保護ではありません。これは、リーフとルートのライセンスに対して、いわゆるキーローテーションを行わずに1つのコンテンツキーが保護に使用されるためです。\n<h1>まとめ</h1>\nDRM ソリューションのすべての主要なコンポーネントを含む Azure Media Services PlayReady ソリューションのエンドツーエンドプロトタイプを紹介しました。\n<ol>\n <li>コンテンツキー ID とコンテンツキーの生成</li>\n <li>Azure Media Services でのストリーミングオリジン</li>\n <li>Azure Media Services playready 動的保護機能による playready 保護</li>\n <li>Azure Media Services playready ライセンス配信サービスを使用した playready ライセンス配信</li>\n <li>Windows media player クライアントを認証し、承認トークンを発行するために、Azure ACS 2.0 を介して STS (Secure Token Service) を実行します。</li>\n <li>Azure IaaS VM でホストされるビデオプレーヤーアプリケーション。 ACS 認証、ACS 承認、PlayReady ライセンスの取得、ビデオ再生が処理されます。</li>\n</ol>\n&nbsp;\n\n<strong>版</strong>\n\n1/6/2015: smooth streaming と MPEG ダッシュプレーヤーは、より一般的なシナリオでの PlayReady 保護のテスト用に強化されています。\n<ol>\n <li>このブログで説明されているエンドツーエンドの実装に使用される ACS 名前空間だけでなく、どの Azure ACS 名前空間でも動作するようになりました。</li>\n <li>この機能は、オープンであるか、トークン制限の有無にかかわらず、動的 PlayReady 保護の下にある smooth streaming または MPEG ダッシュの資産で動作します。</li>\n <li>Azure Media Services またはオンプレミスの playready ライセンスサーバーのキー配信サービスのいずれかである PlayReady ライセンスサーバーで動作します。</li>\n</ol>\n&nbsp;\n\n1/23/2015: AMS Content Protection での jwt サポートのリリースでは、このプロトタイプは、STS と IdP の両方として Azure Active Directory (AAD) を使用して、jwt にトークン制限が含まれるように拡張されています。 AMS batch ジョブ (動的 PlayReady 保護または AES 暗号化の設定用): AAD テナントを認識しますが、プレーヤーアプリについては何もありません (プレーヤーは問題ありません)。 AAD テナント: は、windows media player アプリを認識しますが、AMS バッチジョブについては何もありません。 プレーヤーアプリ: AAD のテナントを認識しますが、ams や ams バッチジョブについては何もありません。 つまり、AAD テナントとプレーヤーアプリは相互に認識します。 AMS batch ジョブは AAD テナントを認識しますが、どのプレーヤーがコンテンツを消費しているかは考慮しません。\n\n&nbsp;\n\n<b><span style=\"font-size: large\">確認:</span> </b>Microsoft Azure Media Services チームの Quintin 火傷、ジョージ Trifonov、Mingfei yan に感謝しました。この作業には重要なヘルプが提供されています。"
