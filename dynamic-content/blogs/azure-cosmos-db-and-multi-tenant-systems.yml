### YamlMime:Yaml
ms.openlocfilehash: f83e5a1c10e43004fa66697a61f27d794df1f9c0
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139910076"
Slug: azure-cosmos-db-and-multi-tenant-systems
Title: Azure Cosmos DB とマルチテナントシステム
Summary: このブログ投稿では、Azure Cosmos DB でマルチテナントシステムを構築する方法について説明します。 Azure Cosmos DB 自体は、Azure でのマルチテナント PaaS サービスです。
Content: >-
  <p>このブログ投稿では、Azure Cosmos DB でマルチテナントシステムを構築する方法について説明します。 Azure Cosmos DB 自体は、Microsoft Azure のマルチテナント PaaS サービスです。 別のマルチテナントシステムでマルチテナントシステムを構築することは困難な場合がありますが、Azure では、タスクを簡単にするためのすべてのツールを提供しています。 マルチテナントシステムの例としては、他の企業が人事システムで使用できるバックグラウンドチェックサービスを提供する企業が挙げられます。 このブログ記事では、この例を使用して、サービスとしてのバックグラウンドチェックを提供する企業の観点から続行します。 この会社を発行元と &ldquo; 呼びます。&rdquo;</p>


  <p>&rsquo;機密ユーザーデータを格納するマルチテナントシステムを構築する方法について説明します。 データの分離とセキュリティは、あらゆるシステムの最も重要な側面です。 <strong>各テナント &rsquo; のデータが相互に分離されるように、システムを設計する必要があり</strong>ます。 特定のテナントに格納されているデータは、1つのテナント違反を別のテナントに渡すことができないように、コンパートメントに分割する必要があります。 これは、 <a href="https://en.wikipedia.org/wiki/Ship_floodability" target="_blank">floodability</a>を減らすために ship のハルを compartmentalizing することに似ています。</p>


  <p>マルチテナントシステムの顧客データの分離と保護を強化するには、テナントデータへのジャストインタイム (JIT) アクセスを可能にする承認されたサービスを1つだけ使用してシステムを構築する必要があります。 任意のプリンシパルのアクセススコープが顧客別に分割されるように、顧客 &rsquo; のデータパーティションごとに異なるシステムプリンシパルを設定する必要があります。 &rsquo;サービスがすべてのテナントデータにアクセスできないようにする必要があります。これは、大きなセキュリティリスクです。 ここで必要なのは、1つのテナント JIT のアクセス許可を取得するサービスです。 このアプローチの利点は、テナントが証明書とキーをいつでもローテーションできることです。</p>


  <p>すべてのテナントは、パブリッシャー&#39;s フロントエンドサービス (FES) を使用してデータを管理できますが、Azure Cosmos DB コレクション内の独自のデータを直接操作することはできません。 この分離により、すべてのテナントがマスターキーと読み取り専用キーにアクセスする必要がなくなります。 すべてのデータアクセスはサービスを介して実行され、ポータルまたはコードを使用して直接アクセスする場合を除き、いずれの Azure Cosmos DB もアクセスできません。 顧客データを管理する発行元アプリケーションは、顧客 &rsquo; のテナントとデータとは別の異なる Azure Active Directory テナントとサブスクリプションでホストされます。</p>


  <p>ただし、テナントは、データに直接アクセスしなくても、すべてのコレクションとデータを所有します。 これにより、テナントに直接課金されるすべてのデータストレージとスループットの課金が簡単になりますが、複雑な要件になります。 &rsquo;この要件を管理する方法については、「」を参照してください。</p>


  <p>このソリューションの主なアクターは、 <a href="https://docs.microsoft.com/en-us/azure/managed-applications/overview" target="_blank">Azure Managed Applications</a>、<a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/service-to-service" target="_blank">デーモンアプリケーション</a>、 <a href="https://docs.microsoft.com/en-us/azure/cosmos-db/introduction" target="_blank">Azure Cosmos DB</a>、 <a href="https://azure.microsoft.com/en-us/services/key-vault/" target="_blank">Azure Key Vault</a>および<a href="https://docs.microsoft.com/en-us/azure/active-directory/fundamentals/active-directory-whatis" target="_blank">Azure Active Directory</a> (AAD) です。 次の段落は、記載されている各ソリューションの理解に役立ちます。</p>


  <p>Azure マネージアプリケーションは、marketplace のサービスカタログに似ていますが、1つの重要な違いがあります。 マネージアプリケーションでは、リソースは、アプリの発行者によって管理されるリソースグループにプロビジョニングされます。 リソースグループはコンシューマー&#39;s サブスクリプションに存在しますが、パブリッシャー&#39;s テナントの id には、顧客サブスクリプションのリソースグループへのアクセス権があります。 発行元は、 <a href="https://azure.microsoft.com/en-us/pricing/details/managed-applications/" target="_blank">ソリューションの継続的なサポートのコスト</a>を指定します。</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/69cadeac-9577-42b4-aa0d-5104ee693492.png"><img alt="Customer subscription flow chart" border="0" height="200" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/e4182aa3-487d-4584-b05e-c601df406d39.png" style="border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="顧客サブスクリプションのフローチャート" width="558"></a></p>


  <p>マネージド アプリケーションは、ユーザーがソリューションを使用するための障壁を削減します。 ユーザーは、ソリューションを使用するために、クラウド インフラストラクチャの専門知識を持っている必要はありません。 ユーザーの重要なリソースへのアクセスは制限されます。 管理する際に間違いを犯すことを心配する必要は&#39;ありません。 マネージアプリケーションを使用すると、基盤となる Azure インフラストラクチャの専門知識を必要とせずに、お客様のソリューションを採用できます。</p>


  <p>マネージド アプリケーションによって、ユーザーと継続的な関係を確立できます。 アプリケーションを管理するための用語を定義すると、すべての課金は Azure の課金によって処理されます。</p>


  <p>顧客はこれらのマネージアプリケーションをサブスクリプションにデプロイしますが、管理、更新、またはサービスを行う必要はありません。 すべてのユーザーが承認済みのバージョンを使用していることを保証できます。 お客様は、これらのアプリケーションを管理するために、アプリケーション固有のドメインの知識を開発する必要はありません。 アプリケーションのトラブルシューティングや問題の診断を気にすることなく、アプリケーションの更新プログラムが自動的に取得されます。 Azure マネージアプリケーションの利点は、課金、異なるテナント間でのデータの分離、簡単なメンテナンスなどの利点です。 詳細については、 <a href="https://docs.microsoft.com/en-us/azure/managed-applications/overview" target="_blank">Azure Managed Applications</a>に関する詳細を参照してください。</p>


  <p>テナントマネージアプリケーションをデプロイしたら、デーモンアプリケーションを作成します。 リソースにアクセスできる<a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-authenticate-service-principal-powershell" target="_blank">AAD アプリケーションとサービスプリンシパルを作成する方法</a>については、こちらの手順に従ってください。 このデーモンアプリケーションには、独自の id とテナントサブスクリプションへのアクセスがあります。 このアプリケーションは、顧客のテナントアプリケーションとサービスプロバイダー (パブリッシャー) との間の橋渡しをします。</p>


  <p>いくつかのことを理解しておくことが重要です。 まず、デーモン アプリケーションでは、ユーザー操作は使用できません。アプリケーションには独自の ID が必要です。 デーモン アプリケーションの例として、バッチ ジョブ (バックグラウンドで実行されているオペレーティング システム サービス) があります。 この種のアプリケーションは、アプリケーション id を使用してアクセストークンを要求し、アプリケーション ID、資格情報 (パスワードまたは証明書)、およびアプリケーション ID URI を提示して、AAD します。 認証が成功すると、デーモンは、アプリケーションの id を表すアクセストークンを AAD から受け取り、web API を呼び出すために使用します。</p>


  <p>Azure Managed Applications のマジックとして、発行元は、発行元が AAD テナントのサブスクリプション内にあるかのように &rsquo; 、管理対象の顧客サブスクリプションリソースにアクセスできます。 顧客テナントのサブスクリプションリソースは、お客様の Azure サブスクリプションでお客様に表示されますが、Azure リソースロックによってアクセスすることはできません。 お客様 &rsquo; のサブスクリプションのマネージアプリケーションリソースへのフルアクセスは、パブリッシャーのみに許可されています。</p>


  <p>デーモンアプリケーションを作成したら、それを Azure Cosmos DB インスタンスの id およびアクセス (IAM) に登録する必要があります。これは、顧客のテナントサブスクリプションのマネージリソースコンポーネントとしてデプロイされます。</p>


  <p>最後に、フロントエンドサービス (FES) を開発します。 これは、顧客テナントのコンポーネントの管理に使用されるサービスです。 このサービスは、デーモンアプリケーション id を取得するオーケストレーションを通過するまで、Azure Cosmos DB に直接アクセスすることはできません。 次に、FES と顧客 &rsquo; のサブスクリプションリソースとの対話に関する詳細な手順を示します。</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/97c5795c-c676-4dba-8c48-3fb57044b52f.png"><img alt="FES interaction with the customer subscription resources flow chart" border="0" height="375" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2c3fa919-d443-45c3-90a1-da33a13f0914.png" style="border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="FES と顧客サブスクリプションリソースフローチャートの相互作用" width="558"></a></p>


  <p>FES は、実行時にデーモンアプリケーション id を引き継ぎます。 FES には、アクセスのために Key Vault に登録されている独自のマネージ id (MSI) もあります。 実行時に、FES は Azure MSI を使用して Key Vault に接続し、証明書の資格情報を取得します。さらに、資格情報を使用して、デーモンアプリケーションを表す AAD からトークンを取得します (手順 1)。</p>


  <p>FES が証明書を取得すると、クライアント ID とシークレット証明書を使用して、デーモンサービスの id を前提とします。 次に、AAD を呼び出して、マネージアプリケーションのアクセストークンを取得します (手順 2)。 この FES は Azure Active Directory Authorization dll (AAD DLL) を使用します。 AAD からトークンを取得するには、次の FES コードスニペットを参照してください。</p>


  <pre>

  using Microsoft.Azure.KeyVault;

  using Microsoft.Azure.Services.AppAuthentication;

  using Microsoft.IdentityModel.Clients.ActiveDirectory;


  string secretIdentifier = &quot; key vault secretIdentifier for daemon app goes here &quot;;

  var tokenCache = TokenCache.DefaultShared;

  string pubTenantId = &quot; publisher&rsquo;s Azure AD directory id here &quot;;


  //// get app key from Key Vault (&hellip; let me know if you need a sample for reading a certificate/private key instead of a secret

  var azureServiceTokenProvider = new AzureServiceTokenProvider();


  var keyVaultClient = new KeyVaultClient(new KeyVaultClient.AuthenticationCallback(azureServiceTokenProvider.KeyVaultTokenCallback));

  string secret = keyVaultClient.GetSecretAsync(appKey)

  .GetAwaiter()

  .GetResult();


  //// now get a token representing the Daemon app, using the secret credential of the Daemon Azure AD application.  Resource is the appropriate Azure resource Uri.

  string daemonAppId = &quot;daemon Azure AD application Id&quot;;

  string authString = $&quot;https://login.microsoftonline.com/{pubTenantId}&quot;;

  string daemonAppResourceUri = &quot;https://management.core.windows.net/&quot;;

  var clientCredential = new ClientCredential(daemonAppId, secret.Value);

  var authenticationContext = new AuthenticationContext(authString, false, tokenCache);


  var authnResult = authenticationContext.AcquireTokenAsync(resourceUri, clientCredential)

  .GetAwaiter()

  .GetResult();


  string daemonToken = authnResult.AccessToken;


  //// alternately, to use a certificate you would substitute the above variables:

  ////     var clientCredential = new ClientAssertionCertificate(clientId, certificate);</pre>


  <p>FES によってアクセストークンが取得されると、マスターキーを取得するために Azure Cosmos DB が呼び出されます (手順3と 4)。 これは、デーモンアプリケーションのアクセストークンを使用して実現されます。 この FES では、ヘッダーに AAD トークンを渡します。</p>


  <pre>

  using Microsoft.Azure.Management.CosmosDB.Fluent;

  using Microsoft.Azure.Management.Fluent;

  using Microsoft.Azure.Management.ResourceManager.Fluent;

  using Microsoft.Azure.Management.ResourceManager.Fluent.Core;


  string subscriptionId = &quot; subscribing customer&rsquo;s subscription id &quot;;

  string resourceGroupName = &quot; subscribing customer&rsquo;s resource group name &quot;;

  string databaseAccountName = &quot; subscribing customer&rsquo;s Cosmos DB account name &quot;;


  var credential = new AzureCredentials(new TokenCredentials(daemonToken), pubTenantId, AzureEnvironment.AzureGlobalCloud);


  var azure = Azure.Configure()

  .WithLogLevel(HttpLoggingDelegatingHandler.Level.Basic)

  .Authenticate(credential)

  .WithSubscription(subscriptionId);


  var cosmosDbAccounts = azure.CosmosDBAccounts;

  var readWritekeys = cosmosDbAccounts.ListKeysAsync(resourceGroupName, databaseAccountName)

  .GetAwaiter()

  .GetResult();</pre>


  <p>マスターキーがあると、Cosmos DB へのアクセスが開始されます (手順 5.)。</p>


  <pre>

  using Microsoft.Azure.Documents;

  using Microsoft.Azure.Documents.Client;


  string cosmosDBendpointUri = $&quot;{databaseAccountName}.documents.azure.com:443/&quot;;


  string masterKey = readWritekeys.PrimaryMasterKey; //// pick the one you need


  var connectionPolicy = new ConnectionPolicy { ConnectionMode = ConnectionMode.Direct, ConnectionProtocol = Protocol.Tcp };


  var documentClient = new DocumentClient(new Uri(cosmosDBendpointUri), masterKey, connectionPolicy);


  client.OpenAsync()

  .GetAwaiter()

  .GetResult();</pre>


  <p>FES を表す<a href="https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview" target="_blank">Azure MSI</a>ではなく、デーモンアプリケーション id が Azure Cosmos DB キーを取得するために使用されるのは、なぜでしょうか。 回答としては、セキュリティの分離、JIT アクセス、Key Vault からのデーモンアプリケーションシークレットの取得、AAD へのアクセスによるセキュリティの分離のサポートに &rsquo; 関するすべてのヘルプを参照してください。 このオーケストレーションにより、FES がすべてのテナント &rsquo; キーにアクセスできないようにします。 このメソッドは、デーモン id を使用することによってのみ、キー JIT にアクセスできます。</p>


  <p>このシステムには、次のような利点があります。</p>


  <ul>
   <li>アクセスキーは、発行元、コード、または構成ファイルと共に保持されません。 この方法では、すべてのテナントに必要なセキュリティが提供されます。</li>
   <li>1つのパブリッシャーアクセストークンがすべてのテナントにアクセスすることはできません。</li>
   <li>サブスクライブしている各顧客は、その顧客 &rsquo; のリソースにアクセスするための独自のデーモンアプリケーション id を使用してプロビジョニングされます。</li>
   <li>FES は、実行時にのみ、デーモンアプリケーションシークレットを使用してアクセストークンを取得できます。</li>
  </ul>


  <p>Azure Cosmos DB は、次のように、このソリューションの利点の多くをもたらします。</p>


  <ul>
   <li>発行元は、新しいテナントのオンボード時に必要なスループットと容量を把握していません。</li>
   <li>Azure Cosmos DB &rsquo; s エラスティックでストレージとスループットを維持することで、このソリューションは非常に柔軟になります。</li>
   <li>パブリッシャーによって定義された Azure Managed Applications テンプレートには、必要に応じて要求ユニットを拡張できる最小既定の Azure Cosmos DB が付属しています。</li>
   <li>デーモンアプリケーションと Key Vault を使用した JIT アクセス。</li>
  </ul>


  <p>この記事では、Azure Cosmos DB に対してマルチテナントシステムを構築するための作業を開始するのに役立つ十分なポインターが提供されていることを願っています。</p>


  <p><em>このブログの投稿に貢献するために、Nikisha Reyes-Grange と Gunda に感謝します。</em></p>
