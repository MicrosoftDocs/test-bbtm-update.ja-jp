### YamlMime:Yaml
ms.openlocfilehash: 87a5328600c0ba1f848d53fcfcdb305fe7347f05
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139904211"
Slug: disabling-arrs-instance-affinity-in-windows-azure-web-sites
Title: Azure Web サイトでの ARR のインスタンス アフィニティWindows無効にする
Summary: Windows Azure Websites で Web サイトの複数のインスタンスを設定すると、Web サイトをスケールアウトするための非常に便利な方法です。Azure では、アプリケーション要求ルーティング IIS 拡張機能を有効に利用しています。
Content: >-
  Windows Azure Websites で Web サイトの複数のインスタンスを設定すると、Web サイトをスケールアウトするための非常に便利な方法です。Azure では、アプリケーション要求<a href="https://www.iis.net/learn/extensions/planning-for-arr" target="_blank">ルーティング IIS 拡張機能</a>を使用して、接続しているユーザーをアクティブなインスタンス間で分散します。 ARR は、ユーザーに特別な Cookie (アフィニティ クッキーと呼ばれる) を与えることによって<strong></strong>ユーザーの接続を巧妙に追跡します。これにより、後続の要求時に、ユーザーが話していたサーバー インスタンスを知る機能が提供されます。 これにより、クライアントが特定のサーバー インスタンスとのセッションを確立すると、セッションがアクティブである限り、同じサーバーと話し続けるのを確認できます。 これは、セッションに依存するアプリケーション (つまり、 ステートレス アプリケーション)。 セッション固有のデータはサーバー間で移動しないのでです。 アプリケーションはこれを行う (通常は SQL のような共有ストレージにデータを格納することで) 設計できますが、ほとんどの場合はそうではなく、通常は、すべてのユーザーを自分の指定されたサーバーに接続し続けしたいと考えました。 ユーザーが別のサーバーに移動すると、新しいセッションが開始され、アプリケーションで使用されたセッション データ (ショッピング カートのコンテンツなど) は削除されます。 このプロセスの簡単な説明を次に示します。

  <ol>
   <li>クライアントが Azure Web サイト Web サイトに接続する</li>
   <li>ARR はフロントエンド Azure サーバーで実行され、要求を受信します</li>
   <li>ARR は、要求を実行する必要がある使用可能なインスタンスを決定します</li>
   <li>ARR は、選択したサーバーに要求を転送し、要求に <strong>ARRAffinity</strong> Cookie をアタッチします</li>
   <li>応答は、 <strong>ARRAffinity Cookie を保持してクライアントに返</strong> されます。</li>
   <li>クライアントは要求を受信すると、後で使用するために Cookie を格納します (ブラウザーは、サーバーから受け取る Cookie に対してこれを行う設計です)</li>
   <li>クライアントが後続の要求を送信すると、その中に Cookie が含まれます</li>
   <li>ARR が要求を受信すると、Cookie が表示され、デコードされます。</li>
   <li>デコードされた Cookie には、前に使用したインスタンスの名前が保持されます。そのため、ARR はプールから要求を選択するのではなく、同じインスタンスに要求を転送します</li>
   <li>ユーザーがブラウザーを閉じるまで、同じサイトに対する後続の要求ごとに同じことを繰り返します (手順 7 から 9)。</li>
  </ol>

  <div><a href="https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/02/8407.blogpicture.png-550x0.png"><img class="alignnone size-medium wp-image-133941" alt="8407.blogpicture.png-550x0" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/8407.blogpicture.png-550x0-400x369.png" width="400" height="369" /></a></div>

  <div>


  ただし、アフィニティを維持することが望ましい場合があります。 たとえば、一部のユーザーはブラウザーを閉じなかったり、接続を長い間続けなかったりします。 この場合、アフィニティ Cookie はブラウザーに残ります。これにより、ユーザーは数時間、数日、またはさらに多くの期間 (理論的には無期限に) サーバーに接続されます。 コンピューターをオンにし、ブラウザーを開いた状態に保つことは珍しいことではなく、多くのユーザー (特に作業場所のコンピューター) が常に実行します。 現実の世界では、これにより、インスタンスごとのユーザーの分布がバランスを取れなく (これは、スーパーの一部のレジスタの背後にある行が 1 人の顧客に引き付け、他のユーザーが通常よりも多くの行で待機する方法と少し似ている)。


  アプリケーションとその実行内容に応じて、ユーザーがサーバーに関連付けられていることを気に入る場合があります。 これがほとんどまたは全く重要ではなく、このアフィニティを無効にし、負荷分散を向上することを選択する場合は、それを制御する機能が導入されています。


  アフィニティはアフィニティ Cookie によって制御されます。アフィニティを無効にするには、Azure が Cookie を提供しないので、アフィニティを無効にする必要があります。そうしない場合、ユーザーによる後続の要求は "新しい" として扱われるので、それらを "自分の" サーバーにルーティングしようとするのではなく、ARR は通常の負荷分散動作を使用して、要求を最適なサーバーにルーティングします。


  アフィニティ Cookie は次のように表示されます。


  </div>

  <div><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/5773.bp2_.png-550x0.png"><img class="alignnone size-full wp-image-133931" alt="5773.bp2.png-550x0" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/5773.bp2_.png-550x0.png" width="550" height="143" /></a></div>

  <div>


  アフィニティの無効化は、次の 2 つの方法で行うことができます。

  <ol>
   <li>アプリケーションで</li>
   <li>サイト構成で</li>
  </ol>

  アプリケーションでこの動作を制御するには、特殊な HTTP ヘッダーを送信するコードを記述する必要があります。これにより、アプリケーション要求ルーターにアフィニティ Cookie を削除します。 このヘッダーは <strong>Arr-Disable-Session-Affinity</strong> であり、true に設定すると、ARR によって Cookie が削除されます。 たとえば、次のような行をアプリケーションのコードに追加できます。

  <table border="1" cellspacing="0" cellpadding="0">

  <tbody>

  <tr>

  <td valign="top" width="623">ヘッダー。Add("Arr-Disable-Session-Affinity", "True");</td>

  </tr>

  </tbody>

  </table>

  </div>

  <div>


  * この例は C# 用ですが、他の言語やプラットフォームでも同様に簡単に実行できます。


  アプリケーションのコードでこれを設定すると、アフィニティをほとんどの部分で保持し、特定のアプリケーション ページでのみリセットする必要がある状況に適しています。 ただし、完全に無効にした方が良い場合は、IIS 自体にヘッダーを直接挿入することで、常に ARR で Cookie を削除できます。 これは、 の <strong>customHeaders 構成</strong> セクションで <strong> 行web.config</strong>。次のコードを web.configし、サイトのルートにアップロードします。


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/6765.bp3_.JPG-550x0.jpg"><img class="alignnone size-full wp-image-133921" alt="6765.bp3.JPG-550x0" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/6765.bp3_.JPG-550x0.jpg" width="550" height="166" /></a>


  しかし、web.configの構成は機密性が高く <strong> 、形式が正 </strong> しく設定されていないファイルによってサイトが正常に動作しないことに注意してください。 以前に複数のファイルを使用する機会がweb.config場合は、 <strong> この </strong> 作業開始 <a href="https://www.iis.net/learn/get-started/planning-your-iis-architecture/the-configuration-system-in-iis-7" target="_blank">ガイドを参照してください</a>。


  <strong><span style="text-decoration: underline;">トラブルシューティング</span></strong>


  これを実装する場合は、その動作を確認してトラブルシューティングする方法を疑問に思う場合があります。 ARR アフィニティ Cookie は通常、Azure Web サイト Web サイト<sup>からの 1 つ</sup> めの応答に含まれており、その後、クライアントから送信された要求とサーバーから受信した応答に含まれます。 動作を確認するには、複数の HTTP トラブルシューティングツールと診断ツールを使用できます。 より一般的なオプションの一覧を次に示します。

  <ol>
   <li>Fiddler</li>
   <li>HTTPWatc</li>
   <li>ネットワーク モニター</li>
   <li>WireShark</li>
   <li>Firebug</li>
  </ol>

  他のいくつかのツールに関する情報については、こちらを参照 <a href="https://oreilly.com/server-administration/excerpts/9780596522315/performance-tools.html" target="_blank">してください</a>。 一覧<sup>の</sup> 1 つめは Fiddler です。これは、任意のブラウザーと対話できる最も人気のある 1 つであり、無料で利用できます。 Fiddler をインストールすると、参照先の URL が記録され、[Inspector]/(インスペクター)タブをクリックして要求または応答を表示し、詳細を確認できます。 たとえば、次の [HTTP ヘッダー] タブを見ることができます。このタブには、次のヘッダーを使用してサーバーから送信されたアフィニティ cookie がSet-Cookieされます。


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/5140.bp4_.png-550x0.png"><img class="alignnone size-full wp-image-133911" alt="5140.bp4.png-550x0" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/5140.bp4_.png-550x0.png" width="550" height="225" /></a>


  <strong>Arr-Disable-Session-Affinity</strong> ヘッダーを追加してアフィニティ Cookie を無効にすると、ARR は Cookie を設定しませんが、<strong>Arr-Disable-Session-Affinity</strong> ヘッダー自体も削除されます。そのため、プロセスが正しく動作している場合はどちらも表示されません。 Cookie とヘッダーの両方が表示される場合は、ヘッダーの設定方法に問題があるという意味です。 ヘッダー名またはヘッダー値のテキストでエラーが発生する可能性があります。 ヘッダーではなく Cookie が表示される場合は、Web.config への変更が無効であるか、ヘッダー挿入コードが機能していない可能性があります。また、関連のない別のヘッダーを追加して確認してみてください。 一般に、コードよりも web.config を使用してヘッダーを設定する方が簡単です。そのため、疑問がある場合は、調査の領域を減らすために簡略化して開始する必要があります。


  最後に、アフィニティを無効にすることでは、軽く考えるべきものではないと言う必要があります。 静的コンテンツの場合は、ほとんど問題が発生しませんが、アプリケーションを実行している場合、あるサーバーから別のサーバーにジャンプするユーザーを扱う目的で設計されていない場合は、うまく終了しない可能性があります。 アフィニティが不均衡を引き起こしているシナリオでは、この新しい機能は大きなニュースになります。


  </div>
