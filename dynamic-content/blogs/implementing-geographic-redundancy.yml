### YamlMime:Yaml
ms.openlocfilehash: 060dc726ede24b6b8804808946a18671a0f7323e
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139895046"
Slug: implementing-geographic-redundancy
Title: 地理的冗長性の実装
Summary: '[この記事は、チームによってSQL Azureされました。]地理的冗長性は、データを複数のデータ センターにグローバルに分散するための非常に便利な言葉です。 これを実現する 1 つの方法は、spread...'
Content: "<p>[この記事は、チームによってSQL Azureされました。]</p><p><a href=\"\"><img style=\"border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; margin-left: 0px; border-left-width: 0px; margin-right: 0px\" title=\"\" border=\"0\" hspace=\"12\" alt=\"clip_image002\" align=\"right\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/1715.clip_5F00_image002_5F00_thumb_5F00_08BA52CA.jpg\" width=\"244\" height=\"244\"></a>clip_image002 Geographic 冗長性は、データを複数のデータ センターにグローバルに分散するための非常に便利な言葉です。 これを実現する 1 つの方法は、データ同期 Service for SQL Azure を使用してハブ データベースを多くのグローバル メンバー データベースに同期することで、データを多数の SQL Azure データ センターに分散することです。 SQL Azure、世界中に 6 つのデータ センターがあります</p>  <p>今後は、データ同期 Services でリアルタイムの書き込みと地理的冗長性を提供する、より複雑な手法についてブログをデータ同期します。</p>  <h2>考慮事項</h2>  <p>このブログ記事で説明する手法は、書き込みデータをリアルタイムで同期する必要がない書き込みと読み取りが多いデータベースに最適です。 この手法に適したシナリオの 1 つは、このブログ記事で説明したマガジン発行 Web サイトです。</p>  <p>SQL Azure Service for データ同期の現在の CTP を使用すると、最も頻繁に同期を 1 時間にできます。 この制限により、この特定の手法の使い方が限られた数のアプリケーションにまで低下します。 良いニュースは、データ同期 Services の今後のリリースで、より頻繁に同期を行うオプションが用意データ同期です。 </p>  <h2>サービスのデータ同期設定SQL Azure</h2>  <p>地理的な冗長性を確保するには、異なるデータ センターにある SQL Azure サーバーを持つ複数の SQL Azure サービス アカウントが必要です。 現時点では、アカウントごとに 1 つのサーバーのみを使用できます。つまり、複数のデータ センターに存在する場合は、複数のアカウントが必要です。 データ センターの場所とメンバー データベースの数は、アプリケーションのニーズによって異なっています。 2 つの異なるデータ センターに 2 つのデータベースを持つことは、地理的な冗長性のために最低限必要です。</p>  <p>次の手順では、サービスのデータ同期を設定SQL Azure。 この手法では、ハブ データベースは読み取りおよび書き込み可能なデータベースであり、メンバー データベースは読み取り (SELECT) のみを行うデータベースです。 メンバー データベースを読み取り専用にすることで、データの整合性と同期の競合の問題が簡単になります。</p>  <h2>データ層の変更</h2>  <p>最後の手順では、最初に Azure Web ロールを使用してローカル データセンターを選択するインテリジェンスWindows追加します。 ローカル データベースがオフラインで、コードがデータセンターのリモート データベースにSQL Azure場合。 このコードは、このブログ記事で説明した接続処理コードを拡張しています。</p>  <h2>接続文字列</h2>  <p>上記のセットアップを使用すると、複数の読み取り専用メンバー データベースがグローバルに分散されます。 つまり、アプリケーションで使用できる接続文字列が複数あるとします。 設計の演習として、これらのアプリケーションが Azure Web ロールWindows使用され、それらのアプリケーションが SQL Azure データベースと同じデータ センターに存在する可能性があるとします。</p>  <p>この手法では、データベースに対して読み取りクエリが実行されるたび、接続文字列を動的に構築します。 コードに次の目標を設定する必要があります。</p>  <ul>   <li>プライマリ サーバーが Azure Web ロールが実行されているデータ センターと同Windows接続文字列を返します。 これにより、パフォーマンスが向上し、データ転送料金が削減されます。</li>    <li>フェールオーバー パートナーがプライマリ サーバーとは異なるデータ センターにある接続文字列を返します。 これにより、地理的な冗長性が得されます。</li>    <li>リモート データ センターを呼び出す代わりに、以前のコード例を基に、ローカル データセンターで一時的なエラーを再試行します。</li>    <li>データが一致するサーバーをデータセンターごとに 1 つ持ちます。</li>    <li>すべてのデータベースの名前は同じです。これにより、各サーバーのデータベース名の一覧を保持する必要がならないので、この例のコードは単純になります。</li>    <li>1 つのリモート データ センターのみを試してください。 ローカル データ センターとランダム フェールオーバー パートナーが失敗した場合は、操作を中止します。</li> </ul>  <h2>ConnectionStringManager</h2>  <p><b>次に示す ConnectionStringManager</b> クラスは、データを保持するデータ センターとサーバーについて知っています。 また、構成ファイルからユーザー ID とパスワードを読み取る方法も知っています。 この情報から、ローカルのデータベースへの接続文字列を構築したりSQL Azure、リモートで接続するためのランダム フェールオーバー パートナーを返したりできます。</p>  <p><b>ConnectionStringManager クラス</b> コードは、ブログ投稿の最後にあるダウンロードで確認できます。 <b>ConnectionStringManager クラス</b>のコードは次のように表示されます。</p>  <pre class=\"csharpcode\"><span class=\"kwrd\">internal</span> <span class=\"kwrd\">class</span> ConnectionStringManager  {      <span class=\"rem\">/// &lt;summary&gt;</span>      <span class=\"rem\">/// Enumeration of SQL Azure Data Centers</span>      <span class=\"rem\">/// &lt;/summary&gt;</span>      <span class=\"kwrd\">internal</span> <span class=\"kwrd\">enum</span> DataCenterEnum      {          EastAsia,          NorthCentralUS,          NorthEurope,          SouthCentralUS,          SoutheastAsia,          WestEurope      }        <span class=\"kwrd\">protected</span> Dictionary&lt;DataCenterEnum, String&gt; _datacenters =          <span class=\"kwrd\">new</span> Dictionary&lt;DataCenterEnum, <span class=\"kwrd\">string</span>&gt;();      Random _random = <span class=\"kwrd\">new</span> Random();        <span class=\"kwrd\">internal</span> ConnectionStringManager()      {          <span class=\"rem\">// WWB: List of Servers With The Same Data, One Per DataCenter</span>          _datacenters[DataCenterEnum.SouthCentralUS]               = <span class=\"str\">&quot;n50rqzztlj&quot;</span>;          _datacenters[DataCenterEnum.NorthCentralUS]               = <span class=\"str\">&quot;iiyzhlnz4s&quot;</span>;      }        <span class=\"rem\">/// &lt;summary&gt;</span>      <span class=\"rem\">// Overall performance could be improved by changing or</span>      <span class=\"rem\">// caching this algorithm, however for simplicity of </span>      <span class=\"rem\">// the example, I am leaving it this way.</span>      <span class=\"rem\">/// &lt;/summary&gt;</span>      <span class=\"rem\">/// &lt;param name=&quot;localDataCenter&quot;&gt;&lt;/param&gt;</span>      <span class=\"rem\">/// &lt;returns&gt;&lt;/returns&gt;</span>      <span class=\"kwrd\">internal</span> DataCenterEnum? FailOverPartner(          DataCenterEnum localDataCenter)      {          <span class=\"rem\">// WWB: Generate a List Of FailOver Partners Not In</span>          <span class=\"rem\">// The Local Data Center</span>          List&lt;DataCenterEnum&gt; nonLocalServers = <span class=\"kwrd\">new</span> List&lt;DataCenterEnum&gt;();          <span class=\"kwrd\">foreach</span> (DataCenterEnum dataCenter <span class=\"kwrd\">in</span> _datacenters.Keys)              <span class=\"kwrd\">if</span> (dataCenter != localDataCenter)                  nonLocalServers.Add(dataCenter);            <span class=\"rem\">// WWB: There Are No Valid FailOver Partners</span>          <span class=\"kwrd\">if</span> (nonLocalServers.Count == 0)              <span class=\"kwrd\">return</span> (<span class=\"kwrd\">null</span>);            <span class=\"rem\">// WWB: Choose a Random Remote DataCenter</span>          <span class=\"kwrd\">int</span> index = _random.Next(nonLocalServers.Count);            <span class=\"kwrd\">return</span> (nonLocalServers[index]);      }        <span class=\"kwrd\">internal</span> String Database      {          get          {              <span class=\"kwrd\">return</span> (ConfigurationManager.AppSettings[<span class=\"str\">&quot;Database&quot;</span>]);          }      }        <span class=\"kwrd\">internal</span> String UserId      {          get          {              <span class=\"kwrd\">return</span> (ConfigurationManager.AppSettings[<span class=\"str\">&quot;UserId&quot;</span>]);          }      }        <span class=\"kwrd\">internal</span> String Password      {          get          {              <span class=\"kwrd\">return</span> (ConfigurationManager.AppSettings[<span class=\"str\">&quot;password&quot;</span>]);          }      }        <span class=\"rem\">/// &lt;summary&gt;</span>      <span class=\"rem\">/// Return the server name for the datacenter.</span>      <span class=\"rem\">/// &lt;/summary&gt;</span>      <span class=\"rem\">/// &lt;param name=&quot;localDataCenter&quot;&gt;&lt;/param&gt;</span>      <span class=\"rem\">/// &lt;returns&gt;&lt;/returns&gt;</span>      <span class=\"kwrd\">internal</span> String Server(DataCenterEnum localDataCenter)      {          <span class=\"kwrd\">return</span> (_datacenters[localDataCenter]);      }        <span class=\"rem\">/// &lt;summary&gt;</span>      <span class=\"rem\">/// Returns the Connection String For the DataCenter</span>      <span class=\"rem\">/// Performance Could be Improved By Caching the Results</span>      <span class=\"rem\">/// And Not Constructing the String Everytime.</span>      <span class=\"rem\">/// &lt;/summary&gt;</span>      <span class=\"rem\">/// &lt;param name=&quot;localDataCenter&quot;&gt;&lt;/param&gt;</span>      <span class=\"rem\">/// &lt;returns&gt;&lt;/returns&gt;</span>      <span class=\"kwrd\">internal</span> String ConnectionString(DataCenterEnum localDataCenter)      {          StringBuilder connectionString = <span class=\"kwrd\">new</span> StringBuilder();            connectionString.AppendFormat(<span class=\"str\">&quot;Server=tcp:{0}.database.windows.net;&quot;</span>,              Server(localDataCenter));          connectionString.AppendFormat(<span class=\"str\">&quot;Database=AdventureWorksLTAZ2008R2;&quot;</span>,               Database);          connectionString.AppendFormat(<span class=\"str\">&quot;User ID={0}@{1};&quot;</span>, UserId,              Server(localDataCenter));          connectionString.AppendFormat(<span class=\"str\">&quot;Password={0};&quot;</span>, Password);          connectionString.AppendFormat(<span class=\"str\">&quot;Trusted_Connection=False;&quot;</span>);          connectionString.AppendFormat(<span class=\"str\">&quot;Encrypt=True;&quot;</span>);            <span class=\"kwrd\">return</span> (connectionString.ToString());      }  }</pre>      <p>呼び出し元のコードは、このブログ記事で説明した接続処理コードを基に構築されています。 現在、C# コードWindowsデータ センターを Azure で検出する方法はありません。 そのため、ローカル データ センターをコードにハードコードする必要があります。 これは、Azure データ センター内の他のデータ センターに同じコードをデプロイWindows変更する必要があります。 また、Azure 構成ファイルの Windowsに移動し、そこからコードを読み取る必要があります。</p>    <pre class=\"csharpcode\"><span class=\"kwrd\">static</span> <span class=\"kwrd\">private</span> ConnectionStringManager       ConnectionStringManager = <span class=\"kwrd\">new</span> ConnectionStringManager();  <span class=\"kwrd\">static</span> <span class=\"kwrd\">private</span> ConnectionStringManager.DataCenterEnum       LocalDataCenter = ConnectionStringManager.DataCenterEnum.SouthCentralUS;    <span class=\"rem\">/// &lt;summary&gt;</span>  <span class=\"rem\">/// Generic Code that takes and input and executes </span>  <span class=\"rem\">/// a statement against the SQL Azure</span>  <span class=\"rem\">/// &lt;/summary&gt;</span>  <span class=\"rem\">/// &lt;param name=&quot;companyId&quot;&gt;&lt;/param&gt;</span>  <span class=\"kwrd\">static</span> <span class=\"kwrd\">void</span> DoSomething(Int32 customerId)  {      <span class=\"rem\">// Always Start Locally, It Is Less Expensive and Faster</span>      ConnectionStringManager.DataCenterEnum currentDataCenter           = LocalDataCenter;        <span class=\"rem\">// This is the retry loop, handling the retries session</span>      <span class=\"rem\">// is done in the catch for performance reasons</span>      <span class=\"kwrd\">for</span> (Int32 attempt = 1; ; )      {          <span class=\"rem\">// Create a SqlConnection Class, the connection isn't established </span>          <span class=\"rem\">// until the Open() method is called</span>          <span class=\"kwrd\">using</span> (SqlConnection sqlConnection =              <span class=\"kwrd\">new</span> SqlConnection(                  ConnectionStringManager.ConnectionString(currentDataCenter)))          {              <span class=\"kwrd\">try</span>              {                  <span class=\"rem\">// Open the connection</span>                  sqlConnection.Open();                    <span class=\"rem\">// Statement To Call</span>                  String sql = <span class=\"str\">@&quot;SELECT CompanyName FROM [SalesLT].[Customer]&quot;</span> +                       <span class=\"str\">@&quot; WHERE CustomerId = @CustomerId&quot;</span>;                    SqlCommand sqlCommand = <span class=\"kwrd\">new</span> SqlCommand(sql, sqlConnection);                    sqlCommand.Parameters.AddWithValue(<span class=\"str\">&quot;@CustomerId&quot;</span>, customerId);                    <span class=\"kwrd\">using</span> (SqlDataReader sqlDataReader = sqlCommand.ExecuteReader())                  {                      <span class=\"kwrd\">while</span> (sqlDataReader.Read())                      {                          <span class=\"rem\">/// Do Something Wtih CompanyName</span>                      }                        <span class=\"kwrd\">return</span>;                  }              }              <span class=\"kwrd\">catch</span> (SqlException sqlException)              {                  <span class=\"rem\">// Increment attempts</span>                  attempt++;                    <span class=\"rem\">// Find Maximum attempts</span>                  Int32 maxRetryCount = Int32.Parse(                      ConfigurationManager.AppSettings[<span class=\"str\">&quot;ConnectionRetrys&quot;</span>]);                    <span class=\"rem\">// Throw Error if we have reach the maximum number of attempts</span>                  <span class=\"kwrd\">if</span> (attempt == maxRetryCount)                      <span class=\"kwrd\">throw</span>;                    <span class=\"rem\">// Determine if we should retry or abort.</span>                  <span class=\"kwrd\">if</span> (RetryLitmus(sqlException))                  {                      <span class=\"rem\">// Transient Error, Lets Wait And Try Again</span>                      <span class=\"rem\">// In This Data Center</span>                      Thread.Sleep(ConnectionRetryWaitSeconds(attempt));                  }                  <span class=\"kwrd\">else</span> <span class=\"kwrd\">if</span> (currentDataCenter == LocalDataCenter)                  {                      <span class=\"rem\">// Non Transient Error, Lets Try In a Remote DataCenter</span>                      currentDataCenter = ConnectionStringManager.FailOverPartner                          (currentDataCenter).Value;                  }                  <span class=\"kwrd\">else</span>                  {                      <span class=\"rem\">// We have tried a remote datacenter, now it is time to error.</span>                      <span class=\"kwrd\">throw</span>;                  }              }          }      }  }</pre>      <h4>まとめ</h4>    <p>質問、懸念事項、コメントはありますか? 以下に投稿すると、対処を試みることができます。</p>"
