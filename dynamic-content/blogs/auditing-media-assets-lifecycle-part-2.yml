### YamlMime:Yaml
ms.openlocfilehash: 801292d426d23847fd1d299b612d80ddf0955788
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139910124"
Slug: auditing-media-assets-lifecycle-part-2
Title: メディア資産のライフサイクルの監査 – パート 2
Summary: (サンプル コードを使用して) メディア資産のライフ サイクルを監査するのに役立つ一連の投稿のパート 2。 パート 2 では、特に、メディア処理のためにアセットが VM にコピー Storage追跡に重点を置いた内容です。
Content: "<a href=\"https://azure.microsoft.com/blog/2014/07/23/auditing-media-assets-lifecycle-part-1-2\">このブログのパート 1</a> では、メディア資産がいつ作成および削除されたのかを示す資産監査レポートを作成する方法に重点を置いています。 パート 2 では、資産がメディア処理のために Storage アカウントから VM にコピーされる資産を追跡する方法について説明します。 パート 1 で提供したサンプル コードを基に作成します。\n\n&nbsp;\n<h2>資産の追跡</h2>\nジョブを送信すると、ジョブ内のタスクはキューにスケジュールされ、Media Services のスケジューラがタスクを実行する VM を割り当てるまでキューに入ります。 タスクへの入力資産として指定された資産は、VM がタスクに割り当てられるまで VM にコピーされません。 この場合、 <strong>AssetAudit </strong>テーブルにエントリを作成する値として、タスク処理時間を使用できます。\n\n&nbsp;\n<h2>コードの変更</h2>\nAssetAuditEntity クラスに文字列メンバーを追加して、タスクの ID をキャプチャします。この ID を使用すると、Storage から資産がコピーされます。\n<pre class=\"prettyprint\">    public class AssetAuditEntity : TableEntity\n    {\n        public string OperationType { get; set; }\n        <strong>public string OperationData { get; set; }\n</strong>    }</pre>\nProcessJobs と ProcessTasks という 2 つの新しい関数があります。 ProcessJobs 関数は、すべてのジョブをループ処理し、ProcessTasks 関数は特定のジョブのすべてのタスクをループ処理します。 タスクごとに、タスクに関連付けられているすべての履歴イベントを確認し、\"処理\" のイベントが見つけた場合は、イベント タイムスタンプを行キーとして使用して AssetAudit テーブル (OperationType=\"InputToTask\" と OperationData=TaskId) にエントリを作成します。\n<pre class=\"prettyprint\">        static void ProcessJobs()\n        {\n            try\n            {\n                int skipSize = 0;\n                int batchSize = 1000;\n                int currentSkipSize = 0;\n\n                while (true)\n                {\n                    foreach (IJob job in _context.Jobs.Skip(skipSize).Take(batchSize))\n                    {\n                        currentSkipSize++;\n                        Console.WriteLine(\"Processing Job \" + job.Id);\n\n                        ProcessTasks(job);                        \n                    }\n\n                    if (currentSkipSize == batchSize)\n                    {\n                        skipSize += batchSize;\n                        currentSkipSize = 0;\n                    }\n                    else\n                    {\n                        break;\n                    }\n\n                }\n\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// \n        /// &lt;/summary&gt;\n        /// &lt;param name=\"job\"&gt;&lt;/param&gt;\n        static void ProcessTasks(IJob job)\n        {\n            try\n            {\n                foreach (ITask task in job.Tasks)\n                {\n                    Console.WriteLine(\"Processing Task Id:\" + task.Id);\n                    for (int i = 0; i &lt; task.HistoricalEvents.Count; i++)\n                    {\n                        if (task.HistoricalEvents[i].Code == \"Processing\")\n                        {\n                            for (int j = 0; j &lt; task.InputAssets.Count; j++)\n                            {\n                                InsertAssetData(task.InputAssets[j].Id, task.HistoricalEvents[i].TimeStamp.ToString(\"o\"), \"InputToTask\", task.Id);\n                            }\n                        }\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message);\n            }\n        }</pre>\nInsertAssetData 関数が更新され、OperationData の省略可能なパラメーターを受け入れる\n<pre class=\"prettyprint\">        static void InsertAssetData(string _assetId, string _timeStamp, string _operationType<strong>, string _operationData = null</strong>)\n        {\n            try\n            {\n                bool _insert = true;\n                if (_operationType == \"Create\")\n                {\n                    // If operationtype is Create, then check if an entry already exists for the given asset id\n\n                    TableQuery&lt;AssetAuditEntity&gt; query = new TableQuery&lt;AssetAuditEntity&gt;().Where(TableQuery.GenerateFilterCondition(\"PartitionKey\", QueryComparisons.Equal, _assetId));\n                    query.Take(1);\n\n                    TableQuerySegment&lt;AssetAuditEntity&gt; tqs = _assetAuditTable.ExecuteQuerySegmented(query, null);\n                    if ((tqs != null) &amp;&amp; (tqs.Results != null))\n                    {\n                        if (tqs.Results.Count &gt; 0)\n                        {\n                            if (tqs.Results[0].OperationType == \"Create\")\n                            {\n                                _insert = false;\n                            }\n                        }\n                    }\n                }\n\n                if (_insert)\n                {\n                    AssetAuditEntity _asset = new AssetAuditEntity();\n                    _asset.PartitionKey = _assetId;\n                    _asset.RowKey = _timeStamp;\n                    _asset.OperationType = _operationType;\n                    <strong>_asset.OperationData = _operationData;\n</strong>\n                    TableOperation op = TableOperation.Insert(_asset);\n                    _assetAuditTable.Execute(op);\n                }\n            }\n            catch (Exception ex)\n            {                \n                Console.WriteLine(ex.Message);                \n            }\n        }</pre>\n最後に、main 関数が更新され、ProcessJobs 関数が呼び出されます\n<pre class=\"prettyprint\">        static void Main(string[] args)\n        {\n            try\n            {\n                // Create and cache the Media Services credentials in a static class variable.\n                _cachedCredentials = new MediaServicesCredentials(_mediaServicesAccountName, _mediaServicesAccountKey);\n\n                // Used the chached credentials to create CloudMediaContext.\n                _context = new CloudMediaContext(_cachedCredentials);\n\n                _cloudStorage = CloudStorageAccount.Parse(_storageConnectionString);\n\n                _blobClient = _cloudStorage.CreateCloudBlobClient();\n                _tableClient = _cloudStorage.CreateCloudTableClient();\n\n                _assetAuditTable = _tableClient.GetTableReference(\"AssetAudit\");\n                _assetAuditTable.CreateIfNotExists();\n\n                ProcessAssetData();\n                ParseStorageLogs();\n\n                <strong>ProcessJobs();</strong>\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message + ex.InnerException.StackTrace);\n            }\n        }</pre>\n<h2>資産監査データ</h2>\nこのブログのパート 1 で提供されている を使用して上記のコードをマージして実行すると、アセットが Storage からメディア処理 VM にコピーされた時点に関連するエントリで AssetAudit テーブルが更新されます。 使用したテスト アカウントに対する更新されたテーブルの内容のスクリーンショットを次に示します。 上記のコードによって作成された新しいエントリの例を強調しました。 強調表示されたエントリには、資産が作成された時刻と、資産を入力として使用したタスク (タイムスタンプとして RowKey と共に) が表示されます。\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/07/2014-07-08_14h10_26.png\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"2014-07-08_14h10_26\" alt=\"2014-07-08_14h10_26\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2014-07-08_14h10_26_thumb.png\" width=\"1028\" height=\"324\" border=\"0\" /></a>\n\nまた、(このブログExcel Power Queryパート 1 で説明したように) データを使用して、上記のデータを Excelに読み込み、詳細な分析を行います。\n\n&nbsp;\n<h2>考慮事項</h2>\n最後に、アプリケーションにこのサンプル コードを使用する場合は、次の点に注意してください\n<ul>\n <li>このコードは、ジョブ コレクションに依存して、資産がコピーされた時間に関連するイベントをキャプチャし、Storage処理 VM にコピーします。 上記のコードが実行される前に削除されたジョブがある場合、対応するイベントはキャプチャされません。 実行後にアプリケーションがジョブを削除する場合は、ジョブ通知の処理の一環として ProcessTasks 関数を呼び出 <a href=\"https://msdn.microsoft.com/en-us/library/dn261241.aspx\">す必要があります</a>。</li>\n <li>この投稿で提供されるサンプル コードは、1 つのストレージ アカウント内のすべての資産を持つ Media Services アカウントを使用するように設計されています。ただし、複数のストレージ アカウントを使用するように簡単に調整できます。</li>\n</ul>"
