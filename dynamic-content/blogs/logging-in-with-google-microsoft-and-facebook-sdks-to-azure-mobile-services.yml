### YamlMime:Yaml
ms.openlocfilehash: c9df4bea86bf39a777c7b668778ee7e31f93fcde
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139909731"
Slug: logging-in-with-google-microsoft-and-facebook-sdks-to-azure-mobile-services
Title: Google、Microsoft、Facebook SDK を使用して Azure Mobile Services にログインする
Summary: Azure Mobile Services 用の .NET および node.js バックエンドの新しいリリースでは、Google、Microsoft、Facebook のネイティブ SDK を使用してサービスにログインするサポートが追加されました。 この投稿では、クライアント SDK を使用して、モバイル アプリケーションのユーザーにより優れたログイン エクスペリエンスを提供する方法を示します。
Content: "Azure Mobile Services が提供する値の 1 つは、非常にシンプルな API を介してモバイル アプリケーションの認証を実装する簡単な方法です。サポート<em></em>されているプラットフォームのクライアント オブジェクトにログイン関数 (または同等の関数) を呼び出します。ユーザーには、モバイル サービスにログインできるシンプルな Web ベースのインターフェイスが表示されます。 これは、サーバー側の認証<em></em>フローと呼ばれるものです。この場合、サービスはクライアントをプロバイダーに案内し (Web ページのリダイレクトを介して)、それ自体に戻ります。\n\nサーバー側認証を使用すると、アプリケーションを起動できますが、使用する認証プロバイダーにログインをサポートするネイティブ SDK がある場合は、アプリで使用した方がユーザーのエクスペリエンスが向上します。 たとえば、ユーザーが Android デバイスに登録されている場合は、Google アカウントがデバイスに関連付けられている可能性が高いので、資格情報を再入力することなくそのアカウントを使用できると、ユーザー エクスペリエンスが向上します。 Android、iOS または Windows Phone デバイスの Facebook アカウント、または Windows または Windows Phone 上の Microsoft アカウント と同じです。 このシナリオは、クライアント側の<em></em>認証フローと呼ばれるものです。クライアント アプリケーションは(ネイティブ SDK を介して) プロバイダーと直接通信し、プロバイダーから何らかのトークンをモバイル サービスと交換してサービス自体で認証します。\n\nクライアント側の認証フローは、.NET ランタイムではなく、node.js バックエンドで Facebook と Microsoft の認証に対して機能しています。 また、これまでは、どのランタイムでも Google SDK 認証をサポートしていけなかったのです。 node.js バックエンドで Google 認証のサポートをリリースしました。また、.NET SDK 内の 3 つのソーシャル プロバイダーすべてからの SDK からのデータを介した認証もサポートしました。 これは<a href=\"https://stackoverflow.com/q/23185985/751090\">長</a><a href=\"https://stackoverflow.com/q/23285860/751090\">く</a>要求<a href=\"https://github.com/Azure/azure-mobile-services/issues/185\">された</a>機能<a href=\"https://social.msdn.microsoft.com/forums/azure/en-US/51cbf1cb-2de2-4516-aa75-75cbec2069d4/post-of-google-token-is-not-supported-405-error?forum=azuremobile\">で、ライブ</a>で見てもらって良かったと思います。 この投稿では、この新機能を使用する方法について確認します。\n<h2>Microsoft アカウント</h2>\nLive SDK の Windows Phone/Windows Store アプリへのログインは、モバイル サービスの最初のリリース (node.js) 以降、node.js バックエンドへのオプションでした。 .NET バックエンドで有効にした後、それを有効にする手順はノードとまったく同じです。アプリを認証用に登録し、Windows Store ダッシュボード情報をモバイル サービスの ID タブにコピーし、Live SDK をアプリケーションに追加します。Live SDK を使用してログインし、後で SDK から受信した認証トークンをモバイル サービスに送信します。 これらの手順はすべて のチュートリアル<a title=\"https://azure.microsoft.com/en-us/documentation/articles/mobile-services-windows-store-dotnet-single-sign-on/https://azure.microsoft.com/en-us/documentation/articles/mobile-services-windows-store-dotnet-single-sign-on/\" href=\"https://azure.microsoft.com/en-us/documentation/articles/mobile-services-windows-store-dotnet-single-sign-on/\"></a>に記載されています。これらの手順に従って、.NET バックエンドを使用する Live SDK ログインをアプリケーションに追加できます。\n<h2>Facebook ログイン</h2>\nMicrosoft アカウント の場合と同様に、Facebook SDK のトークンを使用してログインするオプションは、node.jsバックエンドで長い間使用されています。 .NET バックエンドでも、このクライアント フローがサポートされます。 また、前のセクションと同様に、クライアント コード (または記述する必要があるサーバー内のコードでも) にまったく違いはありません。そのため、ノードのすべてのチュートリアルが .NET バックエンドにも適用されます。 Facebook SDK を使用してアプリにログインを追加する方法の詳細については、ブログ記事「 <a href=\"https://blogs.msdn.com/b/carlosfigueira/archive/2014/02/05/using-the-facebook-ios-sdk-for-logging-in-to-azure-mobile-services.aspx\">iOS アプリ</a> と <a href=\"https://blogs.msdn.com/b/carlosfigueira/archive/2014/01/08/using-the-facebook-android-sdk-for-logging-in-to-azure-mobile-services.aspx\">Android Apps」を参照してください</a>。\n<h2>Google ログイン</h2>\nGoogle アカウントのクライアント認証フローは、node.js と .NET バックエンドの両方の新機能であり、両方に対して同じように動作します。 Android アプリにログイン操作を追加するシナリオについて説明します。\n<h3>認証用にアプリを登録する</h3>\nGoogle SDK を使用してネイティブ Android アプリの認証を開始する前に、バックエンド モバイル サービスを <a href=\"https://console.developers.google.com/\">Google Developers Console</a> のプロジェクトに接続して \"準備\" する必要があります。 これを行うには、「<a href=\"https://azure.microsoft.com/en-us/documentation/articles/mobile-services-dotnet-backend-android-get-started-users/\">Mobile Service</a> アプリに認証を追加する」チュートリアルの最初のセクションに従います (「Google ログイン用アプリを Mobile Services に登録する」<a href=\"https://azure.microsoft.com/en-us/documentation/articles/mobile-services-how-to-register-google-authentication/\">のオプションに従います</a>)。 完了したら、ネイティブ部分に進む必要があります。\n<h3>Google+ を Android アプリに統合する</h3>\nGoogle サインインをアプリケーションに追加するには、アプリケーションに Google Play 開発者サービスライブラリを追加する必要があります。 Google <a href=\"https://developers.google.com/+/mobile/android/getting-started\">ドキュメントの 「Getting started」</a> ページには、これを行うのに必要なすべての手順が含まれています。 最初の手順では、前の手順で作成したのと同じプロジェクトを使用するのではなく、 <a href=\"https://console.developers.google.com/\">Google Developers Console</a> で新しいプロジェクトを作成することを指示します。 プロジェクトには、Web アプリケーションのクライアント ID が既に存在し、Android インストール済みアプリケーションの新しい OAuth クライアント ID を追加します。\n<h3>Android アプリのサインインの追加</h3>\nプロジェクトGoogle Play適切に設定したら、それを使用してログインを開始し、最初に Google 自体に、次にモバイル サービスにログインできます。 Google Play 開発者サービス を使用する前に、それが存在するかどうかを常に確認する必要があります (以前に発生したエミュレーターが正しくセットアップされていない場合に備えて、デバッグに多くの時間を節約できます)。\n<pre class=\"prettyprint\">    btn.setOnClickListener(new View.OnClickListener() {\n\n        @Override\n        public void onClick(View v) {\n            int isAvailableResult = GooglePlayServicesUtil.isGooglePlayServicesAvailable(activity);\n            if (isAvailableResult == ConnectionResult.SUCCESS) {\n                Log.d(\"msg\", \"Result for isGooglePlayServicesAvailable: SUCCESS\");\n                pickUserAccount();\n            } else {\n                Log.e(\"error\", \"Google play services is not available: \" + isAvailableResult);                \n            }\n        }\n    });</pre>\nサービスがデバイス (実際または仮想) で実行されている状態を確立したら、ユーザーが使用するデバイスに関連付けられているアカウントを選択できます。 このためには <a href=\"https://developer.android.com/reference/com/google/android/gms/common/AccountPicker.html\">、AccountPicker</a> クラスを使用します。このクラスでは、ユーザーが自分のアカウントを選択するための UI が表示されます。または、ユーザーがアカウントを 1 つしか持っている場合は、ユーザーの介入を必要とせずに自動的に選択されます (エクスペリエンスの向上)。\n<pre class=\"prettyprint\">    static final int REQUEST_CODE_PICK_ACCOUNT = 1000;\n    private void pickUserAccount() {\n        String[] accountTypes = new String[] { \"com.google\" };\n        Intent intent = AccountPicker.newChooseAccountIntent(null, null, accountTypes, false, null, null, null, null);\n        startActivityForResult(intent, REQUEST_CODE_PICK_ACCOUNT);\n    }</pre>\nピッカー UI は別のアクティビティとして表示されます。そのため、結果を取得するには onActivityResult メソッドをオーバーライドする必要があります。 結果として、ユーザーが使用するアカウントの名前を取得できます。完了したら、モバイル サービスへのログインに必要なトークンを要求できます。\n<pre class=\"prettyprint\">    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if (requestCode == REQUEST_CODE_PICK_ACCOUNT) {\n            if (resultCode == RESULT_OK) {\n                String accountName = data.getStringExtra(AccountManager.KEY_ACCOUNT_NAME);\n                Log.d(\"msg\", \"Account name: \" + accountName);\n                getTokenAndLogin(accountName);\n            } else if (resultCode == RESULT_CANCELED) {\n                Log.d(\"msg\", \"Activity cancelled by user\");\n            }\n        }\n    }</pre>\nGoogle からサービスにログインするために必要なトークンは、ID トークンです。 Android ID トークンは、Web アプリケーションに対してユーザーを認証するために使用されます。Android アプリは、ユーザーが再度ログインする必要なくリモート サービスと話し合える必要があります。 これは、ユーザーが開発者コンソールで定義されているネイティブ アプリで認証を行い、リモート <em> </em>アプリ (モバイル サービス) にトークンを提示するクロスクライアント認証の形式です。<em></em>これにより、トークンが同じプロジェクトから取得されたことを Google で検証します。<em></em> 同じプロジェクトに関連付けられた 2 つの OAuth クライアント ID を作成したのを覚えていますか? モバイル サービスと Google が通信して、ユーザーがアプリケーションに対してのみ認証されるのは、その方法です。\n\nID トークンを取得するには、デバイスがオンライン (もう 1 つの良い方法) である必要があります。その後、バックグラウンド スレッドに移動してトークンを取得します。これは <a href=\"https://developer.android.com/reference/android/os/AsyncTask.html\">AsyncTask</a> を使用します。\n<pre class=\"prettyprint\">    static final String GOOGLE_SCOPE_TAKE2 = \"audience:server:client_id:\";\n    static final String CLIENT_ID_WEB_APPS = \"0000000000000-0aaaaaaa00aa00aa0aaa0a0aaaaaaa0a.apps.googleusercontent.com\";\n    static final String GOOGLE_ID_TOKEN_SCOPE = GOOGLE_SCOPE_TAKE2 + CLIENT_ID_WEB_APPS;\n\n    private void getTokenAndLogin(String accountName) {\n        if (mAccountName == null) {\n            pickUserAccount();\n        } else {\n            if (isDeviceOnline()) {\n                new GetTokenAndLoginTask(this, GOOGLE_ID_TOKEN_SCOPE, accountName).execute((Void)null);\n            } else {\n                Toast.makeText(this, R.string.not_online, Toast.LENGTH_LONG).show();\n            }\n        }\n    }\n\n    private boolean isDeviceOnline() {\n        ConnectivityManager mgr = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);\n        NetworkInfo netInfo = mgr.getActiveNetworkInfo();\n        return netInfo != null &amp;&amp; netInfo.isConnected();\n    }</pre>\nデバイスがオンラインである検証時に、使用するアカウントと要求のスコープを受け取る <a href=\"https://developer.android.com/reference/com/google/android/gms/auth/GoogleAuthUtil.html#getToken(android.content.Context, java.lang.String, java.lang.String)\">GoogleAuthUtil.getToken</a> メソッドを使用できます。 クライアント間認証の場合、スコープはプレフィックス \"audience:server:client_id:\" の後に Web アプリケーションのクライアント <em>ID</em> (このセクションの最初の手順で作成されました) として定義されます。この場合、Android アプリケーションのクライアント ID は使用しません。 ユーザーがまだアプリケーションにデータの使用を承認していない場合は、UserRecoverableAuthException がスローされ、後で説明するように対処できます。 ユーザーがアプリに自分の情報を使用する許可を与えた場合、トークンが返されます。トークンを取得し、モバイル サービスのログイン呼び出しに送信するには、\"id_token\" というプロパティを持つオブジェクトにラップします。 その呼び出しが完了すると、モバイル サービスにログインし、保護されたリソースにアクセスできます。\n<pre class=\"prettyprint\">    class GetTokenAndLoginTask extends AsyncTask&lt;Void, Void, Void&gt; {\n\n        MainActivity mActivity;\n        String mScope;\n        String mEmail;\n\n        public GetTokenAndLoginTask(MainActivity activity, String scope, String email) {\n            this.mActivity = activity;\n            this.mScope = scope;\n            this.mEmail = email;\n        }\n\n        @Override\n        protected Void doInBackground(Void... params) {\n            try {\n                final String token = fetchIdToken();\n                if (token != null) {\n                    loginToMobileService(token);\n                }\n            } catch (IOException e) {\n                Log.e(\"error\", \"Exception: \" + e);\n            }\n\n            return null;\n        }\n\n        protected void loginToMobileService(final String idToken) {\n            runOnUiThread(new Runnable(){\n\n                @Override\n                public void run() {\n                    mActivity.updateTextView(\"Token: \" + idToken);\n                    JsonObject loginBody = new JsonObject();\n                    loginBody.addProperty(\"id_token\", idToken);\n                    mClient.login(MobileServiceAuthenticationProvider.Google, loginBody, new UserAuthenticationCallback() {\n\n                        @Override\n                        public void onCompleted(MobileServiceUser user, Exception error,\n                                ServiceFilterResponse response) {\n                            if (error != null) {\n                                Log.e(\"error\", \"Login error: \" + error);\n                            } else {\n                                Log.d(\"msg\", \"Logged in to the mobile service as \" + user.getUserId());\n                            }\n                        }\n                    });\n                }\n            });\n        }\n\n        protected String fetchIdToken() throws IOException {\n            try {\n                return GoogleAuthUtil.getToken(mActivity, mEmail, mScope);\n            } catch (UserRecoverableAuthException urae) {\n                mActivity.handleException(urae);\n            } catch (GoogleAuthException gae) {\n                Log.e(\"error\", \"Unrecoverable exception: \" + gae);\n            }\n            return null;\n        }\n    }</pre>\n最後のピースは、getToken メソッドが回復可能な例外を返したケースを処理する方法です。 この場合、例外によって指定されたアクティビティを開始することで例外を処理できます。これにより、ユーザーにアプリの使用を承認するよう求めるダイアログが表示されます。 次に、onActivityResult の実装を更新して、アプリが承認画面から戻った場合に、トークンを再度取得する呼び出しを行う必要があります (ユーザーがアプリを承認している場合は成功します)。\n<pre class=\"prettyprint\">    static final int REQUEST_CODE_PICK_ACCOUNT = 1000;\n    static final int REQUEST_CODE_RECOVER_FROM_PLAY_SERVICES_ERROR = 1001;\n\n    public void handleException(final Exception e) {\n        // Because this call comes from the AsyncTask, we must ensure that the following\n        // code instead executes on the UI thread.\n        runOnUiThread(new Runnable() {\n            @Override\n            public void run() {\n                if (e instanceof GooglePlayServicesAvailabilityException) {\n                    // The Google Play services APK is old, disabled, or not present.\n                    // Show a dialog created by Google Play services that allows\n                    // the user to update the APK\n                    int statusCode = ((GooglePlayServicesAvailabilityException)e)\n                            .getConnectionStatusCode();\n                    Dialog dialog = GooglePlayServicesUtil.getErrorDialog(statusCode,\n                            MainActivity.this,\n                            REQUEST_CODE_RECOVER_FROM_PLAY_SERVICES_ERROR);\n                    dialog.show();\n                } else if (e instanceof UserRecoverableAuthException) {\n                    // Unable to authenticate, such as when the user has not yet granted\n                    // the app access to the account, but the user can fix this.\n                    // Forward the user to an activity in Google Play services.\n                    Intent intent = ((UserRecoverableAuthException)e).getIntent();\n                    startActivityForResult(intent,\n                            REQUEST_CODE_RECOVER_FROM_PLAY_SERVICES_ERROR);\n                }\n            }\n        });\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if (requestCode == REQUEST_CODE_PICK_ACCOUNT) {\n            if (resultCode == RESULT_OK) {\n                String accountName = data.getStringExtra(AccountManager.KEY_ACCOUNT_NAME);\n                Log.d(\"msg\", \"Account name: \" + accountName);\n                getTokenAndLogin(accountName);\n            } else if (resultCode == RESULT_CANCELED) {\n                Log.d(\"msg\", \"Activity cancelled by user\");\n            }\n        } else if (requestCode == REQUEST_CODE_RECOVER_FROM_PLAY_SERVICES_ERROR &amp;&amp; resultCode == RESULT_OK) {\n            getTokenAndLogin();\n        }\n    }</pre>\nさらに、モバイル アプリにネイティブ Google 認証を追加し、それを使用してモバイル サービスにログインする方法について説明しました。 前に説明したように、これは、アプリケーション バックエンドと .NET バックエンドのnode.js同じように動作します。\n<h2>まとめ</h2>\nしばらくの間要求された機能をリリースできるとき、それを行ったのは常に良いことです。 これにより、Azure Mobile Servicesユーザーのログイン エクスペリエンスを向上することで、アプリケーションにより多くの価値が追加されます。\n\n通常どおり、この投稿のコメントとして、Twitter <a href=\"https://twitter.com/azuremobile\">@AzureMobile</a> または MSDN フォーラムでフィードバック <a href=\"https://social.msdn.microsoft.com/Forums/windowsazure/en-US/home?forum=azuremobile\">をお送りください</a>。"
