### YamlMime:Yaml
ms.openlocfilehash: e63d8b4fa153fec7ac9785e2c01488a204a41b95
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139889851"
Slug: custom-analyzers-in-azure-search
Title: Azure Search のカスタムアナライザー
Summary: Azure Search、Web アプリケーションやモバイルアプリケーションを構築する開発者は、優れた製品エクスペリエンスを提供するために、検索エキスパートである必要はありません。
Content: >-
  <p>Azure Search、Web アプリケーションやモバイルアプリケーション &rsquo; を構築する開発者は、製品に優れた検索機能を追加するために、検索エキスパートになる必要がないと考えています。 私たちは、私たちの価値提案の中核をシンプルにし、検索サービスを迅速かつ簡単に作成および構成するプロセスを実現しています。 ほとんどの場合、Azure portal、インデクサー、および SDK を使用しているお客様は、30分以内にアプリケーションに検索を統合できます。</p>


  <p>単純に価値がありますが、幅広い要件を持つ顧客の期待にも対応することを目指しています。 より高度なシナリオに対処するために、サービス&#39;s 内部操作の特定の側面を&#39;しました。 たとえば、ドキュメントの順位付けを <a href="https://msdn.microsoft.com/en-us/library/azure/dn798928.aspx">スコアリングプロファイル</a> で構成して、インデックス内のフィールドの相対的な重要度をいくつかの要因に基づいて再定義することができます。</p>


  <p>同じ原則に従って、カスタムアナライザーを定義する機能を提供することで、より多くの方法で字句解析を制御する必要があります。</p>


  <h2>字句解析のカスタマイズ</h2>


  <p>ここでは、以前の投稿: <a href="https://aka.ms/linguistics"><u><font color="#0066cc">Azure Search での言語サポート</font></u></a>の概念について説明します。 &nbsp;&nbsp;ここでは、自然言語でコンテンツを分析する複雑さと、使用される言語に応じてこのプロセスがどのように変化するかについて説明します。 この問題は、ソースコード、マークアップ言語、製品コードなどを含む任意のテキストに一般化することができます。 このような場合は、他のすべてをフィルターで除外する際に重要な用語を抽出できるように、構文アナライザー &nbsp; を正しく構成する必要があります。</p>


  <p>Analyzer は、次のように指定する構成です。</p>


  <ul>
      <li>文字フィルター &ndash; のシーケンスによって、入力テキストの特定の文字または記号が除外または置き換えられる</li>
      <li>トークナイザは、連続するテキストを独立したトークンに分割します。たとえば、文を単語に分割します。</li>
      <li>一連のトークンフィルター-すべての文字を小文字に変換する小文字のフィルターなど、トークナイザによって生成されるトークンをフィルターで除外または変更します。</li>
  </ul>


  <p>2015-02-28-Preview API バージョンでは、 <a href="https://lucene.apache.org/core/">Lucene</a>の定義済みのトークナイザー、トークンフィルター、および char フィルターに基づいてカスタムアナライザーを作成できる新しいインターフェイスを公開&#39;ます。 サポートされているすべてのトークナイザー、トークンフィルター、および文字フィルターの一覧を含む新しい API の詳細については、 <a href="https://aka.ms/azsanalysis">こちら</a>を参照してください。</p>


  <p>次のセクションでは、カスタムアナライザーの構成の &nbsp; 例として名前 &nbsp; のカタログを検索するためのインデックス定義を作成する方法について&#39;説明します。</p>


  <h2>ユーザーがカスタムアナライザーを使用して検索する</h2>


  <p>この簡略化された例では、すべてのアクターの架空のカタログを検索します。 インデックスの定義を次に示します。</p>


  <p><font face="Consolas" size="2">{<br />

  &nbsp;&quot;名前 &quot; : &quot; 名前 &quot; 、<br />

  &nbsp;&quot;フィールド &quot; : [<br />

  &nbsp;&nbsp;&nbsp; { &quot; 名前 &quot; : &quot; id &quot; , &quot; 型 &quot; : &quot; Edm. 文字列 &quot; , &quot; キー &quot; : true, &quot; 検索 &quot; 可能: false},<br />

  &nbsp;&nbsp;&nbsp; { &quot; name &quot; : &quot; name &quot; , &quot; type &quot; : &quot; Edm. String &quot; }<br />

  &nbsp; ]<br />

  }</font></p>


  <p><br />

  この例では、インデックスには、キーだけでなく、フィールド &quot; 名 &quot; が1つだけ含まれています。 この名前フィールドは検索可能であり、標準のトークナイザと小文字のフィルターを使用する既定の standard analyzer で分析されます。 "Stallone" という名前 &quot; を検索すると、 &quot; Sylvester stallone のドキュメントが返されます。 ただし、名前 &quot; Skarsgard &quot; を検索した場合、アクター &quot; Stellan skarsg &aring; rd &quot; は返されません。これは、クエリ内の名前のスペルが &#39;&aring; ではなく&#39; &#39;であるためです。 &#39;</p>


  <p>多くの場合、キーボードでの書き込み時に diacritic をスキップします。 幸いなことに、このような状況は、ascii の <a href="https://lucene.apache.org/core/4_10_0/analyzers-common/org/apache/lucene/analysis/miscellaneous/ASCIIFoldingFilter.html">折りたたみフィルター</a> を使用して簡単に対処できます。 ascii 圧縮フィルターでは、ascii 以外の文字はすべて ascii に相当する文字に変換されます。 次のようにインデックス定義に変更を加えて、ASCII フォールドフィルターを標準アナライザーの構成に追加できます。</p>


  <p><font size="2"><font face="Consolas">{<br />

  &nbsp;&quot;名前 &quot; : &quot; 名前 &quot; 、</font></font><br />

  <font face="Consolas" size="2">&nbsp;&quot;フィールド &quot; : [<br />

  &nbsp;&nbsp;&nbsp; { &quot; 名前 &quot; : &quot; id &quot; , &quot; 型 &quot; : &quot; Edm. 文字列 &quot; , &quot; キー &quot; : true, &quot; 検索 &quot; 可能: false},<br />

  &nbsp;&nbsp;&nbsp;{ &quot; name &quot; : &quot; name &quot; , &quot; type &quot; : &quot; Edm. String &quot; , <strong> &quot; analyzer &quot; : &quot; my_standard &quot; </strong> }<br />

  &nbsp; ],</font><br />

  <font face="Consolas"><font size="2"><strong>&nbsp;&quot;アナライザー &quot; : [<br />

  &nbsp;&nbsp;&nbsp; {<br />

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;名前 &quot; : &quot; my_standard &quot; 、<br />

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; @odata.type &quot; : &quot; #Microsoft、CustomAnalyzer &quot; 、<br />

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;トークナイザ &quot; : &quot; standard &quot; 、<br />

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;tokenfilters &quot; : [ &quot; 小文字 &quot; 、 &quot; asciifolding &quot; ]<br />

  &nbsp;&nbsp;&nbsp; }<br />

  &nbsp; ]</strong><br />

  }</font></font></p>


  <p><br />

  [名前] フィールドで、analyzer プロパティが <strong>my_standard</strong>に設定されていることに注意してください。 ASCII フォールドフィルターは、検索時およびインデックス作成時に適用されます。</p>


  <h2>発音検索</h2>


  <p>ユーザーエクスペリエンスをさらに向上させるために、発音フィルターを使用して、クエリなど &quot; のサウンドを有効 &quot; にすることができます。 たとえば、alek Bold &quot; を &quot; 検索した場合、Alek Baldwin のドキュメントは返されません。 この問題に対処するために、音声トークンフィルターを使用し <a href="https://en.wikipedia.org/wiki/Metaphone">て音声で</a>名前にインデックスを付けるようにフィールドを構成できます。 このフィルターを追加するには、次のようにインデックス定義を変更します。</p>


  <p><font face="Consolas" size="2">{<br />

  &nbsp;&quot;名前 &quot; : &quot; 名前 &quot; 、<br />

  &nbsp;&quot;フィールド &quot; : [<br />

  &nbsp;&nbsp;&nbsp; { &quot; 名前 &quot; : &quot; id &quot; , &quot; 型 &quot; : &quot; Edm. 文字列 &quot; , &quot; キー &quot; : true, &quot; 検索 &quot; 可能: false},<br />

  &nbsp;&nbsp;&nbsp; { &quot; name &quot; : &quot; name &quot; , &quot; type &quot; : &quot; Edm. String &quot; , &quot; analyzer &quot; : &quot; my_standard &quot; }<br />

  &nbsp; ],<br />

  &nbsp;&quot;アナライザー &quot; : [<br />

  &nbsp;&nbsp;&nbsp; {<br />

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;名前 &quot; : &quot; my_standard &quot; 、<br />

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; @odata.type &quot; : &quot; #Microsoft、CustomAnalyzer &quot; 、<br />

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;トークナイザ &quot; : &quot; standard &quot; 、<br />

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;tokenfilters &quot; : [ &quot; 小文字 &quot; 、 &quot; asciifolding &quot; 、 <strong> &quot; ふりがな &quot; </strong> ]<br />

  &nbsp;&nbsp;&nbsp; }<br />

  &nbsp; ]<br />

  }</font></p>


  <p><br />

  ASCII フォールドと発音トークンフィルターを使用すると、カタログ名を検索するためのアプリケーションでは、ユーザーのミスや漏れに対する耐性が高くなります。</p>


  <h2>インデックスと検索固有のアナライザー</h2>


  <p>さらに柔軟性を高めるために、indexAnalyzer と searchanalyzer と &nbsp; いう2つの新しいフィールドプロパティを追加&#39;ます。 これで、検索時 &nbsp; およびインデックス作成時に別のアナライザーを適用するように設定でき&#39;ます。 たとえば、前の例で、アクター名に対して高速プレフィックス一致を有効にするとします。これを行うには、インデックス作成時に <a href="https://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ngram/EdgeNGramTokenFilter.html">Edgengram</a> トークンフィルターを適用する方法があります。 そのために、インデックス名のフラグメントに専用のフィールドを追加して、効率的なプレフィックス照合を行う&#39;ます。 変更されたインデックスの定義を&#39;してみましょう。</p>


  <p><font face="Consolas" size="2">{<br />

  &nbsp;&quot;名前 &quot; : &quot; 名前 &quot; 、<br />

  &nbsp;&quot;フィールド &quot; : [<br />

  &nbsp;&nbsp;&nbsp; { &quot; 名前 &quot; : &quot; id &quot; , &quot; 型 &quot; : &quot; Edm. 文字列 &quot; , &quot; キー &quot; : true, &quot; 検索 &quot; 可能: false},<br />

  &nbsp;&nbsp;&nbsp; { &quot; name &quot; : &quot; name &quot; , &quot; type &quot; : &quot; Edm. String &quot; , &quot; analyzer &quot; : &quot; my_standard &quot; },<br />

  <strong>&nbsp;&nbsp;&nbsp; { &quot; name &quot; : &quot; partialname &quot; , &quot; type &quot; : &quot; Edm. String &quot; , &quot; searchanalyzer &quot; : &quot; standard &quot; , &quot; indexanalyzer &quot; : &quot; prefix &quot; }</strong><br />

  &nbsp; ],<br />

  &nbsp;&quot;アナライザー &quot; : [<br />

  &nbsp;&nbsp;&nbsp; {<br />

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;名前 &quot; : &quot; my_standard &quot; 、<br />

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; @odata.type &quot; : &quot; #Microsoft、CustomAnalyzer &quot; 、<br />

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;トークナイザ &quot; : &quot; standard &quot; 、<br />

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;tokenfilters &quot; : [ &quot; 小文字 &quot; 、 &quot; asciifolding &quot; 、 &quot; ふりがな &quot; ]<br />

  &nbsp;&nbsp;&nbsp; },</font><br />

  <font face="Consolas"><font size="2"><strong>&nbsp;&nbsp;&nbsp; {<br />

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;名前 &quot; : &quot; prefix &quot; 、<br />

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; @odata.type &quot; : &quot; #Microsoft、CustomAnalyzer &quot; 、<br />

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;トークナイザ &quot; : &quot; standard &quot; 、<br />

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;tokenfilters &quot; : [ &quot; 小文字 &quot; 、 &quot; my_edgeNGram &quot; ]<br />

  &nbsp;&nbsp;&nbsp; }<br />

  &nbsp; ],<br />

  &nbsp;&quot;tokenfilters &quot; : [<br />

  &nbsp;&nbsp;&nbsp; {<br />

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;名前 &quot; : &quot; my_edgeNGram &quot; 、<br />

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; @odata.type &quot; : &quot; #Microsoft、EdgeNGramTokenFilter &quot; 、<br />

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;mingram &quot; : 2、<br />

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;maxgram &quot; :20<br />

  &nbsp;&nbsp;&nbsp; }<br />

  &nbsp; ]</strong><br />

  }</font></font></p>


  <p><br />

  名前ごとにこのセットアップを使用すると、複数の用語のインデックスが作成されます。 たとえば、名前が Pacino の場合、 <strong>プレフィックス</strong> アナライザーによって次のように生成されます。</p>


  <p><br />

  &nbsp;&nbsp;&nbsp; pa<br />

  &nbsp;&nbsp;&nbsp; パック<br />

  &nbsp;&nbsp;&nbsp; paci<br />

  &nbsp;&nbsp;&nbsp; pacin<br />

  &nbsp;&nbsp;&nbsp; pacino</p>


  <p><br />

  このため、partialName &quot; のような &quot; 検索クエリでは、partialname フィールドに対して期待される結果が返されます。 [PartialName] フィールドの searchAnalyzer は、クエリ用語が既に正しいプレフィックス形式であるため、[標準 &quot; ] に &quot; 設定されています。</p>


  <p>説明したようなインデックス定義を再構築&#39;場合は、 <a href="https://msdn.microsoft.com/en-us/library/azure/dn798928.aspx">スコアリングプロファイル</a> を使用して、正確な名前フィールドとの一致を常に部分一致よりも高いスコアにすることができます。</p>


  <p><font face="Consolas" size="2">&quot;scoringProfiles &quot; : [<br />

  &nbsp; {<br />

  &nbsp;&nbsp;&nbsp;&quot;名前 &quot; : &quot; exactFirst &quot; 、<br />

  &nbsp;&nbsp;&nbsp;&quot;テキスト &quot; : {<br />

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;重み &quot; : { &quot; name &quot; : 2, &quot; partialname &quot; : 1} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </font></p>


  <p><font face="Consolas" size="2">&nbsp;&nbsp;&nbsp; }<br />

  &nbsp; }<br />

  ]</font></p>


  <p><br />

  検索要求は次のようになります。</p>


  <blockquote>

  <p><br />

  https://[サービス名].search.windows.net/indexes/names/docs?search=PaciscoringProfile&amp;=exactFirstapi-version&amp;=2015-02-28-Preview</p>

  </blockquote>


  <p>または、最近公開された <a href="https://msdn.microsoft.com/en-us/library/azure/mt589323.aspx">Lucene</a> クエリ言語を使用し、クエリの一部としてフィールドの相対的な重要度を定義することもできます。</p>


  <blockquote>

  <p><br />

  https://[サービス名].search.windows.net/indexes/names/docs?search=name:Paci^2 partialName:PaciqueryType&amp;=fullapi-version&amp;=2015-02-28-Preview</p>

  </blockquote>


  <h2>まとめ</h2>


  <p>ユーザーがカスタム アナライザー構成を作成できるようにすることで&#39;多くの機能を利用できます。 力を持つには責任があります。 目的の結果を達成するには、ドキュメントと検索クエリがどのように分析されるのかについての基本的な理解が必要です。 この記事を読み始めやすくなできればと思います。</p>


  <p>詳細については、このトピックの <a href="https://aka.ms/azsanalysis">MSDN ドキュメント ページ</a> を参照してください。 お問い合わせやフォーラムに関する質問Stack Overflow Azure Search <a href="https://stackoverflow.com/tags/azure-search">にお問い</a> 合 <a href="https://social.msdn.microsoft.com/Forums/en-US/home?forum=azuresearch">わせください</a>。 いつでも&#39;フィードバックをお寄せください。<a href="https://feedback.azure.com/forums/263029-azure-search/"></a></p>
