### YamlMime:Yaml
ms.openlocfilehash: a1e22b9fbc6ae5a472ffe2aa7f53da184983f2be
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139895231"
Slug: using-the-service-bus-via-rest-http
Title: Using the Service Bus via REST / HTTP (REST / HTTP を介した Service Bus の使用)
Summary: '[この記事は AppFabric チームによって投稿されました。] 2011 Service Bus CTP で導入された Durable Messaging の新機能は非常に優れ、新しい機能よりも優れています。'
Content: "<p>[この記事は AppFabric チームによって投稿されました。]</p>  <p>2011 年 5 月の CTP で導入された<a href=\"https://blogs.msdn.com/b/appfabric/archive/2011/05/14/announcing-the-windows-azure-appfabric-ctp-may-and-june-releases.aspx\">新しい Service Bus Durable Messaging</a> 機能は非常に優れています。また、AppFabric に追加された新しいメッセージング機能の多くよりも優れた点は、HTTP を使用して任意のプラットフォーム上のクライアントからアクセスできるという事実です。 この投稿では、メッセージングに Service Bus REST エンドポイントを使用する方法を紹介します。その一部では、10 月<a href=\"https://blogs.msdn.com/b/willpe/archive/2010/11/01/getting-started-with-service-bus-v2-october-ctp-connection-points.aspx\">の CTP</a> を思い出す場合があります。キューを使用します (そのため、火曜日からの <a href=\"https://blogs.msdn.com/b/appfabric/archive/2011/05/17/an-introduction-to-service-bus-queues.aspx\">David</a> の投稿を見てみるのも良いアイデアです)。また、HTTP での Access Control <a href=\"https://blogs.msdn.com/b/willpe/archive/2011/05/12/getting-access-control-service-tokens-via-http.aspx\">トークン</a>の動作方法に関する優れた入門です。 も。</p>  <h3>RESTful サービスの前Service Bus</h3>  <p>通常、Service Bus のユーザーは AppFabric SDK をダウンロードしてインストールし、<i>Microsoft.ServiceBus</i> や <i>Microsoft.ServiceBus.Messaging</i> への参照を追加し、<a href=\"https://msdn.microsoft.com/en-us/library/microsoft.servicebus.servicebusnamespaceclient.aspx\">ServiceBusNamespaceClient</a> を使用して管理操作 (キュー、トピック、サブスクリプションの作成、列挙、削除) または <a href=\"https://msdn.microsoft.com/en-us/library/microsoft.servicebus.messaging.messagingfactory.aspx\">MessagingFactory</a> を使用してメッセージを送受信します。 アドレス指定やセキュリティなど、詳細は SDK によって行います。Access Control Service トークンを取得または更新する必要はありません。また、サービスと直接やり取りする必要はありません。SDK を使用します。 REST エンドポイントを使用すると、少なくとももう少し楽しくできるメタルに少し近づけます。 </p>  <p>可能な限り、SDK を使用する必要があります。 これは、サービスの基になる複雑さの一部からユーザーを守り、将来機能が変化する中で保護するのに役立つ場合があります。また、frankly の方がはるかに簡単です。 しかし、デスクトップ以外の .Net Framework バージョン (Windows Phone 7 や Silverlight など) で作業する場合や、microsoft 以外のプラットフォーム (iOS、Android、Java、PHP、Ruby など) で作業する場合や、以前のバージョンの .Net Framework を操作する場合など、SDK を使用できない場合は十分な時間があります。</p>  <p>便宜上、一貫性を確保するために、この投稿のコード サンプルは C# に示されています。これは、もちろん、iOS、PHP、または Ruby から Service Bus を使用するときに C# で記述するからではありません。 今日は、ユーザーの多くが使い慣れた言語から REST API を使用する基本の一部を示す方法に注目したいと思います。 しかし、プラットフォームやデバイス間で Service Bus を使用して実行できるすばらしいことを示す、より広範な言語での今後の投稿を楽しみにできます。</p>  <p>この投稿では、開始するために 5 つのことを取り上げます。コメント (下記) または <a href=\"https://social.msdn.microsoft.com/Forums/en-US/appfabricctp/\">AppFabric CTP フォーラム</a>で、詳細、例、ガイダンスが必要な領域に関するフィードバックをお寄せください。 </p>  <ol>  <li>アプリケーションからセキュリティ トークンを取得Access Control Service </li>  <li>サービス名前空間にキューを作成する </li>  <li>キューにメッセージを送信する </li>  <li>キューからメッセージを受信する </li>  <li>キューを削除する </li>  </ol>  <p>ビジー状態になります。そのため、<a href=\"https://portal.appfabriclabs.com/\">AppFabric Labs</a> ポータルでアカウントを設定し、[Lets はじめに!</p>  <h3>セキュリティ トークンの取得と使用</h3>  <p>先週、HTTP 経由で <a href=\"https://blogs.msdn.com/b/willpe/archive/2011/05/12/getting-access-control-service-tokens-via-http.aspx\">Access Control Service</a> トークンを取得して理解する方法に関するガイダンスを提供しました。そのため、このトピックでは、今日は非常に詳細な情報を提供する必要があります。 言うまでもなく、Service Bus では、次のように HTTP 承認ヘッダーに WRAP アクセス トークンを提示する必要があります。 </p>  <pre class=\"code\"><span class=\"keyword\">Authorization</span>: <span class=\"string\">WRAP access_token=\"<i>&lt;Your Token Here&gt;</i>\"</span></pre>  <p>まず、AppFabric ポータルで検索できる発行者名とキーを使用して、 <a href=\"https://portal.appfabriclabs.com/\">ACS からトークンを取得します</a>。 </p>  <pre class=\"code\"><span class=\"keyword\">string</span> serviceNamespace = <span class=\"string\">\"contoso\"</span>;  <span class=\"keyword\">string</span> issuerName  = <span class=\"string\">\"owner\"</span>;  <span class=\"keyword\">string</span> issuerPassword = <span class=\"string\">\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa=\"</span>;    <span class=\"keyword\">string</span> acsBaseAddress = <span class=\"string\">\"https://\"</span> + serviceNamespace + <span class=\"string\">\"-sb.accesscontrol.appfabriclabs.com/\"</span>;    <span class=\"comment\">// Note that the scheme is Http</span>  <span class=\"keyword\">string</span> relyingPartyAddress = <span class=\"string\">\"https://\"</span> + serviceNamespace + <span class=\"string\">\".servicebus.appfabriclabs.com/\"</span>;    <span class=\"comment\">// Create the body of the Post Request, formatted as a HTTP Form</span>  <span class=\"keyword\">string</span> postData = <span class=\"string\">\"wrap_scope=\"</span> + <span class=\"user-type\">Uri</span>.EscapeDataString(relyingPartyAddress) +                    <span class=\"string\">\"&amp;wrap_name=\"</span> + <span class=\"user-type\">Uri</span>.EscapeDataString(issuerName) +                    <span class=\"string\">\"&amp;wrap_password=\"</span> + <span class=\"user-type\">Uri</span>.EscapeDataString(issuerPassword);    <span class=\"keyword\">string</span> authorizationToken;  <span class=\"keyword\">using</span> (<span class=\"user-type\">WebClient</span> acsWebClient = new<span></span> <span class=\"user-type\">WebClient</span>())  {      <span class=\"comment\">// The response contains the access token and its expiry time formatted as an HTTP       // Form like: wrap_access_token=&lt;token&gt;&amp;wrap_expiry_time=2000</span>      <span class=\"keyword\">string</span> response = acsWebClient.UploadString(acsAddress, <span class=\"string\">\"POST\"</span>, postData);        <span class=\"keyword\">string</span>[] tokenVariables = response.Split(<span class=\"string\">'&amp;'</span>);      <span class=\"keyword\">string</span>[] tokenVariable = tokenVariables[0].Split(<span class=\"string\">'='</span>);      authorizationToken = <span class=\"user-type\">Uri</span>.UnescapeDataString(tokenVariable[1]);  }</pre>  <p>アクセス トークンには有効期限 (現在は 20 分) が含まれているので、有効期限が切れるまで同じトークンを何度も繰り返し使用できます。 ただし、有効期限が経過したら、新しいトークンを要求する必要Access Control Service。 次に、サービス バスの呼び出しに使用する WebClient を作成します。Authorization ヘッダーを正しく設定して初期化します。このヘッダーは、サービス バスに対して行うすべての呼び出しに存在する必要があります。</p>  <pre class=\"code\"><span class=\"user-type\">WebClient</span> webClient = <span class=\"keyword\">new</span> <span class=\"user-type\">WebClient</span>();  webClient.Headers[<span class=\"string\">\"Authorization\"</span>] = <span class=\"string\">\"WRAP access_token=\\\"\"</span> + authorizationToken + <span class=\"string\">\"\\\"\"</span>;</pre>  <h3>新しいキューの作成</h3>  <p>10 月の CTP では、名前空間管理のアイデアを導入しました。永続的な Service Bus エンティティを作成、列挙、削除する明示的な RESTful インターフェイスです (5 月の CTP では、キュー、トピック、サブスクリプションです)。 その概念は、ほんの数点の変更で 5 月の CTP にまで適用されます。 確立された RESTful パターンを引き続き使用します (HTTP GET を使用して取得/列挙します。作成する HTTP PUT。削除する HTTP DELETE) を使用して Atom フィードとエントリを操作します。管理名前空間 (以前の https:// your-namespace-mgmt.servicebus.appfabriclabs.com/) とサービス名前空間 (まだ https://&lt;&lt; our-namespace.servicebus.appfabriclabs.com&gt;&gt;) を組み合わせることで、簡略化しました。</p>  <p>キューは、サービス名前空間内の任意の場所に存在できます。キューの説明を名前空間の \"空いている\" URI に設定して作成します。 要求に対して正しいコンテンツの種類 (<b>Content-Type: application/atom+xml</b>) を指定し、それを定義する Atom エントリを含む新しいキューの URI に <b>HTTP PUT</b> を発行する必要があります (secure, https スキームを使用)。</p>  <pre class=\"code\"><span class=\"comment\">// Note that the scheme is Https</span>  <span class=\"keyword\">string</span> serviceAddress = <span class=\"string\">\"https://\"</span> + serviceNamespace + <span class=\"string\">\".servicebus.appfabriclabs.com/\"</span>;    <span class=\"keyword\">string</span> queueName = <span class=\"string\">\"MyFirstQueue\"</span>;  <span class=\"keyword\">string</span> putData = <span class=\"string\">@\"&lt;entry xmlns=\"\"https://www.w3.org/2005/Atom\"\"&gt;                       &lt;title type=\"\"text\"\"&gt;\"</span> + queueName + <span class=\"string\">@\"&lt;/title&gt;                       &lt;content type=\"\"application/xml\"\"&gt;                         &lt;QueueDescription xmlns:i=\"\"https://www.w3.org/2001/XMLSchema-instance\"\" xmlns=\"\"\"\" /&gt;                       &lt;/content&gt;                     &lt;/entry&gt;\"</span>;    <span class=\"keyword\">string</span> queueAddress = serviceAddress + queueName;    webClient.Headers[<span class=\"string\">\"Content-Type\"</span>] = <span class=\"string\">\"application/atom+xml\"</span>;  <span class=\"keyword\">string</span> response = webClient.UploadString(queueAddress, <span class=\"string\">\"PUT\"</span>, putData);</pre>  <p>要求に対する応答には、新しく作成されたキューの Atom エントリ (下) が含まれるので、キューの説明のすべての設定可能なプロパティが<a href=\"https://msdn.microsoft.com/en-us/library/microsoft.servicebus.messaging.queuedescription.aspx\">含まれる。</a> 既存のキューに対する更新は許可されませんが、新しいキューを作成するときに、これらのプロパティを [キューの説明] に含めることができます。</p>  <pre class=\"xml code\">&lt;<span class=\"element\">entry</span> <span class=\"attribute\">xmlns</span>=\"https://www.w3.org/2005/Atom\"&gt;    &lt;<span class=\"element\">id</span>&gt;https://willpe.servicebus.appfabriclabs.com/MyFirstQueue&lt;/<span class=\"element\">id</span>&gt;    &lt;<span class=\"element\">title</span> <span class=\"attribute\">type</span>=\"text\"&gt;<span class=\"element-content\">MyFirstQueue</span>&lt;/<span class=\"element\">title</span>&gt;    &lt;<span class=\"element\">published</span>&gt;<span class=\"element-content\">2011-05-17T20:26:00Z</span>&lt;/<span class=\"element\">published</span>&gt;    &lt;<span class=\"element\">updated</span>&gt;<span class=\"element-content\">2011-05-17T20:26:00Z</span>&lt;/<span class=\"element\">updated</span>&gt;    &lt;<span class=\"element\">author</span>&gt;      &lt;<span class=\"element\">name</span>&gt;<span class=\"element-content\">willpe</span>&lt;/<span class=\"element\">name</span>&gt;    &lt;/<span class=\"element\">author</span>&gt;    &lt;<span class=\"element\">link</span> <span class=\"attribute\">rel</span>=\"self\" <span class=\"attribute\">href</span>=\"https://willpe.servicebus.appfabriclabs.com/MyFirstQueue\"/&gt;    &lt;<span class=\"element\">content</span> <span class=\"attribute\">type</span>=\"application/xml\"&gt;      &lt;<span class=\"element\">QueueDescription</span> <span class=\"attribute\">xmlns</span>=\"\" <span class=\"attribute\">xmlns:i</span>=\"https://www.w3.org/2001/XMLSchema-instance\"&gt;        &lt;<span class=\"element\">LockDuration</span>&gt;<span class=\"element-content\">PT30S</span>&lt;/<span class=\"element\">LockDuration</span>&gt;        &lt;<span class=\"element\">MaxQueueSizeInBytes</span>&gt;<span class=\"element-content\">104857600</span>&lt;/<span class=\"element\">MaxQueueSizeInBytes</span>&gt;        &lt;<span class=\"element\">RequiresDuplicateDetection</span>&gt;<span class=\"element-content\">false</span>&lt;/<span class=\"element\">RequiresDuplicateDetection</span>&gt;        &lt;<span class=\"element\">RequiresSession</span>&gt;<span class=\"element-content\">false</span>&lt;/<span class=\"element\">RequiresSession</span>&gt;        &lt;<span class=\"element\">DefaultMessageTimeToLive</span>&gt;<span class=\"element-content\">P10675199DT2H48M5.4775807S</span>&lt;/<span class=\"element\">DefaultMessageTimeToLive</span>&gt;        &lt;<span class=\"element\">DeadLetteringOnMessageExpiration</span>&gt;<span class=\"element-content\">false</span>&lt;/<span class=\"element\">DeadLetteringOnMessageExpiration</span>&gt;        &lt;<span class=\"element\">DuplicateDetectionHistoryTimeWindow</span>&gt;<span class=\"element-content\">PT10M</span>&lt;/<span class=\"element\">DuplicateDetectionHistoryTimeWindow</span>&gt;      &lt;/<span class=\"element\">QueueDescription</span>&gt;    &lt;/<span class=\"element\">content</span>&gt;  &lt;/<span class=\"element\">entry</span>&gt;</pre>  <h3>キューへのメッセージの送信</h3>  <p>REST エンドポイントを使用したメッセージの送信は非常に単純です。HTTP: メッセージの本文を Authorization ヘッダーを指定してキューの受信メッセージ URI に送信します (メッセージの本文に適切なコンテンツの種類を指定します)。</p>  <pre class=\"code\"><span class=\"keyword\">string</span> messageBody = \"Hello World!\";  <span class=\"keyword\">string</span> sendAddress = serviceAddress + queueName + <span class=\"string\">\"/Messages\"</span>;    webClient.Headers[<span class=\"string\">\"Content-Type\"</span>] = <span class=\"string\">\"text/plain\"</span>;  webClient.UploadString(sendAddress, <span class=\"string\">\"POST\"</span>, messageBody);</pre>  <h3>キューからのメッセージの受信</h3>  <p>メッセージは、ピーク ロックまたは <b>受信</b> と削除 <b>のセマンティクスを使用して</b> 受信できます。どちらも REST 経由でサポートされますが、今のところは Receive と Delete を使用します。 このモードでの受信は、受信タイムアウトを使用してメッセージ キューのヘッドに HTTP 削除要求を発行するのと同じほど簡単です。</p>  <pre class=\"code\"><span class=\"keyword\">string</span> receiveAddress = serviceAddress + queueName + <span class=\"string\">\"/Messages/Head?timeout=30\"</span>;  <span class=\"keyword\">string</span> receivedMessageBody = webClient.UploadString(receiveAddress, <span class=\"string\">\"DELETE\"</span>, <span class=\"keyword\">string</span>.Empty);</pre>  <p>receivedMessageBody には、前に送信されたプレーンテキスト (ニート! ) が含まれています。また、応答ヘッダーを見て、メッセージのその他のプロパティを見つける方法も確認できます。</p>  <pre class=\"code\"><span class=\"keyword\">X-MS-MESSAGE-ID</span>: <span class=\"string\">d78afc3299b54ab2bd0e97b183ab1f77</span>  <span class=\"keyword\">X-MS-DELIVERY-COUNT</span>: <span class=\"string\">0</span>  <span class=\"keyword\">X-MS-SEQUENCE-NUMBER</span>: <span class=\"string\">2</span>  <span class=\"keyword\">X-MS-SIZE</span>: <span class=\"string\">12</span>  <span class=\"keyword\">Content-Type</span>: <span class=\"string\">text/plain</span></pre>  <h3>キューの削除</h3>  <p>最後に、キューを削除します。これは、キューのアドレスに対する単純な HTTP 削除によって実現されます。</p>  <pre class=\"code\">webClient.UploadString(queueAddress, <span class=\"string\">\"DELETE\"</span>, <span class=\"keyword\">string</span>.Empty);</pre>  <p>そのため、そこには、AppFabric とメッセージングの新しい REST 機能を使用するService Busがあります。 さらに多くのことを行えるので、来週はさらに多くの機能について説明しますが、チームにフィードバックを送信するのも早すぎるという話ではありません。 <a href=\"https://social.msdn.microsoft.com/Forums/en-US/appfabricctp/\">AppFabric CTP フォーラム</a> にアクセスして、ご意見をお聞かせください。</p>  <p>特に、ビルドするアプリケーションで HTTP を使用する方法について、ご意見をお聞かしく思います。</p>  <ul>  <li>アプリケーションの使用を検討しているプラットフォームとデバイスはService Busですか? </li>  <li>アプリケーションを成功Service Bus HTTP を使用してサポートすることが最も重要な機能は、どの機能ですか? </li>  </ul>  <p><b>HTTP 機能調査を利用して、データの将来を形成Service Bus。</b></p>"
