### YamlMime:Yaml
ms.openlocfilehash: 3ad38443a621e386ab01a3bb8699cbac5ee5ab84
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139903894"
Slug: understanding-serverless-cold-start
Title: 'サーバーレス コールド スタートの概要 '
Summary: "\"コールド スタート\" は、サーバーレス アーキテクチャの大きなディスカッション ポイントであり、サーバーレス アーキテクチャの多くのユーザーのあいまいAzure Functions。 この投稿の目的は、コールド スタートとは何か、それが起こる理由、およびそれを中心にソリューションを設計する方法を理解するのに役立ちます。 "
Content: >-
  <p><strong>2019 年 6 月の更新: </strong>動的スケーリング関数のコールド スタートの軽減策が、新しいプランプレミアムしました。 詳細については、<a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-premium-plan#pre-warmed-instances">こちら</a>を参照してください。</p>


  <p>コールド スタートは、サーバーレス アーキテクチャの大きなディスカッション ポイントであり、サーバーレス アーキテクチャの多くのユーザーのあいまいAzure Functions。 この投稿の目的は、コールド スタートとは何か、それが起こる理由、およびそれを中心にソリューションを設計する方法を理解するのに役立ちます。 この説明を提供するために、&rsquo;アプリケーションが背後でどのように動作Azure Functions詳しく説明します。</p>


  <h2>消費プランと専用プラン</h2>


  <p>Azure Functionsには、消費量と専用の 2 つの主なフレーバーがあります。 2 つの違いは&rsquo;重要です。一方を選択すると、アプリケーションの動作だけでなく、請求方法も決まるのです。 &ldquo;&rsquo;&rdquo;&rsquo;&rsquo;使用プランはサーバーレス モデルであり、コードはイベントに反応し、表示された負荷に合わせて効果的にスケールアウトし、コードが実行されていないときにスケールダウンされ、使用した分に対してだけ請求されます。 さらに、このすべては、ユーザーが何を行Microsoft Azureなのかを考えずに行います。 一方、専用プランでは、仮想マシンのレンタル制御が必要です。 このコントロールは、そのマシンで好きなことを行えることを意味します。 これは&rsquo;常に使用可能であり、24 時間 365 日実行する必要がある関数がある場合は、より経済的に意味があります。 興味を&rsquo;持ち、より詳細な説明が必要な場合は、ドキュメントを参照 <a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-scale">してください</a>。</p>


  <h2>コールド スタートとは</h2>


  <p>大まかに言えば、コールド&rsquo; スタートは、使用されていないアプリケーションの起動に時間がかかるという現象を説明するために使用される用語です。 時間のコンテキストAzure Functions待機時間は、ユーザーが関数を待機する必要がある合計時間です。 イベントが発生して関数を起動した場合から、その関数がイベントへの応答を完了するまで。 より正確には、コールド スタートは、最近呼び出されていない Functions&rsquo; の待機時間の増加です。 専用プランAzure Functionsを使用する場合、Functions&rsquo; ホストは常に実行されています。つまり、コールド スタートは実際には問題ではありません。 そのため、スコープはサーバーレス消費モデルを実行する Functions に絞り込まれています。 もっと&rsquo;深く進もう。</p>


  <h2>関数を記述するとどうなるか</h2>


  <p>最初の&rsquo;関数を記述したとします。 関数&rsquo;アプリをプロビジョニングし、テンプレートの 1 つに基づいて関数を作成し、ビジネス ニーズに合わせて変更しています。 を保存し、指定したトリガーが関数を開始するまで待ちます。 後で関数がトリガーされます。 このプロセスが開始されると、&rsquo;まだ何も実行していないので、すべてのコードと構成は、Azure Storage 内のファイルとしてのみ存在します。 コード&rsquo;を実行するために引き続き何が行う必要があるのかを一時停止して考えます。</p>


  <ol>
   <li>
   <p>Azure では、容量のあるサーバーにアプリケーションを割り当てる必要があります。</p>
   </li>
  </ol>


  <ol start="2">
   <li>
   <p>その後、Functions ランタイムはそのサーバーで起動する必要があります。</p>
   </li>
  </ol>


  <ol start="3">
   <li>
   <p>その後、コードを実行する必要があります。</p>
   </li>
  </ol>


  <p>手順 1 と 2 では、意図しない場合、しばらく時間がかかる場合があります。サーバーのスピンアップと構成には時間が必要です。 このエクスペリエンスを&rsquo;ユーザーに提供するために、毎回ゼロから開始するのではなく、サーバーのプールをウォーム状態に保ち、そのプールからワーカーを引き出す方法を実装しました。 つまり、任意の時点で、Functions ランタイムが稼働して事前に構成されているアイドル状態のワーカーがいます。 これらの事前ウォー &ldquo;ドされたサイトを作成&rdquo; すると、コールド スタート時間を測定可能に改善しました。 これで、3 倍から 4 倍の速さになります。 次に、&rsquo;&rsquo;リソースがまだ割り当てられていないときに関数の実行をトリガーするとどうなるかを詳しく見てみましょう。</p>


  <h2>コールド スタート中に何が起こるか</h2>


  <p style="text-align: center;"><img src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/4cca2941-3df2-49aa-bb73-495dc64b2ead.jpeg"></p>


  <ol>
   <li>
   <p>Azure は、ウォーム ワーカーのプールからアプリに事前構成済みサーバーを割り当てる。 このサーバーには既に Functions ランタイムが実行されているが、指定されていない。</p>
   </li>
   <li>このワーカーは、アプリに固有の方法で Functions ランタイムを構成することで特殊化されます。 この特殊化を行うには、次の処理が行います。 <ul>
    <li>このAzure Functionsインフラストラクチャによって、割り当Azure Filesされた worker にコンテンツが&rsquo;マウントされます</li>
    <li>
    <p>関数アプリに固有のアプリ設定がワーカーに適用される</p>
    </li>
   </ul>
   </li>
   <li>Functions ランタイムがリセットされ、必要な拡張機能がワーカーに読み込まれます。 読み込む拡張機能を確認するために、ランタイムは関数アプリ内の任意の関数の function.json ファイルを読み取ります。 たとえば、この問題は、&rsquo;Durable Functionsを使用<a href="https://docs.microsoft.com/en-us/azure/azure-functions/durable-functions-overview"></a>している場合や、入力または出力バインドがある場合に発生します。</li>
   <li>関数自体は、言語プロバイダーによってメモリに読み込まれます。 これには、アプリケーションのサイズに応じ、さまざまな時間が必要になります。</li>
   <li>
   <p>コードが実行されます。</p>
   </li>
  </ol>


  <p>関数を&rsquo;最近実行した場合は、手順 1 から 4 が既に実行され、リソースが既に割り当て済みであり、サイトがウォームです。 ご想像のように、このシナリオでは、処理が大幅に速くなります。 約 20 分の非アクティブ状態の後、リソースの割り当ては解放されます。その後、次の呼び出しはコールド スタートになります。このプロセス全体が再び発生します。これは上の図です。</p>


  <h2>チームはそれ以上改善していますか?</h2>


  <p>できます。 この投稿は、単なる特定の時点 (2018 年 2 月) の分析であり、多くの詳細が変更される可能性があります。 証拠として、最近&rsquo;、ランタイムと一般提供言語の更新プログラムをリリースしました。コールド スタート時間ではさらに 50% 改善されています。 ここでは非常&rsquo;に深く取り上げないのですが、この更新により、ネイティブ イメージ生成の回帰が修正されました。 詳細については、<a href="https://docs.microsoft.com/en-us/dotnet/framework/tools/ngen-exe-native-image-generator" target="_blank">NGEN</a> を参照するか、リリース自体を確認<a href="https://github.com/Azure/azure-webjobs-sdk-script/releases/tag/v1.0.11490" target="_blank"></a>してください。完全にオープン ソースです。</p>


  <h2>長時間のコールド スタートを回避するためにコードを改善する方法</h2>


  <p>コールド スタートを&rsquo;引き起こす背後で何が起こっているかをベースラインで理解したので、それを回避するためにソリューションを設計する方法に取り組み始めることができます。</p>


  <p>言語: まず、C#、F#、JavaScript などの一般提供言語を使用します。 試験的な言語&rsquo;がいくつか用意されています。これらの言語のほとんどが完全にサポートされ、最適化されています。実際には、すべての実行で新しいプロセスが開始され、待機時間が大きな影響を受ける可能性があります。 また、&rsquo;2.0&rsquo; ランタイムで実行されている言語はプレビュー中であり、完全に最適化されていない点にも注意してください。 今後、これらの言語のパフォーマンスは向上すると予想されますが、今のところ、前述の GA 言語に従います。 詳細については、ドキュメントを参照 <a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-versions" target="_blank">してください</a>。</p>


  <h2>軽量コードを記述する</h2>


  <p>依存関係: コードをデプロイすると、依存関係がファイルとしてアプリケーションに追加されます。 上記の手順 4 で説明したように、アプリに必要なすべてのコードが最終的にメモリに読み込まれ、より大きなアプリケーションでは時間がかかります。 &rsquo;そのため、依存関係が多い場合は、Azure Files からの I/O 操作の時間が長く、より大きなアプリをメモリに読み込むのに必要な時間が長くなるので、コールド スタートが長くなります。 これは、JavaScript で Functions を記述する人々にとって、npm ツリーが大きな問題を生み出す可能性があるという事実です。 これにより、アプリのサイズが増えるだけでなく、処理する必要があるファイルAzure Filesが増えるだけでなく、さらに速度が低下します。 特にこのシナリオでは、役立&rsquo;つツールをリリースしました。 詳細については <a href="https://github.com/Azure/azure-functions-pack/releases/tag/1.0.0" target="_blank">、「Funcpack</a> 」を参照してください。</p>


  <p>効率的なコード: 場合によっては、より効率的なコードを記述する場合があります。 ここで注意する方法はいくつかあり、最初に可能な限り多くの処理を非同期にしてみてください。 コードの完了&rsquo;をブロックする負荷の高い同期呼び出しがある場合、関数はうまく機能しない。 この問題に沿って、コードが起動する前に発生する必要がある作業量を最小限に抑え、CPU を大量に消費するコードを回避してください。 この問題&rsquo;を自分で心配する場合は、Application インサイト を<a href="https://azure.microsoft.com/en-us/services/application-insights/" target="_blank">試インサイト</a>。 これは&rsquo;素晴らしい監視ツールであり、アプリケーションの速度低下をプラットフォームの速度低下から切り離すのに役立ちます。</p>


  <h2>コールド スタートを完全に回避する</h2>


  <p>専用モード: 前に説明したように、App Service プランで Functions を実行すると、VM で何が起こるかを制御することで、これらの問題が軽減されます。 これは少し&rsquo;コストが高く、サーバーレスではありません。ただし、個々の呼び出しごとに待機時間を短くする要件がソリューションにある場合は、専用モードの使用を検討してください。</p>


  <h2>フィードバック</h2>


  <p>フィードバックは常に歓迎されます。 その他の理由で製品チームに直接ご自分の考えやご連絡をしたい場合は、Twitter またはお問い合わせGitHub。</p>
