### YamlMime:Yaml
ms.openlocfilehash: 0f20b6fc329fe43187647c48bbface2d2f7f9c6e
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139905195"
Slug: offline-support-in-azure-mobile-services-android-sdk
Title: Azure Mobile Services Android SDK でのオフラインサポート
Summary: Azure Mobile Services SDK for Android の最新バージョンでは、フューチャ (非同期操作の場合) とオフライン (非接続アプリケーション) の両方のサポートが追加されました。 この記事では、オフライン機能について説明します。ポータル (To do list) からダウンロードしたサンプルアプリケーションをオフラインで使用できるようにするために必要な手順について説明します。 アプリに必要な機能について説明します。
Content: >-
  前回の<a href="https://azure.microsoft.com/blog/2014/08/04/futures-support-and-breaking-changes-in-azure-mobile-services-android-sdk/">投稿</a>では、Azure Mobile Services 用の Android SDK の新しい (アルファ) バージョンについて説明しました。これにより、フューチャのサポートが導入されました。 この投稿では、Android SDK が管理対象と iOS との機能の同等性を持つようになったため、オフラインサポートも追加されました。 この記事では、Todo アプリをオフラインで有効にするために必要な手順について説明し、アプリで必要とされる各機能について説明します。


  <b>TL; DR</b>: この投稿は、<a href="https://aka.ms/Iajk6q">新しいバージョンの Azure Mobile Services Android SDK</a>でリリースされた機能を使用して、Azure portal からダウンロードしたクイックスタートアプリケーションをオフラインで有効にする方法を示しています。 サンプルリポジトリ </a> で " href="https://github.com/Azure/mobile-services-samples/tree/master/TodoOffline/Android/blog20140807"> <a title=" https://github.com/Azure/mobile-services-samples/tree/master/TodoOffline/Android/blog20140807 この記事の例の完全なコードを確認し、<a href="https://github.com/Azure/azure-mobile-services/tree/android">メインリポジトリの Android ブランチ</a>の SDK ソースを参照することもできます。

  <h2>初期セットアップ</h2>

  まず、ポータルでダウンロードできるクイックスタートアプリケーションを使用してみましょう。 新しいモバイルサービスを作成します。 この例では、Visual Studio を使用しなくても設定できる node.js バックエンドを使用してみましょう。


  <a href="https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/08/001-CreateMobileService.png"><img style="padding-top: 0px; padding-left: 0px; padding-right: 0px; border: 0px;" title="001-CreateMobileService" alt="001-CreateMobileService" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/001-CreateMobileService_thumb.png" width="484" height="375" border="0" /></a>


  サービスが作成されたら、Android プラットフォームを選択し、[TodoItem テーブルの作成] を選択して、スタートプロジェクトをコンピューターにダウンロードします。


  <a href="https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/08/002-DownloadTodoApp.png"><img style="padding-top: 0px; padding-left: 0px; padding-right: 0px; border: 0px;" title="002-DownloadTodoApp" alt="002-DownloadTodoApp" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/002-DownloadTodoApp_thumb.png" width="440" height="484" border="0" /></a>


  Eclipse でプロジェクトを開き、作業を開始する準備ができました。

  <h2>クイックスタートアプリを更新しています</h2>

  ここでプレビューしているオフラインサポートには、いくつかの優れた機能があります。 そのうちの1つは、Azure のテーブルにローカルの変更をプッシュするときに発生する可能性がある競合を解決する機能です。 たとえば、2つの電話で同じアプリを実行していて、両方の電話で <em>同じ</em> 項目をローカルに変更した場合、変更をサーバーにプッシュする準備ができたら、そのうちの1つは、競合が発生して失敗します。 SDK を使用すると、コードを使用してこれらの競合を処理し、競合している項目をどのように処理するかを決定できます。


  ただし、現在のクイックスタートでは、競合が発生する可能性があります。これは、項目に対して実行できる唯一の操作が完了としてマークされるためです。 True の場合、1つのクライアントで項目を完了としてマークした後、別のクライアントで同じ操作を行うことができますが、技術的には競合していますが、これはそれほど興味がないということです。 次に、[クイックスタート] を変更して、todo 項目を完全に編集できるようにすることで、さらに興味深いものにしましょう。


  ダウンロードできるコードでは、項目の編集を許可するようにアプリが更新されていることがわかります。 これと同じ手順を実行する場合は、 <a href="#Appendix">この投稿の最後にある付録</a>を参照してください。

  <h2>SDK を更新しています</h2>

  アプリケーションでオフラインサポートを追加するには、まず、それをサポートする Mobile Services Android SDK のバージョンを取得する必要があります。 プレビュー機能として起動しているため、公式のダウンロード場所には含まれません。 ここでは、に <a title=" https://aka.ms/Iajk6q https://aka.ms/Iajk6q " href="https://aka.ms/Iajk6q"> </a> アクセスしてローカルでダウンロードできます。 ダウンロードが完了したら、mobileservices-2.0.0 と guava-17.0 ファイルを抽出して、プロジェクトの lib フォルダーにコピーします。以前のバージョンの SDK (このブログの執筆時点では mobileservices-1.1.5) を削除し、Eclipse の lib フォルダーの内容を更新します。


  これで、プロジェクトに多くのエラーが発生します。これは、 <a href="https://azure.microsoft.com/blog/2014/08/04/futures-support-and-breaking-changes-in-azure-mobile-services-android-sdk/">以前の投稿</a>に記載されている重大な変更が原因です。 多くの場合、これらは Todoactivity.java にありますが、ほとんどは異なるパッケージに移動されるクラスに関連しています。 Eclipse でファイルを選択したら、[ソース] メニューの [インポートの整理] を選択し (Ctrl + Shift + O)、そのほとんどが修正されます。 残りの部分を修正するには、クラス宣言の前に次のインポートを追加します。

  <pre class="prettyprint">import static com.microsoft.windowsazure.mobileservices.table.query.QueryOperations.*;</pre>

  また、フューチャを使用して、インターフェイスの新しいコントラクトに準拠する進行状況を示すために使用されるサービスフィルターを更新します。

  <pre class="prettyprint">private class ProgressFilter implements ServiceFilter {

      @Override
      public ListenableFuture&lt;ServiceFilterResponse&gt; handleRequest(
              ServiceFilterRequest request, NextServiceFilterCallback next) {

          runOnUiThread(new Runnable() {

              @Override
              public void run() {
                  if (mProgressBar != null) mProgressBar.setVisibility(ProgressBar.VISIBLE);
              }
          });

          ListenableFuture&lt;ServiceFilterResponse&gt; result = next.onNext(request);

          Futures.addCallback(result, new FutureCallback&lt;ServiceFilterResponse&gt;() {
              @Override
              public void onFailure(Throwable exc) {
                  dismissProgressBar();
              }

              @Override
              public void onSuccess(ServiceFilterResponse resp) {
                  dismissProgressBar();
              }

              private void dismissProgressBar() {
                  runOnUiThread(new Runnable() {

                      @Override
                      public void run() {
                          if (mProgressBar != null) mProgressBar.setVisibility(ProgressBar.GONE);
                      }
                  });
              }
          });

          return result;
      }
  }</pre>

  これで、アプリは最新の SDK を使用するようになり、以前と同じように動作し続けます。

  <h2>新しい (フューチャベースの) API を使用するようにモバイルサービス呼び出しを更新する</h2>

  また、このリリースで導入された新しいフューチャベースの Api を使用するようにテーブル操作を変更する方法もあります。オフラインで使用するクラスにコールバックベースのメソッドがないため、完全に接続されている場合は、常時接続のアプリケーションに移行しやすくなります。 この操作を行う必要があるのは、バックグラウンドスレッドへの操作を伴う可能性のあるアクションを開始することです。操作の結果が得られると、UI コンポーネントを変更する必要がある場合は、呼び出しをメイン (UI) スレッドにポストバックする必要があります。 たとえば、メソッドは <code>addItem</code> 次のように書き換えることができます。

  <pre class="prettyprint">public void addItem(View view) {
      if (mClient == null) {
          return;
      }

      // Create a new item
      final ToDoItem item = new ToDoItem();

      item.setText(mTextNewToDo.getText().toString());
      item.setComplete(false);

      // Insert the new item
      new AsyncTask&lt;Void, Void, Void&gt;() {

          @Override
          protected Void doInBackground(Void... params) {
              try {
                  mToDoTable.insert(item).get();
                  if (!item.isComplete()) {
                      runOnUiThread(new Runnable() {
                          public void run() {
                              mAdapter.add(item);
                          }
                      });
                  }
              } catch (Exception exception) {
                  createAndShowDialog(exception, "Error");
              }
              return null;
          }
      }.execute();

      mTextNewToDo.setText("");
  }</pre>

  Update メソッドは次のようになります。

  <pre class="prettyprint">private void updateItem(final ToDoItem item) {
      if (mClient == null) {
          return;
      }

      new AsyncTask&lt;Void, Void, Void&gt;() {

          @Override
          protected Void doInBackground(Void... params) {
              try {
                  mToDoTable.update(item).get();
                  runOnUiThread(new Runnable() {
                      public void run() {
                          if (item.isComplete()) {
                              mAdapter.remove(item);
                          }
                          refreshItemsFromTable();
                      }
                  });
              } catch (Exception exception) {
                  createAndShowDialog(exception, "Error");
              }
              return null;
          }
      }.execute();
  }</pre>

  最後に、テーブルから項目を取得する場合は、同じ操作を行う必要があります。

  <pre class="prettyprint">private void refreshItemsFromTable() {

      // Get the items that weren't marked as completed and add them in the
      // adapter
      new AsyncTask&lt;Void, Void, Void&gt;() {

          @Override
          protected Void doInBackground(Void... params) {
              try {
                  final MobileServiceList&lt;ToDoItem&gt; result = mToDoTable.where().field("complete").eq(false).execute().get();
                  runOnUiThread(new Runnable() {

                      @Override
                      public void run() {
                          mAdapter.clear();

                          for (ToDoItem item : result) {
                              mAdapter.add(item);
                          }
                      }
                  });
              } catch (Exception exception) {
                  createAndShowDialog(exception, "Error");
              }
              return null;
          }
      }.execute();
  }</pre>

  この時点で、アプリケーションを再度実行できるようになり、以前と同じように動作し続けるはずです。

  <h2>テーブルから同期テーブル</h2>

  これで、アプリをオフラインに対応できるようになりました。 まず、テーブルへのアクセスに使用するクラスを変更する必要があります。または <code>MobileServiceJsonTable</code> を使用する代わり <code>MobileServiceTable&lt;E&gt;</code> に、新しい <code>MobileServiceSyncTable&lt;E&gt;</code> クラスまた <code>MobileServiceJsonSyncTable</code> はクラスを使用します。 他のプラットフォームと同様に、同期テーブルは基本的に、対応する "リモート" テーブルにローカルに変更をプッシュする方法と、リモートテーブルから項目をローカルに "プル" する方法を "認識" するローカルテーブルです。 変更の追跡は同期コンテキストによって行われます。同期コンテキストは、項目をローカルに格納するために使用されるローカルストアで初期化する必要があります。 Mobile Services SDK は、SQLite データベースに基づくストアの実装を提供し、この投稿に使用します。


  まず、ローカルストアの初期化を処理しましょう。 <code>onCreate</code>メソッドで、インスタンスを作成 <code>MobileServiceClient</code> した後に、次の行を追加します。

  <pre class="prettyprint">SQLiteLocalStore localStore = new SQLiteLocalStore(mClient.getContext(), "ToDoItem", null, 1);

  SimpleSyncHandler handler = new SimpleSyncHandler();

  MobileServiceSyncContext syncContext = mClient.getSyncContext();


  Map&lt;String, ColumnDataType&gt; tableDefinition = new HashMap&lt;String, ColumnDataType&gt;();

  tableDefinition.put("id", ColumnDataType.String);

  tableDefinition.put("text", ColumnDataType.String);

  tableDefinition.put("complete", ColumnDataType.Boolean);


  localStore.defineTable("ToDoItem", tableDefinition);

  syncContext.initialize(localStore, handler).get();</pre>

  最後の数行では、ローカルテーブルにアクセスする (ストア内で定義する) とき、またはコンテキストを初期化するときに例外がスローされる場合があります。そのため、例外ハンドラーも更新して、これらの処理に対処する必要があります。

  <pre class="prettyprint">} catch (MalformedURLException e) {
      createAndShowDialog(new Exception("There was an error creating the Mobile Service. Verify the URL"), "Error");
  } catch (Exception e) {
      Throwable t = e;
      while (t.getCause() != null) {
          t = t.getCause();
      }
      createAndShowDialog(new Exception("Unknown error: " + t.getMessage()), "Error");
  }</pre>

  コンテキストが初期化されたので、メインアクティビティのフィールドの <code>mToDoTable</code> 型をまたは <code>MobileServiceSyncTable&lt;ToDoItem&gt;</code> から <code>MobileServiceTable&lt;ToDoItem&gt;</code> 変更します。 <code>onCreate</code>メソッドで、メソッドを使用 <code>getSyncTable</code> するように、そのフィールドの初期化を変更します。 他にも、変更が必要なものがあります。 ローカルテーブルから読み取る場合は、クエリを渡す必要があります。また、"regular" テーブルからクエリオブジェクトを取得できます。 そのため、新しいプライベートフィールドを定義します。

  <pre class="prettyprint">/**
   * The query used to pull data from the remote server
   */
  private Query mPullQuery;</pre>

  メソッドで <code>onCreate</code> 初期化します。

  <pre class="prettyprint">// Saves the query which will be used for reading data

  mPullQuery = mClient.getTable(ToDoItem.class).where().field("complete").eq(false);</pre>

  次のように、refreshItemsFromTable メソッドのコードを更新して、そのクエリを使用します。

  <pre class="prettyprint">final MobileServiceList&lt;ToDoItem&gt; result = mToDoTable.read(mPullQuery).get();</pre>

  これでアプリを実行できるようになり、完全にオフラインで実行できるようになります。

  <h2>プルとプッシュ</h2>

  以前にアプリを実行したことがある場合は、気付かないかもしれません。以前にアプリの前に表示されていた項目は、一覧に表示されなくなります。 この問題は、現在、ローカル (同期) テーブルと対話していますが、サーバー側との同期は実行されていないため、このコードを初めて実行するときは、空の (ローカル) テーブルに対して実行されます。 必要なのは、サーバーから既存のデータをプルするように同期テーブルに指示し、サーバー側にローカルに加えられたすべての変更をプッシュすることです。


  クイックスタートアプリには、そのロジック (アプリの右上隅にある [更新] メニュー項目) を実装できる適切な場所が用意されています。 データを同期する必要があるかどうかに関して、他のアプリの要件は異なる場合がありますが、デモを行うためには、ユーザーに明示的に要求してください。 <code>onOptionsItemSelected</code>メソッドで、新しいバックグラウンドタスクを開始し、その場所でローカルストアに対して行われたすべての変更を (同期コンテキストを使用して) 最初にプッシュした後、(同期テーブルを使用して) ローカルテーブルに送信するすべてのデータを後でプルします。

  <pre class="prettyprint">public boolean onOptionsItemSelected(MenuItem item) {
      if (item.getItemId() == R.id.menu_refresh) {
          new AsyncTask&lt;Void, Void, Void&gt;() {

              @Override
              protected Void doInBackground(Void... params) {
                  try {
                      mClient.getSyncContext().push().get();
                      mToDoTable.pull(mPullQuery).get();
                      refreshItemsFromTable();
                  } catch (Exception exception) {
                      createAndShowDialog(exception, "Error");
                  }
                  return null;
              }

          }.execute();
      }

      return true;
  }</pre>

  アプリを実行して [更新] ボタンをタップすると、サーバーのすべての項目が表示されます。 その時点で、デバイスからネットワークを無効にし、変更を続けることができます。アプリは正常に動作します。 サーバーに変更を同期する時間が経過したら、ネットワークを再びオンにし、[更新] ボタンをもう一度タップします。


  指摘すべき重要な点が1つあります。ローカルストアに保留中の変更がある場合は、プル操作によってそれらの変更がサーバーにプッシュされます (同じ行に変更がある場合、プッシュ操作は失敗し、アプリケーションは競合を適切に処理できるようになります)。 つまり、上記のコードのプッシュ呼び出しは必ずしも必要ではありませんが、コードが実行されていることを明確にすることをお勧めします。

  <h2>競合の処理</h2>

  データのオフライン処理は非常に優れていますが、プッシュ操作の実行中に競合が発生した場合はどうなるでしょうか。 この時点までは、アプリケーションはバージョン列を格納していないため <code>ToDoItem</code> 、サーバーデータの以前の変更をすべて無視し、サーバーデータを上書きします (基本的には "クライアント優先" の競合解決ポリシー)。 しかし、これよりもスマートにすることができます。 まず、 <a href="https://blogs.msdn.com/b/carlosfigueira/archive/2013/11/23/new-tables-in-azure-mobile-services-string-id-system-properties-and-optimistic-concurrency.aspx">オプティミスティック同時実行制御</a> が適用されるようにバージョンを追加し、更新が項目のバージョンに対して条件になるようにしましょう。 <code>ToDoItem</code>クラスで、次のメンバーを追加します。

  <pre class="prettyprint">/**
   * The version of the item in the database
   */
  @com.google.gson.annotations.SerializedName("__version")

  private String mVersion;


  /**
   * Gets the version of the item in the database
   *
   * @return the version of the item in the database
   */
  public String getVersion() {
      return mVersion;
  }


  /**
   * Sets the version of the item in the database
   *
   * @param mVersion the version of the item in the database
   */
  public void setVersion(String mVersion) {
      this.mVersion = mVersion;
  }</pre>

  ローカルテーブル <code>onCreate</code> を定義するときに新しい列を追加する方法

  <pre class="prettyprint">tableDefinition.put("__version", ColumnDataType.String);</pre>

  ここで、Fiddler や Postmon などのツールを使用して項目を編集し、アプリケーションで同じ項目を編集する (または、2つの異なるデバイス/エミュレーターで同じ項目を編集する) 場合、プッシュしようとするとエラーが発生します。 ただし、次に示すように、カスタム同期ハンドラーを実装することで、そのエラーを処理し、独自の競合解決ポリシーを実装することができます。

  <pre class="prettyprint">private class ConflictResolvingSyncHandler implements MobileServiceSyncHandler {

      @Override
      public JsonObject executeTableOperation(
              RemoteTableOperationProcessor processor, TableOperation operation)
              throws MobileServiceSyncHandlerException {

          MobileServicePreconditionFailedExceptionBase ex = null;
          JsonObject result = null;
          try {
              result = operation.accept(processor);
          } catch (MobileServicePreconditionFailedExceptionBase e) {
              ex = e;
          } catch (Throwable e) {
              ex = (MobileServicePreconditionFailedExceptionBase) e.getCause();
          }

          if (ex != null) {
              // A conflict was detected; let's force the server to "win"
              // by discarding the client version of the item
              // Other policies could be used, such as prompt the user for
              // which version to maintain.
              JsonObject serverItem = ex.getValue();

              if (serverItem == null) {
                  // Item not returned in the exception, retrieving it from the server
                  try {
                      serverItem = mClient.getTable(operation.getTableName()).lookUp(operation.getItemId()).get();
                  } catch (Exception e) {
                      throw new MobileServiceSyncHandlerException(e);
                  }
              }

              result = serverItem;
          }

          return result;
      }

      @Override
      public void onPushComplete(MobileServicePushCompletionResult result)
              throws MobileServiceSyncHandlerException {
      }
  }</pre>

  これで、アプリを実行したときに競合が発生すると、自動的に処理されます。

  <h2>まとめ</h2>

  現在、ネイティブ iOS アプリケーションのオフラインサポートを追加しています。マネージ SDK と同様に、プレビュー形式でリリースしています。 お客様のフィードバックをお待ちしており、Azure Mobile Services 用の Sdk の改善を続けることができます。 通常どおり、この投稿には、 <a href="https://social.msdn.microsoft.com/Forums/windowsazure/en-US/home?forum=azuremobile">MSDN フォーラム</a> または twitter <a href="https://twitter.com/azuremobile">@AzureMobile</a> を通じてコメント/提案/質問を残してください。


  この投稿で使用されているコードをダウンロードする場合は、<a href="https://github.com/Azure/mobile-services-samples/tree/master/TodoOffline/Android/blog20140807">サンプルリポジトリ</a>の下にある GitHub の mobile services サンプルリポジトリで入手できます。 また、Azure Mobile Service SDK for Android バージョン 2.0 alpha <a title=" https://aka.ms/Iajk6q https://aka.ms/Iajk6q " href="https://aka.ms/Iajk6q"> </a> を入手できます。 これらの勇気くらくらのいずれかである場合は、 <a href="https://github.com/Azure/azure-mobile-services/tree/android">azure-mobile services リポジトリの Android ブランチ</a>で完全なクライアント SDK を使用できます。

  <h2><a name="Appendix"></a>付録: ToDoItem プロジェクトを更新して投稿用に準備する</h2>

  ポータルからダウンロードした既存の ToDo リストアプリを変更して、項目を編集可能にするために必要な手順を次に示します。

  <h3>新しいアクティビティの追加</h3>

  新しい画面で項目の編集を処理します。そのため、新しいアクティビティをプロジェクトに追加してみましょう。 Eclipse でプロジェクトアイコンを右クリックし、[新規] &gt; 、[その他] の順に選択して、android ノードを追加し、[Android アクティビティ] – &gt; [空のアクティビティ] を選択します。


  <a href="https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/08/A001-CreateNewActivity.png"><img style="padding-top: 0px; padding-left: 0px; padding-right: 0px; border: 0px;" title="A001-CreateNewActivity" alt="A001-CreateNewActivity" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/A001-CreateNewActivity_thumb.png" width="480" height="367" border="0" /></a>


  新しいアクティビティに EditToDoActivity という名前を入力し、[完了] をクリックします。


  <a href="https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/08/A002-NameNewActivity.png"><img style="padding-top: 0px; padding-left: 0px; padding-right: 0px; border: 0px;" title="A002-NameNewActivity" alt="A002-NameNewActivity" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/A002-NameNewActivity_thumb.png" width="480" height="412" border="0" /></a>


  これで、アクティビティを構成する準備ができました。 次に、文字列ファイル (res/values/strings.xml) を開き、これらの変更を加えて、ローカリゼーションの警告を防止します。

  <ul>
   <li>"Hello_world" 文字列値を削除します。</li>
   <li>"Title_activity_edit_to_do" の値を "EditToDoActivity" から "Edit ToDo item" に変更します。</li>
   <li>次の新しい文字列を追加します。
  <ul>
   <li>&lt;string name = "label_item_text" &gt; item &lt; /string&gt;</li>
   <li>&lt;string name = "label_complete" &gt; complete &lt; /string&gt;</li>
   <li>&lt;string name = "button_item_edit_done" &gt; done &lt; /string&gt;</li>
  </ul>

  </li>

  </ul>

  ここで、新しいアクティビティのレイアウトを開きます。既定で用意されているテキストビューを削除してから、編集する項目のテキストを含む編集テキスト (@ + id/textBoxEditItem、 hint:@string/title_activity_edit_to_do ) を追加します。項目の完全な状態を含むチェックボックス (@ + id/checkBoxItemComplete; text:@string/label_complete ) と、編集の終了を示すボタン (@ + id/ボタンの編集; text:@string/button_item_edit_done ) を追加します。 次の図は、そのレイアウトを実装した方法を示しています。 また、オプションのテキストビューを項目テキスト ( text:@string/label_item_text ) のラベルと共に追加して、よりわかりやすいようにしました。


  <a href="https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/08/A003-NewActivityLayout.png"><img style="padding-top: 0px; padding-left: 0px; padding-right: 0px; border: 0px;" title="A003-NewActivityLayout" alt="A003-NewActivityLayout" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/A003-NewActivityLayout_thumb.png" width="219" height="360" border="0" /></a>


  次に、既存のチェックボックスをオフにして、テーブルの行テンプレート (res/layout/row_list_to_do.xml) を変更し、代わりにテキストビュー (@ + id/todoItemText) に置き換えます。 メインアクティビティでは項目のみが表示され、クリックされると、新しいアクティビティに移行して編集できるようになります。


  今すぐコードを実行します。 EditToDoActivity ファイル (src/your-project-name の下) を開き、その内容を次のコードに置き換えます。

  <pre class="prettyprint">public class EditToDoActivity extends Activity {

      protected static final String ITEM_TEXT_KEY = "com.example.blog20140807.item_text";
      protected static final String ITEM_COMPLETE_KEY = "com.example.blog20140807.item_complete";

      @Override
      protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          setContentView(R.layout.activity_edit_to_do);

          Bundle extras = getIntent().getExtras();
          String itemText = extras.getString(ITEM_TEXT_KEY);
          boolean itemComplete = extras.getBoolean(ITEM_COMPLETE_KEY);

          final EditText itemTextBox = (EditText)findViewById(R.id.textBoxEditItem);
          itemTextBox.setText(itemText);
          final CheckBox completeCheckbox = (CheckBox)findViewById(R.id.checkBoxItemComplete);
          completeCheckbox.setChecked(itemComplete);

          Button btnDone = (Button)findViewById(R.id.buttonDoneEditing);
          btnDone.setOnClickListener(new View.OnClickListener() {

              @Override
              public void onClick(View v) {
                  Intent i = new Intent();
                  i.putExtra(ITEM_TEXT_KEY, itemTextBox.getText().toString());
                  i.putExtra(ITEM_COMPLETE_KEY, completeCheckbox.isChecked());
                  setResult(RESULT_OK, i);
                  finish();
              }
          });
      }
  }</pre>

  <h3></h3>

  <h3>新しいアクティビティを使用するようにコードを更新する</h3>

  ここで、アダプターコード (src/your-project-name/ToDoItemAdapter) を開き、getView 実装を以下のいずれかに置き換えます。

  <pre class="prettyprint">@Override

  public View getView(int position, View convertView, ViewGroup parent) {
      View row = convertView;

      final ToDoItem currentItem = getItem(position);

      if (row == null) {
          LayoutInflater inflater = ((Activity) mContext).getLayoutInflater();
          row = inflater.inflate(mLayoutResourceId, parent, false);
      }

      row.setTag(currentItem);
      final TextView textView = (TextView) row.findViewById(R.id.todoItemText);
      textView.setText(currentItem.getText());

      return row;
  }</pre>

  メインアクティビティ (src/your-project-name/Todoactivity.java) について説明してみましょう。 まず、パブリック <code>checkItem</code> メソッドを削除し、次に示す新しい <code>updateItem</code> メソッドに置き換えます (項目を完了としてマークするだけではなく、変更を加えることができるため)。

  <pre class="prettyprint">private void updateItem(ToDoItem item) {
      if (mClient == null) {
          return;
      }

      mToDoTable.update(item, new TableOperationCallback&lt;ToDoItem&gt;() {

          public void onCompleted(ToDoItem entity, Exception exception, ServiceFilterResponse response) {
              if (exception == null) {
                  if (entity.isComplete()) {
                      mAdapter.remove(entity);
                  }

                  refreshItemsFromTable();
              } else {
                  createAndShowDialog(exception, "Error");
              }
          }

      });
  }</pre>

  ここで、クラスに次のフィールドを追加して、編集されている項目を追跡し、1つを編集アクティビティにタグ付けします。

  <pre class="prettyprint">/**
   * The position of the item which is being edited
   */
  private int mEditedItemPosition = -1;


  private static final int EDIT_ACTIVITY_REQUEST_CODE = 1234;</pre>

  アクティビティのジャンプコードから始めることができます。 Edit アクティビティに移動するには、メソッドのコード <code>onCreate</code> を変更して、項目を表示するリストにを追加 <code>OnItemClickListener</code> します。 ハンドラーで、新しい <code>Intent</code> を作成し、編集されている項目に関する情報 (他のアクティビティで取得される) を追加して、そのアクティビティを開始します。

  <pre class="prettyprint">// Create an adapter to bind the items with the view

  mAdapter = new ToDoItemAdapter(this, R.layout.row_list_to_do);

  ListView listViewToDo = (ListView) findViewById(R.id.listViewToDo);

  final ListView listViewToDo = (ListView) findViewById(R.id.listViewToDo);

  listViewToDo.setAdapter(mAdapter);


  listViewToDo.setOnItemClickListener(new OnItemClickListener() {

      @Override
      public void onItemClick(AdapterView&lt;?&gt; parent, View view,
              int position, long id) {
          Intent i = new Intent(getApplicationContext(), EditToDoActivity.class);
          mEditedItemPosition = position;
          ToDoItem item = mAdapter.getItem(position);
          i.putExtra(EditToDoActivity.ITEM_COMPLETE_KEY, item.isComplete());
          i.putExtra(EditToDoActivity.ITEM_TEXT_KEY, item.getText());
          startActivityForResult(i, EDIT_ACTIVITY_REQUEST_CODE);
      }
  });


  // Load the items from the Mobile Service

  refreshItemsFromTable();</pre>

  最後に、メソッドをオーバーライド <code>onActivityResult</code> し、実装で、結果が新しいアクティビティからのものであるかどうかを確認し、項目に変更があったかどうかを確認します。その場合は、メソッドを呼び出し <code>updateItem</code> て変更を保持します。

  <pre class="prettyprint">@Override

  protected void onActivityResult(int requestCode, int resultCode, Intent intent) {
      if (requestCode == EDIT_ACTIVITY_REQUEST_CODE &amp;&amp; resultCode == RESULT_OK &amp;&amp; mEditedItemPosition &gt;= 0) {
          ToDoItem item = mAdapter.getItem(mEditedItemPosition);
          String text = intent.getExtras().getString(EditToDoActivity.ITEM_TEXT_KEY);
          boolean complete = intent.getExtras().getBoolean(EditToDoActivity.ITEM_COMPLETE_KEY);

          if (!item.getText().equals(text) || item.isComplete() != complete) {
              item.setText(text);
              item.setComplete(complete);
              updateItem(item);
          }
      }
  }</pre>

  準備が完了しました。 クイックスタートは編集ができるように更新されており、この投稿で説明されているようにオフラインサポートを追加する準備ができました。
