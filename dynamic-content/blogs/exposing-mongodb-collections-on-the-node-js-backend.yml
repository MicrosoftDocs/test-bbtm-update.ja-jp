### YamlMime:Yaml
ms.openlocfilehash: 7671ab70361247a5b27ed25f197ecc53355c8fec
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139909280"
Slug: exposing-mongodb-collections-on-the-node-js-backend
Title: バックエンドで MongoDB コレクションを公開node.jsする
Summary: .NET バックエンドとは異なり、Azure node.js のバックエンドMobile Services MongoDB コレクションはネイティブにサポートされていません。 ただし、テーブル スクリプトを使用して、node.jsモバイル サービスに実装できます。 この投稿では、Mongo データベースからモバイル サービスに CRUD 操作の基本的なサポートを追加する方法について説明します。
Content: >-
  .NET バックエンドをリリースすると、さまざまな種類のストレージ レイヤー (SQL (Entity Framework 経由)、Azure Table Storage、MongoDB のネイティブ サポートが追加されました。 バックエンドnode.jsは常に SQL Azure をサポートしています。また、Azure Table Storage をモバイル サービス クライアントに公開<a href="https://chrisrisner.com/Mobile-Services-and-Windows-Azure-Storage"></a>する方法<a href="https://blogs.msdn.com/b/paolos/archive/2013/04/09/how-to-use-windows-azure-table-storage-in-windows-azure-mobile-services.aspx"></a>について説明したいくつかの投稿を見ていました。 .NET バックエンドから <a href="https://blogs.msdn.com/b/azuremobile/archive/2014/04/14/creating-mongodb-backed-tables-in-azure-mobile-services-with-net-backend.aspx">MongoDB</a> を使用する方法について既に書いているので、この投稿ではループを閉じ始め、mongoDB コレクションを node.js でサポートされる Azure Mobile Service で "テーブル" として公開する方法について説明します。


  この投稿で使用する方法は、ノード バックエンドに "仮想" テーブルを作成し、最初に (<a href="https://manage.windowsazure.com">Azure portal</a> またはコマンド ライン インターフェイスを使用して) テーブルを作成し、その <a href="https://azure.microsoft.com/en-us/documentation/articles/xplat-cli/"></a>CRUD (作成/読み取り/更新/削除) スクリプトを更新して、すべての要求を MongoDB コレクションにリダイレクトします。 この投稿では、挿入/更新/削除操作と、単純な読み取り (単一の項目を参照するか、すべての項目を読み取る) を実装します。 このトピックの次の投稿では、完全な読み取り操作を実装するために必要な手順について説明します。

  <h2>データベースのセットアップ</h2>

  これらは、. <a href="https://blogs.msdn.com/b/azuremobile/archive/2014/04/14/creating-mongodb-backed-tables-in-azure-mobile-services-with-net-backend.aspx">NET</a> バックエンドに関する投稿とまったく同じ手順ですが、この投稿を自己格納可能にするために、ここでコピーしています。 何らかのコレクションが作成された MongoDB アカウントが既にある場合は、この手順をスキップしてください (接続文字列をメモしてください。後で必要になります)。 この投稿では"orders" という名前のコレクションも使用します。作成する必要はありません。存在しない場合はバックエンドによって作成されます。


  最初から始める場合は、この投稿では Mongo Labs データベースを使用しています。これは、Azure portal で無料で取得できます (サンドボックス化された開発者向けエディションの場合)。 アカウントを作成するには、Azure portal に移動し、[新規] –&gt; [ストア] を選択し、MongoLab アドオンを選択します。ここでアカウントにサインアップできます。


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/1902/2630.001_2D00_CreateMongoDB_5F00_63FDC00F.png"><img style="float: none; padding-top: 0px; padding-left: 0px; margin: 0px auto; padding-right: 0px; border-width: 0px;" title="001-CreateMongoDB" alt="001-CreateMongoDB" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/1902/5367.001_2D00_CreateMongoDB_5F00_thumb_5F00_6AB0C992.png" width="610" height="399" border="0"></a>


  アカウントを設定したら、[接続情報] ボタンをクリックして URI をコピーしてデータベースに接続し、その値を保存します。 アカウントに指定した名前は、後で使用するデータベースの名前です。


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/1902/8400.002_2D00_MongoConnectionInfo_5F00_4A95BCD5.png"><img style="float: none; padding-top: 0px; padding-left: 0px; margin: 0px auto; padding-right: 0px; border-width: 0px;" title="002-MongoConnectionInfo" alt="002-MongoConnectionInfo" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/1902/8004.002_2D00_MongoConnectionInfo_5F00_thumb_5F00_3F6C328B.png" width="360" height="175" border="0"></a>


  これで、Mongo データベースが設定されます。コレクションを作成する必要は、最初にバックエンド経由でアクセスしようとするときに作成されます。

  <h2>サービスのセットアップ</h2>

  まだ行っていない場合は、この例で使用する新しいモバイル サービスを作成します。 ポータルで "orders" という名前のテーブルを作成し、そのテーブルのスクリプトを使用して、クライアントからの要求を Mongo データベースに中継します。 最後に、ポータルの [構成] タブに移動して、前のセクションで取得した接続文字列を格納するために使用する新しいアプリ設定 ("MongoConnectionString") を追加します。 複数のユーザーがコード (開発者) にアクセスできる場合がありますが、サービス自体の管理者だけが実稼働ポータルにアクセスできる可能性がある場合は、接続文字列 (および他のシークレット) をアプリケーション設定として保存する代わりに、アプリケーション設定として保存するのをお使いください。


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/1902/2146.003_2D00_ConnectionStringAsAppSetting_5F00_1F5125CE.png"><img style="float: none; padding-top: 0px; padding-left: 0px; margin: 0px auto; padding-right: 0px; border-width: 0px;" title="003-ConnectionStringAsAppSetting" alt="003-ConnectionStringAsAppSetting" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/1902/1641.003_2D00_ConnectionStringAsAppSetting_5F00_thumb_5F00_5148C658.png" width="610" height="96" border="0"></a>

  <h3>MongoDB SDK のインポート</h3>

  Mongo DB (適切に <a href="https://www.npmjs.org/package/mongodb">mongodb</a> と呼ばれる) と話せる node.js パッケージがあります。この記事ではこれを使用します。 カスタム ノード パッケージを使用するには、 の説明に従ってソース管理を有効にする必要があります<a title="https://azure.microsoft.com/en-us/documentation/articles/mobile-services-store-scripts-source-control/https://azure.microsoft.com/en-us/documentation/articles/mobile-services-store-scripts-source-control/" href="https://azure.microsoft.com/en-us/documentation/articles/mobile-services-store-scripts-source-control/"></a>。 サービスでこの機能が既に有効になっている可能性があります (これは、新しく作成されたサービスの既定値です)。 完了したら、サービス リポジトリをローカルに複製します。

  <pre class="prettyprint">C:\temp\blog\MongoDbFromNodeBackend&gt;git clone https://blog20140618.scm.azure-mobile.net/blog20140618.git

  Cloning into 'blog20140618'...

  Username for 'https://blog20140618.scm.azure-mobile.net': carlosfigueira

  Password for 'https://carlosfigueira@blog20140618.scm.azure-mobile.net':

  remote: Counting objects: 92, done.

  remote: Compressing objects: 100% (84/84), done.

  remote: Total 92 (delta 38), reused 0 (delta 0)

  Unpacking objects: 100% (92/92), done.</pre>

  完了したら、リポジトリのサービス フォルダーに移動し、npm を使用してサービスに mongodb モジュールをインストールできます (まだ行っていない場合は、web サイトにアクセスして実行できる node.js をインストールする必要<a href="https://nodejs.org/">があります)。</a> "--save" オプションを使用して packages.json ファイルにモジュールを追加できます。その後、このブログ記事で説明したように、リポジトリ内のパッケージ ファイルを "git-ignore" することができます。<a href="https://blogs.msdn.com/b/azuremobile/archive/2014/01/20/support-for-package-json-in-azure-mobile-services.aspx"></a>

  <pre class="prettyprint">C:\temp\blog\MongoDbFromNodeBackend\blog20140618\service&gt;npm install --save mongodb

  npm WARN package.json blog20140618@1.0.0 No README.md file found!

  npm http GET https://registry.npmjs.org/mongodb

  npm http 200 https://registry.npmjs.org/mongodb

  npm http GET https://registry.npmjs.org/mongodb/-/mongodb-1.4.6.tgz

  npm http 200 https://registry.npmjs.org/mongodb/-/mongodb-1.4.6.tgz

  ...</pre>

  package.json サポートを使用している場合は、次の行を含 <code>.gitignore</code> むファイルを追加します。

  <pre class="prettyprint">node_modules/</pre>

  また、.gitignore ファイルと package.json ファイルを "git add" します。 それではない場合は、リポジトリにnode_modulesを "git add" します。 MongoDB と話すテーブル操作にコードを追加する準備ができました。

  <h2>CRUD 操作</h2>

  mongodb パッケージを使用してコレクションを操作するには、すべての操作で最初に DB への接続を開き、コレクション オブジェクトを作成する必要があります (存在しない場合は、DB にコレクションを作成するか、既存のコレクションへの参照を返します)。その後、操作を実行します。 1 つ 1 つ行ってみしましょう。

  <h3>Inserts</h3>

  挿入操作から始めしましょう。 前に説明したように、接続してコレクションを取得し、実際の挿入を実行します。

  <pre class="prettyprint">function insert(item, user, request) {
      var collectionName = tables.current.getTableName();
      var MongoClient = require('mongodb').MongoClient;
      var connectionString = process.env['MongoConnectionString'];
      MongoClient.connect(connectionString, function(err, db) {
          if (err) {
              console.log('Error connecting to the MongoDB: ', err);
              request.respond(500, { error: err });
          } else {
              db.createCollection(collectionName, function(err, collection) {
                  if (err) {
                      console.log('Error creating collection: ', err);
                      request.respond(500, { error: err });
                  } else {
                      collection.insert(item, { w: 1 }, function(err, result) {
                          if (err) {
                              console.log('Error inserting into the collection: ', err);
                              request.respond(500, { error: err });
                          } else {
                              // item has been inserted!
                              request.respond(201, result);
                          }
                      });
                  }
              });
          }
      });
  }</pre>

  これでテストできます。 Fiddler を使用しますが、他の HTTP クライアントでも問題ありません。

  <pre class="prettyprint">POST https://blog20140618.azure-mobile.net/tables/orders HTTP/1.1

  User-Agent: Fiddler

  Content-Type: application/json

  x-zumo-application: LuKpHqHmHgHBwuqpUzXonKnIdGOZBk59

  Host: blog20140618.azure-mobile.net

  Content-Length: 221


  {
      "client":"John Doe",
      "orderDate":"2014-06-12T00:00:00.000Z",
      "items":[
          { "name" : "bread", "quantity" : 1, "price" : 1.99 },
          { "name" : "milk", "quantity" : 1, "price" : 2.99 }
      ]
  }</pre>

  また、すべてがうまく機能している場合は、次のような応答を受け取る必要があります (わかりやすくするために、一部のヘッダーが削除され、折れ線が追加されます)。

  <pre class="prettyprint">HTTP/1.1 201 Created

  Content-Length: 190

  Content-Type: application/json

  Server: Microsoft-IIS/8.0

  Date: Thu, 12 Jun 2014 23:51:22 GMT


  [
      {
          "client":"John Doe",
          "orderDate":"2014-06-12T00:00:00.000Z",
          "items":[
              {"name":"bread","quantity":1,"price":1.99},
              {"name":"milk","quantity":1,"price":2.99}
          ],
          "_id":"539a3cfaad2df8d85e780e81"
      }
  ]</pre>

  挿入操作は機能しました。MongoDB の管理コンソールを開く場合に確認できるよう、項目が DB に挿入されました。 ただし、応答にはいくつかのプロパティがあり、モバイル サービス クライアントでは問題になります。

  <ul>
   <li>戻り値の型は、オブジェクトではなく配列です</li>
   <li>作成されたオブジェクトの識別子は、クライアント SDK で想定されている "id" ではなく、"_id" として定義されます。</li>
  </ul>

  これらの問題に対処する必要があります。 1 つ目は実際には MongoDB の機能です。複数の項目を一度に "一括挿入" できます。また、コレクション オブジェクトの "insert" メソッドでもそれがサポートされています。<em></em> モバイル サービス クライアント SDK は (少なくともまだ) 一括挿入をサポートしていないので、単一の項目の挿入のみを処理しましょう。 ID の場合は、クライアントに戻る前に正規化する必要があります。 ただし、項目を挿入するときに、ペイロードの一部として項目の ID を渡し、項目を挿入する前に ID を正規化する必要がある場合も考える必要があります。

  <pre class="prettyprint">function insert(item, user, request) {
      var collectionName = tables.current.getTableName();
      var MongoClient = require('mongodb').MongoClient;
      var connectionString = process.env['MongoConnectionString'];
      MongoClient.connect(connectionString, function(err, db) {
          if (err) {
              console.log('Error connecting to the MongoDB: ', err);
              request.respond(500, { error: err });
              return;
          }
          db.createCollection(collectionName, function(err, collection) {
              if (err) {
                  console.log('Error creating collection: ', err);
                  request.respond(500, { error: err });
                  return;
              }
              if (Array.isArray(item)) {
                  request.respond(400, { error: 'Bulk inserts not supported' });
                  return;
              }

              // Normalize the id to what MongoDB expects
              mobileServiceIdToMongoId(item);

              collection.insert(item, { w: 1 }, function(err, result) {
                  if (err) {
                      console.log('Error inserting into the collection: ', err);
                      request.respond(500, { error: err });
                      return;
                  }

                  // Unwrap the inserted item
                  result = result[0];

                  // Normalize the id to what the mobile service client expects
                  mongoIdToMobileServiceId(result);

                  request.respond(201, result);
              });
          });
      });
  }


  function mobileServiceIdToMongoId(item) {
      var itemId = item.id;
      delete item.id;
      if (itemId) {
          item._id = itemId;
      }
  }


  function mongoIdToMobileServiceId(item) {
      var itemId = item._id;
      delete item._id;
      if (itemId) {
          item.id = itemId;
      }
  }</pre>

  また、同じ要求を再び送信した場合は、クライアントが想定した応答を受け取る必要があります。

  <pre class="prettyprint">HTTP/1.1 201 Created

  Content-Length: 187

  Content-Type: application/json

  Location: https://blog20140618.azure-mobile.net/tables/orders/539a41da134eac902318577e

  Server: Microsoft-IIS/8.0

  Date: Fri, 13 Jun 2014 00:12:10 GMT


  {
      "client":"John Doe",
      "orderDate":"2014-06-12T00:00:00.000Z",
      "items":[
          {"name":"bread","quantity":1,"price":1.99},
          {"name":"milk","quantity":1,"price":2.99}
      ],
      "id":"539a41da134eac902318577e"
  }</pre>

  "Location" HTTP ヘッダーも取得されました。node.js ランタイムから無料で取得できます (id を持つオブジェクトで 201 Created が返されたので)。

  <h3>読み取り</h3>

  挿入の場合と同様に、必要な実際の操作を実行する前に、データベースに接続してコレクションを取得する必要があります。 コードを繰り返すので、その一部を共有スクリプトに移動します。 git リポジトリのルートにある service/shared フォルダーに、"mongoHelper.js" という名前のファイルを作成し、次に示すコードを追加します。 mongo とモバイル サービス ID の間で変換する関数では、後で使用される オブジェクトで ID を変換するか削除するか決定するために、追加のパラメーターを追加します。

  <pre class="prettyprint">exports.connectAndGetCollection = function(collectionName, callback) {
      var MongoClient = require('mongodb').MongoClient;
      var connString = process.env["MongoConnectionString"];
      MongoClient.connect(connString, function(err, db) {
          if (err) {
              callback(err, null);
          } else {
              db.createCollection(collectionName, function(err, collection) {
                  if (err) {
                      callback(err, null);
                  } else {
                      callback(null, collection);
                  }
              });
          }
      });
  }


  exports.mobileServiceIdToMongoId = function(item, remove) {
      var itemId = item.id;
      delete item.id;
      if (itemId &amp;&amp; !remove) {
          item._id = itemId;
      }

      return itemId;
  }


  exports.mongoIdToMobileServiceId = function(item, remove) {
      var itemId = item._id;
      delete item._id;
      if (itemid &amp;&amp; !remove) {
          item.id = itemId;
      }

      return itemId;
  }</pre>

  次に、読み取りスクリプトにアクセスします。 次に示す内容を含むファイルを service/tables/orders.read.jsファイルの下に作成します。 "標準" テーブルと同様に、読み取り要求には、ルックアップ (または 1 つの要素の読み取り、/tables/&lt;tableNameitem&lt;&gt;/ ID&gt; への GET 要求) と、項目の一覧を返す "一般的な" 読み取りという 2 種類があります。 関数に渡されるクエリ オブジェクトの "id" プロパティをチェックすることで、2 つの呼び出しを区別できます。 次のコードでは、読み取りを簡単にするために、2 つのケースを独自の関数で分割します。

  <pre class="prettyprint">function read(query, user, request) {
      var collectionName = tables.current.getTableName();
      var mongoHelper = require('../shared/mongoHelper');
      mongoHelper.connectAndGetCollection(collectionName, function(err, collection) {
          if (err) {
              console.log('Error creating collection: ', err);
              request.respond(500, { error: err });
              return;
          }

          if (query.id) {
              findSingleObject(collection, query.id, mongoHelper, request);
          } else {
              returnMultipleObjects(collection, query, mongoHelper, request);
          }
      });
  }</pre>

  1 つのオブジェクトを検索する場合は、コレクション オブジェクトで "findOne" メソッドを使用できます。 ただし、オブジェクト ID を検索する方法は異なります。 <a href="https://docs.mongodb.org/manual/reference/object-id/">MongoDB の ObjectID</a> (ID を渡さずに項目を挿入していた場合に取得する識別子の型) を使用している場合は、ObjectID オブジェクト自体 (または JSON プロジェクション { $oid: &lt;実際の id&gt;}) を使用して検索する必要があります。 それ以外の場合は、"_id" プロパティ自体で検索できます。 クライアントの要求からの ID は常に文字列なので、有効なオブジェクト ID のように見えるかどうかを確認してから、オブジェクト ID と "単純な" ID の両方を検索します。 それ以外の場合は、オブジェクト ID ではないとわかっているので、値を指定して簡単に_idできます。

  <pre class="prettyprint">function findSingleObject(collection, itemId, mongoHelper, request) {
      // Lookup operation: get for a single element
      var callback = function(err, item) {
          if (err) {
              console.log('error querying collection: ', err);
              request.respond(500, { error: err });
          } else {
              if (item) {
                  mongoHelper.mongoIdToMobileServiceId(item);
                  request.respond(200, item);
              } else {
                  request.respond(404);
              }
          }
      };
      var ObjectID = require('mongodb').ObjectID;
      if (ObjectID.isValid(itemId)) {
          // Maybe its a MongoDB object id; maybe it just looks like one
          collection.findOne({ _id: { $in: [ itemId, new ObjectID(itemId) ] } }, callback);
      } else {
          // It's not an object id; may have been created by the client
          collection.findOne({ _id: itemId }, callback);
      }
  }</pre>

  一般的な読み取りケースでは、サーバーは複数の項目を返します。 ここで、コレクション内のすべての項目を返します (クライアントによって渡されるページング/フィルター処理/並べ替えオプションは無視されます)。このオブジェクトに関する次の投稿では、クエリ オブジェクトの詳細を確認して、完全なクエリ機能を実装する方法を確認します。

  <pre class="prettyprint">function returnMultipleObjects(collection, query, mongoHelper, request) {
      // TODO: look at query parameters. For now, return all items.
      collection.find().toArray(function(err, items) {
          if (err) {
              console.log('error querying collection: ', err);
              request.respond(200, { error: err });
          } else {
              items.forEach(function(item) {
                  mongoHelper.mongoIdToMobileServiceId(item);
              });
              request.respond(200, items);
          }
      });
  }</pre>

  項目を挿入してクエリを実行できます。 残りの操作に進む...

  <h3>更新</h3>

  モバイル サービス テーブルでは、HTTP <strong>PATCH </strong>要求がサーバーに送信された場合に更新スクリプトが呼び出されます。 PATCH のセマンティクスは、要求本文で指定されたプロパティのみを変更し、コレクション オブジェクトの <a href="https://mongodb.github.io/node-mongodb-native/markdown-docs/insert.html#find-and-modify">findAndModify</a> メソッドにマップする必要があるという意味です。 また、前のセクションで説明した 2 つのケースの ID とアカウントに基づいてクエリを実行する必要があります。そのため、今度は、そのロジックを共有コードに移動する良い時期です。 この追加のエクスポートをファイル サービス/shared/mongoHelper.js

  <pre class="prettyprint">exports.queryForId = function(id) {
      /// &lt;summary&gt;
      /// Returns a query object which can be used to find an object with the given id.
      ///  the query will be a simple query by "_id" based on the value of the id if
      ///  the id is not a valid ObjectID, or a query by the id value or the ObjectID
      ///  value otherwise.
      /// &lt;/summary&gt;
      /// &lt;param name="id" type="String"&gt;The id to create the query for.&lt;/param&gt;
      /// &lt;returns&gt;An object which can be used as the query parameter in MongoDB's
      ///  collection methods "findOne" or "update".&lt;/returns&gt;
      if (ObjectID.isValid(id)) {
          return { _id: { $in: [ id, new ObjectID(id) ] } };
      } else {
          return { _id: id };
      }
  }</pre>

  また、update 関数では、それを使用できます。 "findAndModify" の結果がコールバックに渡され、エラーが発生してオブジェクトが更新された場合、更新されたオブジェクトは "result" パラメーターで渡され、呼び出し元に戻すことができます。 フィルター条件 (この例では ID に基づく) に一致する項目がない場合、その値は null/未定義になります。その場合、クライアントに 404 Not Found が返されます。 update メソッドでは、モバイル サービスと node.js 形式の間の変換に使用される関数の "remove" パラメーターを使用します。更新プログラムを適用するときにオブジェクトの ID を設定する必要はありません。

  <pre class="prettyprint">function update(item, user, request) {
      var collectionName = tables.current.getTableName();
      var mongoHelper = require('../shared/mongoHelper');
      mongoHelper.connectAndGetCollection(collectionName, function(err, collection) {
          if (err) {
              console.log('Error creating collection: ', err);
              request.respond(500, { error: err });
              return;
          }

          // Normalize the id to what MongoDB expects and remove it from the object.
          var itemId = mongoHelper.mobileServiceIdToMongoId(item, true);

          var params = {
              query: mongoHelper.queryForId(itemId),
              sort: [],
              update: { $set: item },
              options: { new: true }
          };

          collection.findAndModify(params.query, params.sort, params.update, params.options, function(err, result) {
              if (err) {
                  console.log('Error updating in the collection: ', err);
                  request.respond(500, { error: err });
                  return;
              }

              if (result) {
                  request.respond(200, result);
              } else {
                  request.respond(404);
              }
          });
      });
  }</pre>

  修正プログラムのセマンティクスは完了です。

  <h3>Deletes</h3>

  最後の操作は非常に単純です。要求から ID を取得し、その ID に一致する項目を削除します。

  <pre class="prettyprint">function del(itemId, user, request) {
      var collectionName = tables.current.getTableName();
      var mongoHelper = require('../shared/mongoHelper');
      mongoHelper.connectAndGetCollection(collectionName, function(err, collection) {
          if (err) {
              console.log('Error creating collection: ', err);
              request.respond(500, { error: err });
              return;
          }

          collection.remove(mongoHelper.queryForId(itemId), { w: 1 }, function(err, result) {
              if (err) {
                  console.log('Error deleting item in the collection: ', err);
                  request.respond(500, { error: err });
                  return;
              }

              if (result) {
                  request.respond(204);
              } else {
                  request.respond(404);
              }
          });
      });
  }</pre>

  そして、MongoDB コレクションを Azure のデータ テーブルとして公開する CRUD 操作の基本的な実装Mobile Servicesします。

  <h2>まとめ</h2>

  (.NET バックエンドとは異なり) node.js バックエンドから MongoDB コレクションを使用する "標準" のサポートがない場合でも、基本的なサポートの追加は複雑すぎないという結果を示しました。 次の投稿では、ページング、並べ替え、フィルター処理など、複雑なクエリ操作を実装するために、このシナリオについて説明します。 また、この投稿のコードを取得する場合は、 で確認できます<a title="</a>https://github.com/carlosfigueira/blogsamples/tree/master/AzureMobileServices/MongoDbOnNodeBackend/CRUDTests/SimpleOperations" href="https://github.com/carlosfigueira/blogsamples/tree/master/AzureMobileServices/MongoDbOnNodeBackend/CRUDTests/SimpleOperations">https://github.com/carlosfigueira/blogsamples/tree/master/AzureMobileServices/MongoDbOnNodeBackend/CRUDTests/SimpleOperations。


  また、いつものように、この投稿のコメント セクションまたは MSDN フォーラムで、コメント/提案/バグ レポートを自由 <a href="https://social.msdn.microsoft.com/Forums/windowsazure/en-US/home?forum=azuremobile">に残してください</a>。
