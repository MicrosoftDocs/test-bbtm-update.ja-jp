### YamlMime:Yaml
ms.openlocfilehash: 26a03151c62402e49869fcbe42ac1f0bc11d95d2
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139896853"
Slug: deep-dive-into-azure-iot-hub-notifications-and-device-twin
Title: Azure IoT Hub の通知とデバイスツインの詳細
Summary: Andrei Ilnitskii は Azure IoT Hub の重要な機能であり、デバイスから発行されたデータに対して SQL ベースのクエリを実行できます。 このようなデータは IoT Hub マネージストアに保存されます...
Content: "<p>Azure IoT hub の通知を使用すると、デバイスの登録、登録解除、データのレポートなど、IoT ソリューションで発生している操作について詳細な洞察を得ることができます。 デバイスツインと組み合わせることで、IoT ソリューションを制御および監視するための非常に強力なツールが提供されます。 Azure IoT Hub の通知を利用して、デバイスのツインプロパティを外部ストアにレプリケートする方法を次に示します。</p>\n\n<h2>Azure IoT でのデバイスデータの格納と管理</h2>\n\n<p>Azure IoT Hub の主な機能は、デバイスから発行されたデータに対して SQL ベースのクエリを実行できることです。 このようなデータは IoT Hub 管理されたストアに保存されるため、独自のストアをプロビジョニングしたり、データモデルを定義したり、ストアの同期を維持したり、カスタムストアを構築して維持するための他の課題を処理したりすることなく、IoT ソリューションで単純にデバイスデータをクエリできます。</p>\n\n<p>ただし、一部の IoT ソリューションでは、デバイスデータを外部ストアに保持する必要があります。 理由としては、IoT Hub データストアでサポートされていない方法 (グラフクエリ、テキスト検索など) でデバイスデータをクエリする必要がある場合や、デバイスデータをより広範なデータセットと結合する必要がある場合や、データのレプリケート先を制御する必要がある場合があります。</p>\n\n<p>これを説明するために、デバイス IoT Hub のライフサイクルとツインの変更通知を使用して、デバイス id とツインプロパティを外部ストア (具体的には、Azure Cosmos Graph データベースにレプリケートする方法を示す<a href=\"https://github.com/Azure-Samples/iot-hub-notifications-sync-graphdb\" target=\"_blank\">サンプル</a>を作成しました。 このサンプルでは、建物、部屋、床、サーモスタットのグラフを保持します。 新しいサーモスタットデバイスがプロビジョニングされると、サーモスタットの頂点がグラフに動的に追加されます。サーモスタットレポートによって&#39;の温度が報告されるため、この頂点が更新されます。 次の図は、サンプルのプロジェクト (blue) と、それに依存する Azure リソース (オレンジ色) とデータフロー全体を含むソリューションのアーキテクチャを示しています。</p>\n\n<p><img alt=\"clip_image001[6]\" border=\"0\" height=\"412\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2862e7bb-acd3-4141-b5cf-a977308e7f4b.png\" style=\"border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;\" title=\"clip_image001 [6]\" width=\"610\"></p>\n\n<p>サンプルは、次のプロジェクトに実装されています。</p>\n\n<ul>\n <li>ThermostatAdmin-新しいサーモスタットをプロビジョニングする管理ツール</li>\n <li>ThermostatDevice-IoT Hub に接続し、そのルーム &rsquo; の現在の気温を報告するサーモスタットデバイス</li>\n <li>syncgraphdbapp .csproj-Azure IoT Hub の通知を活用して、サーモスタットデータをより広範なグラフにレプリケートします</li>\n</ul>\n\n<h2>デバイスツイン &amp; の通知の入門</h2>\n\n<p><a href=\"https://docs.microsoft.com/en-us/azure/iot-hub/iot-hub-devguide-device-twins\" target=\"_blank\">デバイスツイン</a> は、IoT ソリューション &rsquo; のクラウドサービスとそのデバイスとの間で状態を同期するために使用されます。 各デバイス &rsquo; ツインは、必要なプロパティと報告されるプロパティのセットを公開します。 クラウドサービスは、必要なプロパティに、デバイスに送信する値を設定します。 デバイスは、必要なプロパティを要求したりサブスクライブしたりして、それらのプロパティを処理します。 同様に、デバイスは、ツイン &rsquo; の報告されるプロパティを介してクラウドサービスに送信する値をプロパティに設定します。 クラウドサービスは、ポイント参照によって報告された、または必要な &rsquo; プロパティを取得できます。また、「概要」で説明されているように、プロパティに基づいて一連のデバイスに対してクエリを実行できます。 または、クラウドサービスにデバイスライフサイクルイベントとツインプロパティ変更イベントが通知されることがあります。これにより、新しいデバイスが追加されたとき、既存のデバイスが削除されたとき、またはツインプロパティが変化したときにサービスが反応するようになります。</p>\n\n<p><img alt=\"Twin\" border=\"0\" height=\"312\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/b55f5e16-8877-40c3-a671-bc28ea79d6ff.png\" style=\"border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;\" title=\"ツイン\" width=\"610\"></p>\n\n<p>「」では、サンプルで使用されているいくつかのデバイスツインの基本について説明 &rsquo; します。 最初に、新しいサーモスタットをデバイスとして IoT Hub に登録する必要があります。 これにより、サーモスタットはハブに安全に接続し、ユーザー定義のデバイス ID を使用してクラウドサービスがデバイスを参照できるようになります。 ここでは、ThermostatAdmin からのスニペットを&#39;ます。</p>\n\n<pre class=\"prettyprint\">\n        async Task AddThermostatAsync(RegistryManager registryManager, string deviceId)\n        {\n            var device = new Device(deviceId);\n \n            Console.WriteLine($&quot;Add thermostat &#39;{deviceId}&#39; ...&quot;);\n            await registryManager.AddDeviceAsync(device);\n            Console.WriteLine(&quot;Thermostat added&quot;);\n \n            Twin thermostat = await registryManager.GetTwinAsync(deviceId);\n            PrintTwin(thermostat);\n        }\n</pre>\n\n<p>サーモスタットが登録されると、物理サーモスタットがハブに接続できるようにする接続文字列を構成できます。 IoT Hub は、現在、対称キーと x.509 証明書を使用した認証をサポートしています。 ThermostatDevice は、次のように前者を使用します。</p>\n\n<pre class=\"prettyprint\">\n        // create a device client to emulate therostat sending temperature update\n        Console.WriteLine(&quot;Create device client and connect to IoT Hub ...&quot;);\n        Service.Device device = await registryManager.GetDeviceAsync(deviceId);\n        if (device == null)\n        {\n            Console.WriteLine($&quot;Thermostat {deviceId} not registered. Please register the thermostat first.&quot;);\n            return;\n        }\n \n        var authMethod = new DeviceAuthenticationWithRegistrySymmetricKey(deviceId, device.Authentication.SymmetricKey.PrimaryKey);\n        var connectionStringBuilder = Device.IotHubConnectionStringBuilder.Create(iotHubConnectionStringBuilder.HostName, authMethod);\n        DeviceClient deviceClient = DeviceClient.CreateFromConnectionString(connectionStringBuilder.ToString(), Device.TransportType.Mqtt);\n \n        await deviceClient.OpenAsync();\n        Console.WriteLine(&quot;Thermostat connected&quot;);\n</pre>\n\n<p>上記のコードスニペットは、認証トークンを生成するために使用されるデバイス &rsquo; の対称キーを取得するために、IoT Hub から以前に登録したデバイスを取得します。 通常、デバイスには、この方法で対称キーを取得するためのアクセス許可がありませんが、サンプルのために実行されます。 次に、DeviceAuthenticationWithRegistrySymmetricKey オブジェクトのインスタンスを作成します。これは、ハブと通信するときに使用される認証方法を表し、デバイス &rsquo; の対称キーと ID を渡します。 次に、IotHubConnectionStringBuilder helper クラスを使用して、DeviceAuthenticationWithRegistrySymmetricKey オブジェクトと、デバイスが登録されている IoT Hub への URI を使用して、デバイス &rsquo; の接続文字列を生成します。 次に、DeviceClient を使用して、新しく形成された接続文字列を使用して DeviceClient を作成します。 OpenAsync はハブへのリンクを開きます。</p>\n\n<p>サーモスタットがハブに接続されたので、そのルーム &rsquo; の現在の温度を報告できます。 次の ThermostatDevice のコードスニペットは、ツインの報告されるプロパティを使用して現在の温度を報告します。</p>\n\n<pre class=\"prettyprint\">\n        var props = new TwinCollection();\n        props[&quot;temperature&quot;] = temperature;\n \n        Console.WriteLine();\n        Console.WriteLine($&quot;Update reported properties:&quot;);\n        Console.WriteLine(props.ToJson(Newtonsoft.Json.Formatting.Indented));\n\n        await deviceClient.UpdateReportedPropertiesAsync(props);\n        Console.WriteLine(&quot;Temperature updated&quot;);\n</pre>\n\n<p>TwinCollection クラスは、報告するプロパティのセットを指定します。 DeviceClient の UpdateReportedPropertiesAsync は、プロパティのセットを、ハブ&#39;s 既定のストアに永続化される IoT Hub に送信します。 クラウドサービスは、前に説明したように、デバイス ID またはクエリを使用して、特定のデバイスのプロパティを取得できます。</p>\n\n<p>デバイスツインの通知は、 <a href=\"https://docs.microsoft.com/en-us/azure/iot-hub/iot-hub-devguide-messages-read-custom\" target=\"_blank\">route</a>と呼ばれる別の IoT Hub 機能を使用して実装されます。 ルートを使用すると、さまざまな IoT Hub ソースからのデバイスメッセージと通知を、フィルターに基づいてユーザーが指定したエンドポイントに転送できます。 たとえば、IoT Hub にデバイスが追加または削除されるたびに、ルーティング可能な通知が発生します。 ツインプロパティが更新されるたびに、ルーティング可能な通知が発生します。 このサンプルでは、これらの通知の種類は両方とも、構成済みの Azure Event Hub エンドポイントにルーティングされます。 SyncGraphDbApp は、イベントハブでこれらの通知をリッスンし、グラフストアを同期します。 ルートは、Azure Portal または ARM テンプレートを使用して構成できます。</p>\n\n<h2>完全なソリューション</h2>\n\n<p>エンドツーエンドのサンプルを使用するには、 <a href=\"https://github.com/Azure-Samples/iot-hub-notifications-sync-graphdb\">GitHub</a>の詳細な手順に従ってください。</p>\n\n<p>このサンプルでは、syncgraphdbapp アプリケーションは Azure IoT Hub の通知を活用して、サーモスタットデータを Cosmos DB のグラフにレプリケートするクラウドサービスをシミュレートします。 syncgraphdbapp は、デバイスライフサイクル通知を使用して、新しいサーモスタットが ThermostatAdmin 経由で登録されるたびに、新しくプロビジョニングされた各サーモスタットの Cosmos DB Graph にサーモスタット頂点を作成します。 ThermostatDevice によって発行されたサーモスタット&#39;s 現在の温度 SyncGraphDbApp は、サーモスタット頂点の気温フィールドを更新します。</p>\n\n<p>SyncGraphDbApp は、デバイスのライフサイクルとツインの変更通知の処理を処理します。 内部的には、TwinChangesEventProcessor クラスは SyncGraphDBEventHub にルーティングされた通知を読み取り、それに応じてグラフを更新します。 プロセッサは、一般的な Azure Event Hub イベントプロセッサとして実装されています。これは、対応するファクトリクラス (TwinChangesEventProcessorFactory) があり、IEventProcessor を実装し、EventProcessorHost によってトリガーされることを意味します。 Azure Event Hub のイベントプロセッサの詳細については、「 <a href=\"https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-programming-guide\">Event Hubs プログラミングガイド</a>」を参照してください。</p>\n\n<p>TwinChangesEventProcessor ProcessEventAsync は、通知の新しいバッチが到着すると呼び出されます。 ProcessEventAsync は、SyncDataAsync を呼び出してバッチを処理し、最後に正常に処理された通知に基づいてイベントハブのチェックポイントを更新します。 チェックポイントを使用すると、SyncGraphDbApp を再起動し、通知を削除せずに処理を再開することができます。</p>\n\n<pre class=\"prettyprint\">\n        public async Task ProcessEventsAsync(PartitionContext context, IEnumerable&lt;EventData&gt; messages)\n        {\n     List&lt;EventData&gt; messagesList = messages.ToList();\n     int lastSuccessfulIndex = -1;\n     while (messagesList.Count &gt; 0)\n     {\n  lastSuccessfulIndex = await this.SyncDataAsync(context, messagesList);\n\n  await context.CheckpointAsync(messagesList[lastSuccessfulIndex]);\n\n  // remove all succeeded messages from the list\n  for (int i = 0; i &lt; lastSuccessfulIndex + 1; i++)\n  {\n      messagesList.RemoveAt(0);\n  }\n     }\n        }\n</pre>\n\n<p>各通知は、そのメッセージソースと操作の種類に基づいて処理されます。 これらは、各 notification &rsquo; s eventData からプルされます。 プロパティヘッダーと共に、ソースハブ名とデバイス ID を指定します。 次の表では、各メッセージソースと操作の種類の組み合わせの意味について説明します。</p>\n\n<table border=\"1\" cellpadding=\"2\" cellspacing=\"0\" width=\"80%\">\n <tbody>\n  <tr>\n   <td valign=\"top\" width=\"15%\">\n   <p align=\"left\"><strong>メッセージソース</strong></p>\n   </td>\n   <td valign=\"top\" width=\"15%\">\n   <p align=\"left\"><strong>操作の種類</strong></p>\n   </td>\n   <td valign=\"top\" width=\"60%\">\n   <p><strong>説明</strong></p>\n   </td>\n  </tr>\n  <tr>\n   <td valign=\"top\" width=\"15%\">deviceLifeCycleEvents</td>\n   <td valign=\"top\" width=\"15%\">createDeviceIdentity</td>\n   <td valign=\"top\" width=\"60%\">新しいデバイスがハブに登録されました</td>\n  </tr>\n  <tr>\n   <td valign=\"top\" width=\"15%\">deviceLifeCycleEvents</td>\n   <td valign=\"top\" width=\"15%\">deleteDeviceIdentity</td>\n   <td valign=\"top\" width=\"60%\">既存のデバイスの登録が解除されました</td>\n  </tr>\n  <tr>\n   <td valign=\"top\" width=\"15%\">twinChangeEvents</td>\n   <td valign=\"top\" width=\"15%\">アップデートツイン</td>\n   <td valign=\"top\" width=\"60%\">グラフ内の既存のツインに適用される変更セットが含まれています (例: PATCH)</td>\n  </tr>\n  <tr>\n   <td valign=\"top\" width=\"15%\">twinChangeEvents</td>\n   <td valign=\"top\" width=\"15%\">replaceTwin</td>\n   <td valign=\"top\" width=\"60%\">グラフ内の既存ツインを置き換える完全ツインを含みます (例: PUT)</td>\n  </tr>\n </tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p>SyncGraphDbApp は、各メッセージソースと操作の種類の組み合わせを処理するために、SyncCommand サブクラスを内部的に実装します。 CreateDeviceIdentitySyncCommand を開始するには、新しいサーモスタットを表す新しい頂点をグラフに追加し、サーモスタットを新しいエッジを介して位置に基づいて部屋の頂点に関連付けます。 このサンプルでは、一度に1つのルームに1つのサーモスタットのみを関連付けることができます。 また、通知は重複している可能性があることにも注意してください。 その結果、競合エラーを処理する必要があります。</p>\n\n<pre class=\"prettyprint\">\n        try\n        {\n            Console.WriteLine(&quot;Add new thermostat vertex ...&quot;);\n            vTwin = await this.AddVertexAsync(&quot;thermostat&quot;, graphTwinId, null);\n        }\n        catch (DocumentClientException ex) when (ex.Error.Code == &quot;Conflict&quot;)\n        {\n            Console.WriteLine($&quot;Thermostat vertex {graphTwinId} already exists in the graph.&quot;);\n            return;\n        }\n \n        // replace location\n        Location? location = this.ParseTaggedLocation(this.jTwin);\n        if (location != null)\n        {\n            await this.ReplaceLocationAsync(vTwin, location.Value);\n        }\n</pre>\n\n<p>DeleteDeviceIdentityCommand は、指定されたサーモスタットの既存の頂点と、サーモスタットを部屋に関連付けるエッジを削除します。</p>\n\n<pre class=\"prettyprint\">\n        string graphTwinId = MapGraphTwinId(this.hubName, this.twinId);\n        Console.WriteLine($&quot;Try remove twin {graphTwinId} from graph ...&quot;);\n\n        await this.ExecuteVertexCommandAsync($&quot;g.V(&#39;{graphTwinId}&#39;).drop()&quot;);\n</pre>\n\n<p>UpdateTwinSyncCommand は2つの手順を実行します。 1) サーモスタット&#39;s 頂点の温度フィールドを更新し、2) 位置が変更された場合はサーモスタットの頂点を新しい部屋の頂点に関連付けます。</p>\n\n<pre class=\"prettyprint\">\n        string graphTwinId = MapGraphTwinId(this.hubName, this.twinId);\n \n        Console.WriteLine(&quot;Get thermostat vertex ...&quot;);\n        Vertex vTwin = await this.GetVertexByIdAsync(graphTwinId);\n        if (vTwin == null)\n        {\n            Console.WriteLine(&quot;Vertex does not exist. Execute Add command ...&quot;);\n            await this.AddTwinAsync(this.hubName, this.twinId, this.jTwin);\n            return;\n        }\n \n        Dictionary&lt;string, string&gt; properties = null;\n        string reportedTemperature = this.ParseReportedTemperature(this.jTwin);\n        if (!string.IsNullOrWhiteSpace(reportedTemperature))\n        {\n            properties = new Dictionary&lt;string, string&gt;\n            {\n                {&quot;temperature&quot;, reportedTemperature }\n            };\n \n            Console.WriteLine(&quot;Update vertex temperature property ...&quot;);\n            vTwin = await this.UpdateVertexAsync(graphTwinId, properties);\n        }\n \n        Location? location = this.ParseTaggedLocation(this.jTwin);\n        if (location != null)\n        {\n            await this.UpdateLocationAsync(vTwin, location.Value);\n        }\n</pre>\n\n<p>置換 Etwinsynccommand は UpdateTwinSyncCommand と同じ実装を持ちます。これは、変更セットと完全な置換がこのシナリオで同じ方法で処理されるためです。</p>\n\n<ol>\n</ol>\n\n<h2>ヒント &amp; テクニック</h2>\n\n<ul>\n <li>SyncGraphDbApp は、IoT Hub 通知を使用して外部ストアを更新する方法を示す単一インスタンスコンソールアプリケーションです。 ソリューションをスケールするには、複数のインスタンスにスケーリングし、パーティション分割されたイベントハブでリッスンする Azure Worker ロールでホストする必要があります。 IoT Hub 通知では、通知&#39;s デバイス ID をイベントハブパーティションキーとして使用します。 その結果、デバイスのライフサイクルとツインの変更通知は、通知&#39;s デバイス ID に基づいてパーティションにルーティングされます。 詳細については、 <a href=\"https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-features\" target=\"_blank\">ドキュメント</a>を参照してください。</li>\n <li>TwinChangeEvents 通知を処理するときは、replaceTwin と updateTwin opTypes の両方を処理して、最新の変更が同期されていることを確認する必要があります。</li>\n <li>サンプルでは、IoT Hubが作成されると、ルートIoT Hubされます。 その結果、ターゲット イベント ハブには、ハブの開始からのすべてのデバイス ライフサイクルとツイン変更イベントが含&#39;含まれる。 これにより、SyncGraphDBApp は、グラフ DB を完全に同期するために必要なすべてのイベントを受け取ります。 ただし、SyncGraphDBApp が以前に作成されたハブを同期する必要がある場合、または SyncGraphDBApp がイベント ハブ&#39;の保持ポリシーよりも長い期間使用できなくなった場合は、SyncGraphDBApp を追い付く方法が必要になります。 このようなキャッチアップ プロシージャは次のように動作します。 <ol>\n  <li>前IoT Hub&#39;説明したように、ルートを作成します。</li>\n  <li>すべてのツインIoT Hubクエリを実行し、結果Graph DB を更新します。 SyncGraphDBApp&#39;Program.RunSyncSampleAsync は、この手順の単純な実装を示しています。</li>\n  <li>通知の処理を開始し、バージョンが db のバージョンより大きいツイン変更通知Graphします。</li>\n </ol>\n </li>\n <li>このサンプルで作成したルートでは、通知のソースとターゲットを指定します。 IoT Hubルートでは、条件と呼ばれる強力なフィルター処理メカニズムもサポートされています。 たとえば、サーモスタットが特定のしきい値を超える温度を報告する場合、この条件を異なる方法で処理する別のターゲットに通知を送信できます (つまり、通知を優先度の高い電子メールに変換します)。 次のルート構成には、温度報告プロパティが 100 を超える場合にのみ、通知が指定されたターゲット エンドポイントに転送されるという条件が含まれています。</li>\n</ul>\n\n<pre class=\"prettyprint\">\n              {\n                  &quot;name&quot;: &quot;TemperatureExceedsThreshold&quot;,\n                  &quot;source&quot;: &quot;TwinChangeEvents&quot;,\n                  &quot;condition&quot;: &quot;$body.properties.reported.Temperature.NewValue &gt; 100&quot;,\n                  &quot;endpointNames&quot;: [\n                    &quot;TemperatureExceedsThresholdNotifications&quot;\n                  ],\n                  &quot;isEnabled&quot;: true\n              },\n</pre>\n\n<h2>意見の投稿</h2>\n\n<p>サンプルを確認したら、フィードバックや提案があればお知らせください。また、GitHub に直接投稿をお送りください。</p>\n\n<h2>リファレンス</h2>\n\n<ul>\n <li><a href=\"https://docs.microsoft.com/en-us/azure/iot-hub/iot-hub-devguide-device-twins\">デバイス ツインについて</a></li>\n <li><a href=\"https://docs.microsoft.com/en-us/azure/iot-hub/iot-hub-devguide-query-language#get-started-with-device-twin-queries\">デバイス ツイン、ジョブ、およびメッセージ ルーティングの IoT Hub クエリ言語</a></li>\n <li><a href=\"https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-programming-guide\">Event Hubs のプログラミング ガイド</a></li>\n</ul>"
