### YamlMime:Yaml
ms.openlocfilehash: 62dfbae0f601d8f081fe499275586f8ecc39e5f7
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139905026"
Slug: azure-data-explorer-technology-101
Title: Azure Data Explorer Technology 101
Summary: '独自のトラブルシューティングのニーズのために、Azure Data Explorer チームは、サービスによって生成された大規模なテレメトリ データ ストリームに対してアドホック クエリを実行したいと考えています。 適切なソリューションがない場合は、それを作成することを決定しました。 '
Content: >-
  <p>Imagineタスクにチャレンジする場合: (1) 毎日数百億件のレコードを受け入れ可能なクラウド サービスを設計します。 (2) このデータを数週間または数か月間確実に格納する、(3) データに対する複雑な分析クエリに回答する、(4) データインジェストからクエリへの遅延の待機時間 (秒) を低く維持し、最後に (5) 構造化されたデータの組み合わせである場合でも、これらのクエリを数秒で完了する、 半構造化テキストとフリー テキスト</p>


  <p>これは、コード名 Kusto でクラウド サービスのAzure Data Explorerを<a href="https://azure.microsoft.com/services/data-explorer/" target="_blank"></a>開始するときに行ったタスク&ldquo;です。&rdquo; 初期のコア チームは、Microsoft Power BI サービスに取り組む 4 人の開発者で構成されました。 独自のトラブルシューティングのニーズのために、サービスによって生成された大規模なテレメトリ データ ストリームに対してアドホック クエリを実行する必要があります。 適切なソリューションがない場合は、それを作成することを決定しました。</p>


  <p>この種のテクノロジを必要と&rsquo;していたのは、Microsoft の唯一の人で、私たちは実現しました。 数か月の作業の中で、最初の内部顧客がいて、サービスの導入が安定して始まりました。</p>


  <p>5 年近く経って、brainchild はパブリック プレビューに入っています。 <a href="https://myignite.techcommunity.microsoft.com/sessions/66692" target="_blank">Scott Guthries&rsquo;</a><strong> </strong>&rsquo;の講演を見て、お知らせブログで説明している内容の詳細<a href="https://aka.ms/ade.blog.pulicpreviewlaunch" target="_blank">Azure Data Explorer確認できます</a>。 このブログ記事では、この記事の背後にあるテクノロジの基本について説明Azure Data Explorer。 詳細については、今後のテクノロジに関するホワイト <a href="https://aka.ms/ade.techwhitepaper" target="_blank">ペーパーを参照してください</a>。</p>


  <h2>Azure Data Explorerとは</h2>


  <p>Azure Data Explorer構造化データ、半構造化データ、非構造化データを取り込むクラウド サービスです。 その後、サービスは、このデータを格納し、数秒の待機時間で分析アドホック クエリに応答します。 一般的な用途の 1 つは、大量のテレメトリ データ ストリームを取り込んでクエリを実行することです。 たとえば、サービスチームAzure SQL Databaseサービスのトラブルシューティング、監視クエリの実行、サービスの異常の検出を行います。 これは、自動修復アクションを実行するための基礎として機能します。 Azure Data Explorerは、Microsoft Office クライアント テレメトリ データ ストリームの格納とクエリにも使用されます。Microsoft Office エンジニアは、ユーザーが個々の Microsoft Office スイートとやり取りする方法を分析できます。 もう 1 つの例は、Azure MonitorをAzure Data Explorerすべてのログ データを格納および照会する方法を示しています。 そのため、クエリを作成したAzure Monitorアクティビティ ログを参照した場合は、既にサービスのユーザーです。</p>


  <p>ユーザーがデータを使用Azure Data Explorer従来のリレーショナル データ モデルで整理されたデータを確認できます。 データはテーブルに編成され、テーブルのすべてのデータ レコードは、強力に型指定されたスキーマです。 テーブル スキーマは列の順序付きリストであり、各列には名前とスカラー データ型があります。 スカラー データ型は、構造化 (int、real、datetime、timespan など)、半構造化 (動的)、またはフリー テキスト (文字列) を使用できます。 動的型は、他のスカラー型、配列、またはそのような値のディクショナリの 1 つの値を保持できる JSON &ndash; に似ています。 テーブルはデータベースに含まれています。1 つのデプロイ (ノードのクラスター) で複数のデータベースをホストできます。</p>


  <p>サービスの機能を説明するために、サービス自体からのすべてのテレメトリ データを保持するためにチームが使用するデータベースの数値を次に示します。 このデータベースの最大のテーブルは、1 日あたり約 2,000 億件のレコード (合計約 1.6 PB の生データ) を受け取り、そのテーブルのデータはトラブルシューティングのために 14 日間保持されます。</p>


  <p>これらの 2,000 億件のレコードをカウントするために使用したクエリは、完了まで約 1.2 秒かかっています。</p>


  <pre>

  KustoLogs | where Timestamp &gt; ago(1d) | count</pre>


  <p>このクエリの実行中に、サービスは新しいログを (非常に同じテーブルに) それ自体に送信 <code>KustoLogs </code>しました。 次に示すのは、関連付け ID <code>ClientActivityId </code>に従ってすべてのログを取得するクエリです。ここでは、has 演算子を使用して列のインデックスという用語を強制的に使用し、一般的なトラブルシューティング ポイント クエリをシミュレートします。</p>


  <pre>

  KustoLogs | where Timestamp &gt; ago(1d) | where ClientActivityId has &quot;4c8fcbab-6ad9-491d-8799-9176fabaf93e&quot;</pre>


  <p>このクエリは、はるかに多くのデータが返される場合でも、完了まで約 1.1 秒かかっています。前のクエリよりも高速です。 これは、Timestamp 列と &ndash; <code>ClientActivityId </code>(文字列) 列の 2 つのインデックスが組み合わせて使用されるという事実が原因です。</p>


  <h2>データ ストレージ</h2>


  <p>ストレージ/クエリ エンジンの中心は、列ストア、テキスト インデックス作成、データ シャーディングという 3 つの非常に成功したテクノロジの組み合わせです。 シャード化列ストアにデータを格納すると、列順に配置されたデータは行順に格納されるデータよりも圧縮が優れたので、膨大なデータ セットを格納できます。 また、シャーディングを使用すると、使用可能なすべてのコンピューティング リソースを利用し、データを列に配置することで、システムが特定のクエリで必要ない列にデータを読み込むのを回避できるので、クエリのパフォーマンスも向上します。 テキスト インデックスや他のインデックス型を使用すると、テーブルの生データに対してクエリが述語化されている場合に、レコードのバッチ全体を効率的に&rsquo;スキップできます。</p>


  <p>基本的に、データは Azure BLOB に格納され、各データ シャードは 1 つ以上の BLOB で構成されます。 インジェスト プロセスで作成されると、データ シャードは変更できません。 データ シャード自体が削除されるまで、すべてのストレージ成果物は変更なしで同じ状態に保たれる。 これには、多くの重要な影響があります。</p>


  <ol>
      <li>これにより、クラスター内の複数のコンピューティング ノードが、複雑な変更管理の調整なしで、データ シャードをキャッシュできます。</li>
      <li>これにより、複数のコンピューティング クラスターが同じデータ シャードを参照できます。</li>
      <li>既存のストレージ成果物の一&rsquo;&ldquo;&rdquo;部を複雑に変更する複雑なコードが発生しなく、システムに堅牢性が追加されます。</li>
      <li>これにより、 &ldquo;データ シャードの&rdquo; ストレージ成果物がハード削除されない限り、以前のスナップショットに戻って移動できます。</li>
  </ol>


  <p>Azure Data Explorerは、データ シャード ストレージ成果物に独自の形式を使用します。このテクノロジ用にカスタム構築されています。 たとえば、この形式は、ストレージ成果物をクエリするプロセスによってメモリマップ可能にし、データ シャードのインデックス専用マージなど、テクノロジに固有のデータ管理操作を可能にするために構築されています。 クエリを実行する前にデータを変換する必要はありません。</p>


  <h2>行速度でのインデックス作成</h2>


  <p>行速度でフリーテキスト列と動的 (JSON に似た) 列のインデックスを作成する機能は、列ストアの原則に基いて構築された他の多くのデータベースとは別にテクノロジを設定する機能の 1 つです。 実際、逆テキスト インデックスを構築することは (低カーディナリティ インデックスには使用されますが、フリーテキスト フィールドでははほとんど役に立たしません)、コンピューティング リソース (ハッシュ テーブルは CPU キャッシュ サイズを超える場合が多い) と Storage リソース (逆インデックス自体のサイズは相当) の複雑なタスクです。</p>


  <p>Azure Data Explorerは、一意の逆インデックス設計を持っています。 既定のケースでは、すべての文字列列と動的 (JSON に似た) 列にインデックスが作成されます。 列のカーディ&ldquo;&rdquo;ナリティが高い場合、つまり、列の一意の値の数がレコードの数に近づくと、エンジンは既定で 2 つのひねりを加えた逆の用語インデックスを作成します。 インデックスはシャード レベルで保持されます。そのため、複数のデータ シャードを複数のコンピューティング ノードで並列に取り込み、細分性が低いので、各用語のレコードごとのヒット/ミス情報を保持する代わりに、この情報は約 1,000 レコードのブロックごとに保持されます。 細分性の低い&rsquo;インデックスは、相関関係 ID など、めったに発生しない用語をスキップする場合でも効率的であり、生成と読み込みのための効率が高いほど十分に小さくなります。 もちろん、インデックスがヒットを示す場合でも、レコードのブロックをスキャンして、述語に一致する個々のレコードを特定する必要がありますが、ほとんどの場合、この組み合わせにより、パフォーマンスが速くなります (より高速になる可能性があります)。</p>


  <p>また、粒度が低く、インデックスが小さいため、データ シャードをバックグラウンドで格納する方法を継続的に最適化できます。 小さいデータ シャードはバックグラウンド アクティビティとしてマージされ、圧縮とインデックス作成が向上します。 たとえば、含まれるデータは継続的に取り込まれるため、クエリの待機時間を小さくする必要があります。 特定のサイズを超えて、データ自体を保持するストレージ成果物はマージを停止し、エンジンはインデックスをマージします。これは、通常、インデックスをマージするのに十分な小ささなので、クエリのパフォーマンスが向上します。</p>


  <h2>列の圧縮</h2>


  <p>列のデータは、標準の圧縮アルゴリズムによって圧縮されます。 既定では、エンジンは <a href="https://en.wikipedia.org/wiki/LZ4_(compression_algorithm)" target="_blank">LZ4</a> を使用してデータを圧縮します。このアルゴリズムは優れたパフォーマンスと妥当な圧縮率を備えます。 実際、この圧縮は、データを圧縮解除する価値があるという理由で、データを圧縮解除する価値があるという理由だけで、データを圧縮解除するより常に優先されると見積もっています。 <a href="https://en.wikipedia.org/wiki/Lempel–Ziv–Markov_chain_algorithm" target="_blank">LZMA</a> や <a href="https://en.wikipedia.org/wiki/Brotli" target="_blank">Brotli</a> などの追加の圧縮アルゴリズムがサポートされますが、ほとんどのお客様は既定値を使用しています。</p>


  <p>エンジンは、RAM キャッシュに読み込まれる場合を含め、圧縮されたデータを常に保持します。</p>


  <p>興味深いトレード&ldquo;&rdquo;オフの 1 つは、テーブル モデルの作成などによって使用される垂直方向の圧縮Microsoft SQL Server 分析サーバー回避する方法です。 この列ストアの最適化では、最終的にデータを圧縮して格納する前にデータを並べ替える方法がいくつか検索されます。その結果、多くの場合、圧縮率が向上し、データの読み込みとクエリ時間が向上します。 この最適化は、CPU Azure Data Explorer高く、クエリでデータを迅速に使用できる必要がある場合に、この最適化を回避します。 このサービスを使用すると、主要なクエリ パターンがある場合にデータの優先並べ替え順序を顧客が示し、最適化として垂直圧縮を将来のバックグラウンド アクティビティにする可能性があります。</p>


  <h2>メタデータのストレージ</h2>


  <p>データと共にAzure Data Explorer、次のようなデータを記述するメタデータも保持されます。</p>


  <ol>
      <li>データベース内の各テーブルのスキーマ</li>
      <li>データ インジェスト、クエリ、およびバックグラウンド クリーンアップ アクティビティ中に使用されるさまざまなポリシー オブジェクト</li>
      <li>セキュリティ ポリシー</li>
  </ol>


  <p>メタデータは、変更できない Azure Blob Storage 成果物の &ndash; データ ストレージと同じ原則に従って格納されます。 変更できない BLOB は &ldquo;&rdquo; HEAD ポインター BLOB のみです。これは、最新のメタデータ スナップショットに関連するストレージ成果物を示します。 このモデルには、不変による上記のすべての利点があります。</p>


  <h2>コンピューティング/Storage分離</h2>


  <p>Azure&rsquo; の設計者が行う初期の決定の 1 つは、コンピューティング、Storage、およびネットワークという 3 つの基本的なコア サービス間に分離を確保することでした。 &ndash; Azure Data Explorerこの原則に厳密に準拠している場合、すべての永続的なデータは Azure Blob Storage に保持され、Compute &ldquo;&rdquo; に保持されるデータは Azure BLOB 内のデータのキャッシュに過ごしたデータと考えらされます。 これにはいくつかの重要な利点があります。</p>


  <ol>
      <li>独立したスケールアウト。コンピューティングを個別にスケールアウトできます (&rsquo;たとえば、同時に実行されるクエリの数が増えてクラスターの CPU 負荷が増加した場合) と Storage (たとえば、1 秒あたりのストレージ トランザクション数が 1 秒あたりのストレージ トランザクション数が増えるポイントに追加の Storage リソースが必要な場合など)。</li>
      <li>障害に対する回復性。 障害が発生した場合は、単純に新しいコンピューティング クラスターを作成し、複雑なデータ移行プロセスなしで古いコンピューティング クラスターからのトラフィックを切り替えます。</li>
      <li>コンピューティングをスケールアップする機能。 上記と同様の手順を適用します。新しいクラスターは、古いクラスターよりも高いコンピューティング SKU になります。</li>
      <li>同じデータを使用する複数のコンピューティング クラスター。 同じデータを使用する複数のクラスターを作成することもできます。そのため、お客様は、たとえば、クラスター間で完全に分離された異なるクラスターで異なるワークロードを実行できます。 1 つのクラスター&ldquo;&rdquo;がリーダーとして機能し、Storage &ldquo;&rdquo; に書き込むアクセス許可が付与され、他のすべてのクラスターはフォロワーとして機能し、そのデータの読み取り専用モードで実行されます。</li>
      <li>SKU の適性の向上。 これは、スケールアウトに密接に関連しています。サービスによって使用されるコンピューティング ノードは、ワークロードの要件に正確に合わせて調整できます。これは、ストレージに適した SKU を使用して Azure Storage が永続ストレージを処理できるからです。</li>
  </ol>


  <p>最後に、&rsquo;&ndash;データ レプリケーションを通じてデータを確実に格納Azure Storageを行う場合は、Azure Storage に依存しています。 つまり、サービス ノード間で行う必要がある調整作業は非常に少なく、サービスが大幅に簡素化されます。 基本的に、メタデータの書き込みだけ調整する必要があります。</p>


  <h2>コンピューティング データ キャッシュ</h2>


  <p>Azure Data Explorer はコンピューティングと Storage を分離するために注意が必要ですが、実際にはローカルの揮発性 SSD &ndash; &ldquo;&rdquo; ストレージをキャッシュとして完全に使用します。エンジンには高度なマルチ階層データ キャッシュ システムが用意されています。これにより、最も関連性の高いデータが CPU に可能な限り密接にキャッシュされます。 このシステムは、変更できないデータ シャード ストレージ成果物に重大に依存し、次の層で構成されます。</p>


  <ol>
      <li>Azure Blob Storage&ndash;永続ストレージ、持続性ストレージ、および信頼性の高いストレージ</li>
      <li>Azure Compute SSD (またはManaged Disks) &ndash; 揮発性ストレージ</li>
      <li>Azure Compute RAM 揮発性 &ndash; ストレージ</li>
  </ol>


  <p>キャッシュ システムの興味深い側面は、圧縮されたデータで完全に動作することです。 つまり、RAM 内の場合でもデータは圧縮され、実際のクエリに必要な場合にのみ圧縮解除されます。 これにより、制限付き/コストの高いキャッシュ リソースを最適に使用できます。</p>


  <h2>分散データ クエリ</h2>


  <p>Azure Data Explorer &ndash; の背後にある分散データ クエリ テクノロジは、大量の非構造化データに対するアドホック分析に優れたサービスを構築するシナリオの影響を強く受け取っています。 次に例を示します。</p>


  <ol>
      <li>このサービスは、クエリによって生成された一時データを、クラスター集計 RAM に保持されている揮発性&rsquo;データとして処理します。 一時的な結果はディスクに書き込まれます。 これには、クラスター内のノード間で転送中のデータが含まれます。</li>
      <li>このサービスには、クエリ タイムアウト (約 4 分) に対するかなり短い既定値があります。 ユーザーはクエリごとにこのタイムアウトを増やす必要がありますが、ここでの前提は、クエリが高速で完了する必要があるという前提です。</li>
      <li>サービス クエリでは、関連するすべてのデータ シャード &ldquo;がクエリ プランにスタンプされ、スナップショット&rdquo; の分離が提供されます。 データ シャードは変更できないので、クエリ プランでデータ シャードの組み合わせを参照する必要があります。 &rsquo;&ldquo;&rdquo;さらに、クエリはタイムアウト (既定では 4 分、最大 1 時間まで増やされる可能性があります) が発生する可能性があります。削除後、データ シャードが 1 時間残り、その間は新しいクエリで使用できなくなったデータ シャードを保証するのに十分です。</li>
      <li>おそらく最も重要です。このサービスは、使いやすさと表現力の両方を実現するために最適化された新しいクエリ言語を実装します。 ユーザーから、この構文で表現されたクエリを作成して読み取るのが (最後に) 気に入ったと伝えます。 言語計算&rsquo;モデルは、主にリレーショナル データ モデル用に構築されるという点で SQL に似ていますが、構文自体は、コマンドの Unix パイプラインなどのデータ フロー言語の後にモデル化されます。</li>
  </ol>


  <p>実際、クエリ言語は大きな前進と見なされ、それを中心に構築されたツールセットは、その導入を推進したサービスの最も重要な側面の 1 つと見なされます。 クエリ言語の詳細については、以下を <a href="https://aka.ms/ade.ql" target="_blank">参照してください</a>。 オンラインの <a href="https://www.pluralsight.com/courses/kusto-query-language-kql-from-scratch" target="_blank">PluralSight コースを受講できます</a>。</p>


  <p>&rsquo;&ldquo;&rdquo;エンジン分散クエリ層の興味深い機能の 1 つは、クロスクラスター クエリをネイティブにサポートし、オプティマイザーでクエリ プランを再配置し、2 つ以上のクラスター間で交換されるデータの量を減らすために必要に応じて、クエリの多くが他のクラスターにリモート処理される点です。</p>


  <h2>まとめ</h2>


  <p>この投稿では、&rsquo;この記事の背後にあるテクノロジの基本について説明Azure Data Explorer。 サービスの詳細については、今後数週間以内に引き続きお知りください。</p>


  <p>この方法の詳細についてはAzure Data Explorer次の方法があります。</p>


  <ul>
      <li><a href="https://azure.microsoft.com/services/data-explorer/" target="_blank">今すぐAzure Data Explorerプレビューで試してみてください</a>。</li>
      <li><a href="https://azure.microsoft.com/pricing/details/data-explorer" target="_blank">サービスの価格情報</a> をAzure Data Explorer。</li>
      <li><a href="https://docs.microsoft.com/en-us/azure/data-explorer/" target="_blank">Azure Data Explorer</a> のドキュメントにアクセスします。</li>
  </ul>
