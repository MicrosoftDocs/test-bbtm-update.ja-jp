### YamlMime:Yaml
ms.openlocfilehash: 84b2ece8da121b9484503d247fe9e15dbaba5f07
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139893678"
Slug: writing-blobs-from-sql-azure-to-windows-azure-storage
Title: SQL Azure から Windows Azure Storage への blob の書き込み
Summary: '[この記事は SQL Azure チームによって提供されました。]このブログの投稿で説明されている sqlstream クラスでは、次のような Windows Azure Storage に書き込むことができます。'
Content: '<p>[この記事は SQL Azure チームによって提供されました。]</p><p>このブログの投稿で説明されている<b>sqlstream</b>クラスでは、SQL Azure から Windows Azure Storage に書き込むことができます。 Windows Azure storage は、クラウド内に永続的な永続的なストレージを提供します。 ストレージサービスにアクセスするには、 <a href="https://windows.azure.com/Cloud/Provisioning/Default.aspx">azure portal</a>で作成されたストレージアカウントが必要です。</p>  <p>会社では、製品のイメージを、タイトル、価格、説明などの他の製品データと共に、データベースに格納することを義務付けている Imagine ます。 Web ページでこれらのイメージを処理する方法の1つは、データベースからそれらのイメージを取得し、ブラウザーにストリーミングすることです。</p>  <p>ただし、より良い方法としては、最初の要求でデータベースからそれらを読み取り、各要求で処理される Azure Storage Windows にそれを書き込むことが考えられます。 SQL Azure の他の製品データとイメージを維持するためのデータの整合性を確保し、Windows Azure Storage から静的ファイルをストリーミングすることによってパフォーマンス上の利点を得ることができます。 これは、Azure Content Delivery Network Windows を利用できる場合に特に役立ちます。</p>  <p>次のコードサンプルでは、Adventure Works データベースを使用してこのシナリオを実装します。この場合、製品のサムネイルは <b>varbinary (max)</b>として格納されます。 コードは次のように設計されています。</p>  <ul>   <li>Windows Azure platform から実行します。 </li>    <li>クエリ文字列の製品 id を使用して、要求から ASP.NET ページへのイメージを配信します。 </li>    <li>Adventure works データベースの Products テーブルからイメージを読み取り、サムネイル画像がまだ存在しない場合は Windows Azure Storage に書き込みます </li>    <li>イメージを提供するためにブラウザーを Windows Azure Storage にリダイレクトします。 </li>    <li>はストリーミングを使用して、イメージ全体がメモリ領域に読み込まれないようにします。 </li> </ul>  <p>SQL Azure データベース、Windows Azure Web ロール、および Windows Azure Storage コンテナーが同じデータセンターにある場合、SQL Azure と Windows Azure Storage 間でデータを転送するコストは発生しません。 これは SQL Azure から Windows Azure Storage への直接的な転送ではないことに注意してください。コードは SQL Azure からイメージを読み取り、Windows Azure Cloud Storage に書き込みます。 コードを実行すると、データは Windows Azure ロールを通過します。</p>  <h2>コード</h2>  <pre class="csharpcode"><span class="kwrd">protected</span> <span class="kwrd">void</span> Page_Load(<span class="kwrd">object</span> sender, EventArgs e)  {      Int32 id = Int32.Parse(Request.QueryString[<span class="str">&quot;ProductId&quot;</span>]);        CloudStorageAccount.SetConfigurationSettingPublisher(          (configName, configSetter) =&gt;      {           <span class="kwrd">if</span> (!configSetter(               RoleEnvironment.GetConfigurationSettingValue(configName)))               RoleEnvironment.RequestRecycle();      });        CloudStorageAccount cloudStorageAccount =                CloudStorageAccount.FromConfigurationSetting(                  <span class="str">&quot;DataConnectionString&quot;</span>);      CloudBlobClient cloudBlobClient =                cloudStorageAccount.CreateCloudBlobClient();      CloudBlobContainer cloudBlobContainer =               cloudBlobClient.GetContainerReference(<span class="str">&quot;images&quot;</span>);      cloudBlobContainer.CreateIfNotExist();        <span class="rem">// WWB: Set Up Public Access To the Container       //(So That We Can Redirect Anyone To the Image)      // Be careful of the putting confidential information on a public       // network, this example is for images.</span>      BlobContainerPermissions permissions = cloudBlobContainer.GetPermissions();      permissions.PublicAccess = BlobContainerPublicAccessType.Container;      cloudBlobContainer.SetPermissions(permissions);        <span class="rem">// WWB: Get Connection String from .cscfg</span>      String connectionString =          RoleEnvironment.GetConfigurationSettingValue(<span class="str">&quot;SqlConnectionString&quot;</span>);        <span class="kwrd">using</span> (SqlConnection sqlConnection =             <span class="kwrd">new</span> SqlConnection(connectionString))      {          sqlConnection.Open();            <span class="rem">// WWB: Get The File Name From SQL Azure For This Id</span>          <span class="rem">// The FileName is Stored In the Products Table</span>          String fileName = FetchFileName(sqlConnection, id);            <span class="kwrd">try</span>          {              CloudBlockBlob cloudBlockBlob =                  cloudBlobContainer.GetBlockBlobReference(fileName);                <span class="rem">// WWB: Set the Blob Options So That We Only Upload Once </span>              BlobRequestOptions blobRequestOptions = <span class="kwrd">new</span> BlobRequestOptions();              blobRequestOptions.AccessCondition =                   AccessCondition.IfNoneMatch(“*”);                <span class="rem">// WWB: Open a Stream to SQL Azure</span>              <span class="kwrd">using</span> (SqlStream sqlStream = <span class="kwrd">new</span> SqlStream(                  sqlConnection, <span class="str">&quot;SalesLT&quot;</span>,                  <span class="str">&quot;Product&quot;</span>,                  <span class="str">&quot;ThumbNailPhoto&quot;</span>,                  <span class="str">&quot;ProductID&quot;</span>, SqlDbType.Int, id))              {                  <span class="rem">// WWB: Upload To Azure Storage Using Our Stream</span>                  cloudBlockBlob.UploadFromStream(sqlStream);              }                <span class="rem">// WWB: Redirect This Request For An Image To Blob Storage URL</span>              Response.Redirect(cloudBlockBlob.Uri.AbsoluteUri);            }          <span class="kwrd">catch</span> (StorageClientException storageClientException)          {              <span class="kwrd">switch</span> (storageClientException.ErrorCode)              {                  <span class="kwrd">case</span> StorageErrorCode.ConditionFailed:                  <span class="kwrd">case</span> StorageErrorCode.BlobAlreadyExists:                      <span class="kwrd">break</span>;                  <span class="kwrd">default</span>:                      <span class="kwrd">throw</span>;              }          }      }  }    <span class="kwrd">private</span> String FetchFileName(SqlConnection sqlConnection, Int32 id)  {      String sql = <span class="str">&quot;SELECT [ThumbnailPhotoFileName] FROM&quot;</span> +          <span class="str">&quot;[SalesLT].[Product] WHERE [ProductID] = @Id&quot;</span>;      <span class="kwrd">using</span> (SqlCommand sqlCommand = <span class="kwrd">new</span> SqlCommand(sql, sqlConnection))      {          sqlCommand.Parameters.AddWithValue(<span class="str">&quot;@Id&quot;</span>, id);          <span class="kwrd">using</span> (SqlDataReader sqlDataReader = sqlCommand.ExecuteReader())          {              <span class="kwrd">if</span> (!sqlDataReader.HasRows)                  <span class="kwrd">throw</span> (<span class="kwrd">new</span>                    ArgumentException(<span class="str">&quot;Id Not Found&quot;</span>,                        <span class="str">&quot;id&quot;</span>));                sqlDataReader.Read();                <span class="kwrd">return</span>                ((String)sqlDataReader[<span class="str">&quot;ThumbnailPhotoFileName&quot;</span>]);          }      }  }</pre>    <p>    <h2>コードの使用</h2>    <p>このコードは非常に汎用であり、他のシナリオで使用できます。 1つの興味深いアイデアは、ローカルの SQL Server データベースを使用してローカルにホストされている IIS サーバーからこれを実行することです。 このコードでは、ローカルの SQL Server を読み取り、データベース内のイメージを Windows Azure Storage にプッシュして、Windows Azure CDN から処理できるようにします。</p>    <p>最初の要求は、SQL Azure からの読み取りと Windows Azure Storage への書き込みを行う必要があるため、他のすべての要求よりも長い時間がかかります。 もう1つの考え方として、Windows Azure Storage を事前に読み込むことで、最初の要求の応答時間が長くならないようにすることができます。 Windows Azure Web ロールのイメージをアップロードする場合は、アップロード後に Windows Azure Storage に書き込むことができます。 これにより、SQL Azure の2か所にイメージデータが入力され、製品データと Windows Azure Storage のイメージコンテナーが表示されます。</p>    <h2>まとめ</h2>    <p>質問、懸念事項、コメントがありますか。 これらを下に投稿してください。</p>'
