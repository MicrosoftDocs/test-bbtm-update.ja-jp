### YamlMime:Yaml
ms.openlocfilehash: 77891dd01f95e9a08cae963c98e5c06f7a1ee224
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139908916"
Slug: is-your-code-ready-for-the-leap-year
Title: コードは閏年の準備ができていますか?
Summary: 2016 年は閏年であり、バグを防ぐために慎重にコード化されていないソフトウェア アプリケーションの問題を意味する可能性があります。 注目すべきバグの種類と、Leap Year が過去に Azure や他のソフトウェアにどのような影響を与えたかについて詳しく説明します。
Content: "<p>2 月に入り、2016 年はうるう年です。<strong></strong> ほとんどの人にとって、これは単に興味深い奇数かもしれません。作業または再生する余分な日。 しかし、ソフトウェア開発者にとって、うるう年は大きな問題を引き起こす可能性があります。</p> <p>今、コードで <em>閏年</em> のバグを確認する場合は、迅速に移行する方が良いです。 実際には、既に <em>影響が </em>発生している可能性があります。また、それを認識していない可能性があります。 コードにどのような種類のバグが含まれていますか?</p> <ul> <li>オフバイワンの問題(特に日付範囲クエリを使用したデータ フィルター処理に関する問題)  <li>ユーザー インターフェイスでの予期しない動作または望ましくない動作  <li>エッジ ケースが発生した場合に例外、クラッシュ、ハングする可能性がある </li></ul> <p>\"Meh\" と言います。 \"マイ コードは問題ありません。 単体テストがあります。\"</p> <p>\"はい、\" と言います。 \"テストではクロックを適切にモックしますか? 2 月 29 日と 12 月 31 日を含むエッジ ケースをテストしますか? システムの他の部分と同様に、低レベルの C++ コードをテストしましたか? うるう年のバグを知っていますか?\"</p> <p>ほとんどの場合、空白の星が見つめらされます。</p> <h1>Azure でこれが重要な理由</h1> <p>実際には、開発者が記述する可能性があるコードに当てはまるだけで、その多くが Azure クラウドで実行される可能性があります。 Azure では <a href=\"https://azure.microsoft.com/en-us/blog/summary-of-windows-azure-service-disruption-on-feb-29th-2012/\" target=\"_blank\">2012</a> 年に独自の閏年の停止が発生し、今回はスムーズなエクスペリエンスを確保するために取り組み続けとなりました。 それ以降、すべてのお客様に調査とエクスペリエンスの恩恵を受け取ってみたいと考えています。</p> <h1>では、何を知る必要がありますか?</h1> <p>ここで取り上がるべきことが多いので、まず最も重要な点から始めしましょう。</p> <ul> <li><strong>2 月 29 日</strong> は、leap 年の影響を受ける唯一の日ではありません。 もう 1 つの非常に重要な日付は <strong>12 月 31</strong> 日です。これは、1 年の 366 日目であり、多くのアプリケーションが誤って 1 年に 365 日としてハードコードを行ったためです。  <ul> <li>クラウドに関して特に考慮する必要がある場合は、ほとんどのクラウド アプリケーションで UTC (協定世界時) を使用するか、少なくとも使用する必要があります。 つまり、2 月 29 日の午前 0 時には、実際にはローカル タイム ゾーンで他の時刻になる可能性があります。 たとえば、米国太平洋のタイム ゾーンでは、2 月 28 日の午後 4 時 (カレンダーの前の日) に、うるうの日が UTC にヒットします。 <a href=\"https://www.timeanddate.com/worldclock/fixedtime.html?msg=Leap+Day+in+Universal+Time&amp;iso=20160229T00\" target=\"_blank\">他のタイム ゾーンで時刻を確認します</a>。  <li>うるう日の問題についてシステムをリアルタイムで監視する準備をしている場合は、2 月 28 日から 3 月 1 日の 3 日間のウィンドウを検討する必要があります。 同様に、12 月 30 日から 1 月 1 日の 366 日目の問題に注意する必要があります。 </li></ul> <li>Leap Year のバグは、任意の言語で見つかる可能性がありますが、C/ C++ コードでは最も危険です。このコードでは、アプリケーションのクラッシュやバッファー オーバーフロー (セキュリティ 上のリスク) が発生する可能性があります。  <li>過去の閏年には、次のような、影響が大きく、注目度の高いバグがいくつか含まれていました。  <ul> <li><a href=\"https://azure.microsoft.com/en-us/blog/summary-of-windows-azure-service-disruption-on-feb-29th-2012/\">2012 Microsoft Azure停止</a>: 証明書の有効期限の誤った計算により、最大 12 時間のサービス中断が発生しました  <li><a href=\"https://www.bbc.com/news/technology-17599701\">2012 TomTom GPS ナビゲーション のバグ</a>:多くのモデルが現在の場所を特定できなかった  <li><a href=\"https://www.nbcnews.com/id/35646131/ns/technology_and_science-games/t/leap-year-glitch-fixed-sony-playstation\">2010 年の再生ステーション</a> ネットワークの停止: 2010 年が閏年として誤って特定された場合に発生します  <li><a href=\"https://www.theguardian.com/technology/blog/2009/jan/01/zune-firmware-mistake\">2008 年 12</a> 月 31 日のロジック エラーが原因で発生する、すべての Microsoft Zune デバイスのブロック  <li><a href=\"https://blogs.technet.com/b/exchange/archive/2008/02/29/3405004.aspx\" target=\"_blank\">2008 Microsoft Exchange管理のバグ</a>: 管理者が 2 月 29 日に多くのことを実行できない  <li>Lotus 1-2-3 の 1900 年の誤算は、30 年以上経った現在のMicrosoft Excelに影響します。 </li></ul></li></ul> <p>これらは、ニュースの見出しを作成した大きなストーリーにすら見えます。 影響度や気付きやすさが異なる数千もの問題が発生したと思います。 <a href=\"https://catless.ncl.ac.uk/Risks/18.74.html#subj5\">1996</a> 年のもう 1 つのあまり知られていないうるう年のバグにより、実際には、ニュージーランドとタスマニアの植物を作り出す植物のプロセス制御システムが、12 月 31 日の午前 0 時 (366 日目) に突然シャットダウンされました。</p> <p>これにより、冷却金属の温度が規制されなきほど、機器に何百万ドルもの損害が発生しました。 このような過去のストーリーは、ソフトウェアリマインダーの現実世界の危険性の一部です。 IOT の最近の広範な導入とクラウド コンピューティングとの交差を考慮すると、全員が高いアラートを受け取る必要があります。</p> <h1>2 つの最も危険な閏年のバグ</h1> <h3>#1: C/ C++ での年の加算または減算</h3> <p>システム時刻を使用する C/C++ Win32 API、 <a href=\"https://msdn.microsoft.com/library/windows/desktop/ms724950.aspx\" target=\"_blank\"><font face=\"Courier New\">SYSTEMTIME</font></a> 構造体は、市民時間の一般的な表現です。 年、月、日の値 (その他) を区切って、日付の各部分に個別のフィールドがあります。 次のコードを見るのはとても一般的です。</p><pre class=\"prettyprint\">SYSTEMTIME st;       // declare a SYSTEMTIME variable \nGetSystemTime(&amp;st);  // set it to the current date and time \nst.wYear++;          // increment it by one year \n</pre>\n<p>このコードはエラーなしで成功します。 ただし、リスクは、コードが 2 月 29 日に呼び出された場合でも、結果の値は 2 月 29 日ですが、うるう以外の年 <em>になります</em>。 たとえば、 は <code>2016-02-29 + 1 year = 2017-02-29</code>存在しません。</p>\n<p>この値は、最終的に <a href=\"https://msdn.microsoft.com/library/windows/desktop/ms724948.aspx\" target=\"_blank\"><font face=\"Courier New\">SystemTimeToFileTime</font></a> などの別の関数にパラメーターとして最終的に渡される前にかなり渡される可能性があります。この場合、関数は戻り値が 0 で失敗します。 残念ながら、 <em>戻り値 </em>を確認せずにこのメソッドを使用するコードを見 <em>つけるのは非常に一般的です</em>。 これにより、初期化されていない状態の値を <code>FILETIME</code> 残すなど、予期しない結果が発生する可能性があります。</p>\n<ul>\n<li>Win32 関数 (特に ) の状態の結果を常に確認します <code>SystemTimeToFileTime</code>。 \n<li>結果の有効性を確認し <code>SYSTEMTIME</code> 、必要に応じて調整することで、正しく年を に追加します。 </li></ul><pre class=\"prettyprint\">SYSTEMTIME st;       // declare a SYSTEMTIME variable \nGetSystemTime(&amp;st);  // set it to the current date and time \nst.wYear++;          // increment it by one year \n\nleap year bool leap = st.wYear % 4 == 0 &amp;&amp; (st.wYear % 100 != 0 || st.wYear % 400 == 0) を確認します。 \n\n2 月 29 日ですが、閏年ではない場合は、2 月 28 日の st.wDay = st.wMonth == 2 &amp;&amp; st.wDay == 29 &amp;&amp; !leap ? に戻ります。 28 : st.wDay; </pre>\n<p>同様のバグは、標準の C++ (非コード) コードでも発生する可能性Windows注意してください。 構造体 <code>tm</code> は、 の代わりに使用されます。 <code>SYSTEMTIME</code>動作は若干異なります。 月は 1 から 12 ではなく 0 から 11 なので、2 月は月 1 です。 の代わりに、 <code>SystemTimeToFileTime</code>を呼び出して <code>_mkgmtime</code> 構造体を生成 <code>time_t</code> できます。 しかし、主な違いは、失敗するのではなく、閏年以外の年に 2 月 29 日を渡した場合、3 月 1 日を表す値が生成される点です。 アプリケーションは 2 月 28 日を予定している可能性があります。そうである場合は、調整する必要があります。</p>\n<h3>#2: 年の各日の値の配列を宣言する</h3><pre class=\"prettyprint\">int items[365];\nitems[dayOfYear - 1] = x;\n</pre>\n<p>上記の C コードは、C# または別の言語で簡単に書き換えるか、整数ではなく文字列または他のデータ型を使用できます。 重要な点は、データを保持する固定サイズの配列を宣言し、配列内に 1 年の毎日の場所が含まれており、それを想定することです。 もちろん、問題は、うるう年には、366 日目の 12 月 31 日の配列に配置されないという点です。</p>\n<p>この影響は言語によって大きく異なります。 C# では、これにより が発生します <code>IndexOutOfRangeException</code>。 C では、境界チェック コンパイラ オプションが有効になっていない限り、バッファー オーバーフローが発生します<a href=\"https://en.wikipedia.org/wiki/Buffer_overflow\" target=\"_blank\"></a>。その影響はごくわずか、またはかなりの<em>可能性があります</em>。 366 番目の要素が自動的に追加されるので、JavaScript 開発者はこの点について心配する必要が少ありません。</p>\n<h1>データ のフィルター処理に関する問題</h1>\n<p>前年の 2 月 28 日から次の年の 3 月 1 日まで、データに影響する可能性がある leap year バグの影響は他に存在します。 通常、これらはデータ <em>フィルター処理に含</em>まれており、範囲クエリでは余分な 1 日は考慮されません。1 年が常に 365 日と仮定するか、2 月が常に 28 日と仮定して。 次のようなSQLを検討してください。</p><pre class=\"prettyprint\">SELECT AVG(Total) as AverageOrder, SUM(Total) as GrandTotal\nFROM Orders WHERE OrderDate &gt;= @startdate AND OrderDate &lt; @enddate\n</pre>\n<p>このクエリは問題ありませんが、 が今日に<code>@enddate</code><code>@startdate</code>設定され、今日から 365 日を引いた値に設定されている場合の動作を検討してください。 範囲に 2 月 29 日のうるう日が含まれる場合、1 年をカバーしているのではありません。 開始日は 1 日短く、したがって、意図が実際に 1 年分のデータを表していたと仮定すると、値は正しくありません。</p>\n<p>このようなバグを評価する場合は、バグの影響 <em>を</em> 自分自身に問い合ってください。 この場合、これらの値はどこに表示されますか? たとえば、平均注文金額が毎日更新されるダッシュボードにグラフを供給している場合、SEC ファイリングなどの会社の財務レポートに年間の売上合計が一覧表示される場合ほど重要ではない可能性があります。 もちろん、この評価には、アプリケーションに精通しているユーザーとそれが使用されている必要があります。に従う one-size-fits-all ルールはありません。</p>\n<p>次のようなアプローチでこの問題を解決した方が良い場合があります。</p><pre class=\"prettyprint\">TimeSpan oneYear = TimeSpan.FromDays(isLeapYear(endDate.Year) ? 366 : 365);\nDateTime startDate = endDate - oneYear;\n</pre>\n<p>ただし、これはアプローチに欠陥があります。 年を評価するだけでは、追加する日数を決定できません。 と考 <code>endDate</code> え、 <code>2016-01-01</code>2016 年はうるう年ですが、到達するまでに減算する日数は 365 日のみです<code>2015-01-01</code>。 代わりに、2 月 29 日のうるう日を範囲に含めるかどうかを検討する必要があります。 これは、特に 1 年ではなく複数の年をカバーする場合に、手で行う場合は非常に複雑なコードになります。</p>\n<p>最終的には<code>TimeSpan</code>、.NET (および他の言語の同様の型) は絶対時間を表し、\"year\" と <em></em>\"month\" はどちらも市民時間の単位であるという事実に基になります。<em></em> 年または月の絶対時間 <em>は、記述 </em>する年または月によって異なる。 夏時間を考慮すると、実際には \"日\" でも同じことを言えますが、この投稿では問題が生じ始めていました。</p>\n<p>.NET の正しい解決策は次です。</p><pre class=\"prettyprint\">DateTime startDate = endDate.AddYears(-1);</pre>\n<p>メソッド <code>AddYears</code> は、前に進む日数を決定するために必要なすべてのロジックを正しく実装します。負の値の場合は後方に移動します。</p>\n<h1>JavaScript での年の追加</h1>\n<p>JavaScript 開発者は、実際には、<a href=\"https://momentjs.com\" target=\"_blank\"></a>次moment.js単純な方法で、これを使用する必要があります。</p><pre class=\"prettyprint\">var m = moment();\nm.add(1, 'years');\n</pre>\n<p>しかし、一部の人々は、多くの場合、これを見て、難しい方法で行うのを好む人もいます。</p><pre class=\"prettyprint\">var d = new Date();\nd.setFullYear(d.getFullYear() + 1);\n</pre>\n<p>ここでの問題は、前に説明した問題です。 今日が閏年の 2 月 29 日である場合、結果の値は 3 月 1 日になります。 これは、ユーザーに許容される場合と受け入れられない場合があります。 その他の日付ごとに、結果が元の値と同じ月にあるとします。 また、アプリケーションで月の開始日ではなく、月末の日付が予想される可能性も考慮してください。</p>\n<p>完全なライブラリを必要とせずに JavaScript で年を正しく追加するために使用できる関数を次に示します。</p><pre class=\"prettyprint\">function addYears(d, n) { \n  var m = d.getMonth(); \n  d.setFullYear(d.getFullYear() + n); \n  if (d.getMonth() !== m) \n  d.setDate(d.getDate() - 1); \n} \n\n// example usage \nvar d = new Date(); \naddYears(d, 1); \n</pre>\n<p>この実装では年数が加算され、3 月へのロールオーバーが発生したのか確認され、発生した場合は補正されます。 繰り返しになりますが、追加する日数を正確に確認して、これを実装しようとはしません。実際に何 <em>を行</em> っているのかわかっている場合を限り、</p>\n<h1>その他の一般的な間違い</h1>\n<p>開発者がうるう年に関連して間違ったことは他にも多数ある。次に例を示します。</p>\n<ul>\n<li>Leap Year アルゴリズムを台無しにしています。 4 年ごとにではありません。 年が 400 で割り切れない限り、4 年ごとに 100 分の <em></em> 1 になります。 1900 は閏年ではありません。 2000 年は閏年でした。 2100 は閏年ではありません。 \n<li>毎月の日数の配列を使用します。2 月には 28 日があります。 このような配列を使用する場合は、leap 年の 29 日目を考慮する必要があります。 より優れた方法は、一般的な <em>年とは</em> 異なる配列を leap 年に使用する方法です。 または、計算を自分で行う代わりに、(使用可能な場合) API を使用する方が良いです。 \n<li>leap 年のコードを分岐し、すべてのコード パスをテストする必要はありません。 たとえば、Zuneバグのコードの<a href=\"https://www.theguardian.com/technology/blog/2009/jan/01/zune-firmware-mistake\"></a>上部に <font face=\"Courier New\">IsleapYear(year)</font> ブランチがあります。これは明らかにテストされません。 \n<li>で個別の年、月、日の値を検証せずに使用する。 たとえば、各コンポーネントを選択するための個別のドロップダウン コントロールを含む UI を使用できます。 その日が月内に有効であるテストでは十分ではありません。 また、年を考慮する必要 <em>があります</em>。 \n<li>日付計算 <em>で</em> 365.25 日や 365.2425 日など、1 年間の平均長を使用する。 これは科学的に正確ですが、実際の市民時間の操作には適した操作ではありません。 少なくとも、正確な値を気にする場合はそうではありません。 近似値だけが必要な場合でも問題ありませんが、関連付けられている時刻は結果でオフになる可能性があります。 </li></ul>\n<h1>操作方法年のバグをキャッチしますか?</h1>\n<ul>\n<li>コードを慎重に精査します。 時間に関連する何かを検索し、細かいくちぎりを付け、それを確認します。\n<li>多数の単体テストを行い、\"クロックをモックする\" 方法を確認します (次のセクションで説明します)。 \n<li>うるう年の前ではなく、一年中テストします。 \n<li>構成を含むすべての入力を検証 <em>します</em>。 \n<li>結果を検証し、シナリオを完了します。 障害戦略を持っている。 </li></ul>\n<p>他の 2 つのアプローチについてよく聞かされます。</p>\n<h3>スタティック コード分析</h3>\n<p>閏年のバグが発生した場所を示すコードに対して実行できるツールのセットだけがある場合は、すばらしいでしょう。 残念ながら、私は何も知りません。 単純な文字列検索、または正規表現検索は、ここまでしか取得できます。</p>\n<p>.NET に本当に必要なのは <a href=\"https://msdn.microsoft.com/en-us/library/mt162308.aspx\" target=\"_blank\">Roslyn アナライザー</a> の包括的なセットであり、leap year、time zone、夏時間、解析など、一般的な日付/時刻のバグをキャッチできます。 残念ながら、このようなアナライザーを自分で作成する時間が私にはない。 将来、ある時点でこの問題に取り込む可能性がありますが、現在は存在しません。</p>\n<p>また、C++、JavaScript、その他の言語用の同様のツールを用意するのも良い方法です。 しかし、私は何も知りません。</p>\n<h3>タイム ワープ</h3>\n<p>クロックを前方に移動して、何が起こるかを確認するだけの理由は何ですか? これは実際には一部のシステムで機能する場合がありますが、この考え方にはいくつかの問題があります。</p>\n<ul>\n<li>単体テストですべてが <em>キャッチされない</em> 場合があります。 アプリケーション全体の各画面とレポートを実際に (手動で) 見ない限り、データ フィルター 処理エラーはキャッチしない可能性があります。 これは間違いを起こしやすいものです。 \n<li>セキュリティの誤った感覚を開発し、すべてが問題ない可能性があります。 顧客が 2 月 29 日または 3 月 1 日に苦情を申し出た場合にのみ、自分がいかに間違っていたか認識できます。 \n<li>多くのシステムでは、ドメイン サーバーで認証するか、時間の影響を受け取る他の認証スキームを使用する必要があります。 <a href=\"https://en.wikipedia.org/wiki/Kerberos_(protocol\">Kerberos プロトコルには厳密</a>な時刻同期要件が設定されています。既定の許容時間は 5 分です。 また、SSL 証明書、コード署名証明書、その他のセキュリティ関連のものはクロックに依存し、実際の時刻についてうそをつもうとすると失敗します。 </li></ul>\n<p>そのため、一般に、このアプローチ <em>に対してお</em> 勧めします。 または、少なくとも、誤検知を作成したり、特定のコード パスのテストを妨げる可能性のある外部リソースへの依存関係を考慮してください。</p>\n<h1>クロックをモックする</h1>\n<p>日付によって動作が異なるコードをテストする方法 時計をモック!</p>\n<p>これは、多くの信頼性の高いシステムで見られる一般的なパターンです (\"仮想クロック\" などの他の名前で知られている場合があります)。 重要な点は、システム クロック (つまり、システム クロックが何時かを示すもの) を、無計画に使用しなけらないという点です。 アプリケーション ロジックは、現在の <code>DateTime.Now</code> <code>DateTime.UtcNow</code> <code>new Date()</code> <code>GetSystemTime</code> 日付と時刻を取得するために、言語内の または に対して直接呼び出しを行う必要はありません。</p>\n<p>代わりに、クロック <em>を (</em> DDD の意味で) サービスとして扱う必要があります。また、他のサービスと同様に、モックを <em>作成できる必要</em> があります。</p>\n<p>たとえば、.NET では、アプリケーション <code>DateTimeOffset.UtcNow</code> ロジックから (または同様の API) を直接呼び出す代わりに、次のようになります。</p>\n<ul>\n<li>を返す <code>IClock</code> メソッドを使用して <code>GetCurrentTime</code> インターフェイスを作成します <code>DateTimeOffset</code>。 \n<li>から を実装 <code>SystemClock</code> するクラスを作成します。ここで <code>IClock</code>、 は を呼び <code>GetCurrentTime</code> 出します <code>DateTimeOffset.UtcNow</code>。 \n<li>を実装 <code>FakeClock</code> するクラスを作成します <code>IClock</code>。 <code>GetCurrentTime</code> このクラスは、固定値をコンストラクター パラメーターとして受け取り、ここで単に固定値を返します。 \n<li>アプリケーション ロジックでは、 インターフェイスにのみ依存 <code>IClock</code> します。 通常、これはコンストラクター挿入です。 \n<li>テスト中 <code>FakeClock</code> に を使用し、実行時に を <code>SystemClock</code> 接続します。 </li></ul>\n<p>これは多くの作業のように聞こえるかもしれませんが、動きを確認すると、利点がある場所が表示されます。 これは、現在の日付と時刻が依存関係である場合に、すべてのコードが確実にテストされる唯一の方法です。</p>\n<p>パターンは多くの異なる言語で同じである必要があるという理由で、ここでは意図的にコードを提供しなかったのです。 また、<a href=\"https://nodatime.org\" target=\"_blank\">Noda Time</a><code>IClock</code> <code>SystemClock</code> には、メイン アセンブリと アセンブリに付属する、非常に便利な実装が<code>FakeClock</code>既に用意<code>NodaTime.Testing</code>されています。 このために Noda Time を使用する方が良いし、その他の多くの理由があります。</p>\n<p>JavaScript 開発者は、Sinon.JSや <a href=\"https://github.com/boblauer/MockDate\" target=\"_blank\">MockDate</a><a href=\"https://sinonjs.org/\" target=\"_blank\"> のような</a>ライブラリ、または moment.jsからの組み込みのモック <a href=\"https://momentjs.com/docs/#/customization/now/\" target=\"_blank\">サポートを検討する必要があります</a>。</p>\n<p>他の言語のライブラリも同様の機能を持つ場合があります。 自宅で成長した実装を試みる前に、必ずそれらを探してください。</p>\n<h1>まとめ</h1>\n<p>Leap 年はこちらです。 Y2K や <a href=\"https://en.wikipedia.org/wiki/Year_2038_problem\" target=\"_blank\">Y2038</a> ではなく、定期的に対応する必要があります。 過去 4 年間に書いたコードの量はどれくらいですか? すべて一気に取り上げらたでしょうか。 ここで、コードをテストしてスキャンします。 おそらく、影に残っていることに気付かなかったいくつかのことを見つけるでしょう。</p>\n<p>ご質問があるでしょうか。 ここにコメントを残してください。お答えします。</p>\n<p><em>このコンテンツの一部は、最初 <a href=\"https://codeofmatt.com/2016/01/01/happy-new-leap-year/\" target=\"_blank\">は codeofmatt.com</a> 発行され、アクセス許可を使用して再印刷されました。</em></p>"
