### YamlMime:Yaml
ms.openlocfilehash: 0c300b91d8f9b824b5fe9ee49948097e0da18735
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139903623"
Slug: case-study-adding-application-insights-to-a-website
Title: 'ケーススタディ: web サイトへの Application Insights の追加'
Summary: この投稿では、Application Insights にオンボードするときの一般的な手順について説明し、前に説明していないいくつかの手法について説明します。
Content: >-
  <p>私たちのチームは、web サイト GetGlimpse.com に Application Insights を追加することを支援しました。 "一目" はオープンソースプロジェクトであるため、このようにして行った決定の一部を共有していると考え &rsquo; ました。 この投稿では、Application Insights にオンボードするときの一般的な手順について説明し、前に説明していないいくつかの手法について説明します。</p>


  <p>開発者は、web サイトが信頼性が高く、ユーザー &rsquo; のニーズを満たしていることを確認する必要があります。 これらのユーザーは、次のリリースの準備として、より多くの情報に基づく決定を行うために、サイトに Application Insights を追加しました。</p>


  <p>GetGlimpse.com は ASP.NET MVC アプリケーションです。 サイト &rsquo; のソースコードは GitHub 上にあり、Azure Web アプリとしてデプロイされています。</p>


  <h1>Process</h1>


  <p>ここでは、Application Insights するために<a href="https://azure.microsoft.com/documentation/articles/app-insights-start-monitoring-app-health-usage/">web アプリをオンボードする標準の手順</a>を開始しました。 このサイトでは、さらにいくつかの手順を実行しました。</p>


  <ol>
   <li>Azure web アプリの設定からインストルメンテーションキーを読み取ります。</li>
   <li>JavaScript の読み込みを最適化します。</li>
   <li>不要なモジュールを削除します。</li>
   <li>ビルドバージョンでタグ付けされたテレメトリを取得します。</li>
   <li>例外の完全なレポートを追加します。</li>
  </ol>


  <p>これらの手順を実行すると、結果の概要と概要が表示されます。</p>


  <h1>Azure Web アプリの設定からインストルメンテーションキーを読み取る</h1>


  <p>Application Insights インストルメンテーションキーはテレメトリを適切なリソースに送信し、テレメトリを確認できるようにします。 通常は、ApplicationInsights.config ファイルに配置し、アプリケーションでそこから取得します。</p>


  <p>ただし、Azure Web アプリでは、代わりに Azure Web アプリ環境変数からインストルメンテーションキーを読み取ることができます。 これは、異なるデプロイのインストルメンテーションキーをオーバーライドできるようにしました。 string ikeyValue = GetEnvironmentVariable ( &quot; APPINSIGHTS_INSTRUMENTATIONKEY &quot; );<br />

  <br />

  (! string.IsNullOrEmpty (ikeyValue))<br />

  {<br />

  &nbsp;&nbsp; TelemetryConfiguration InstrumentationKey = ikeyValue;<br />

  }</p>


  <div align="left">&nbsp;</div>


  <div align="left">この作業を行うには、web アプリに<a href="https://azure.microsoft.com/documentation/articles/insights-perf-analytics/">Azure アプリケーションインサイト拡張機能を追加</a>するか、web サイトの設定でインストルメンテーションキーを手動で設定します。</div>


  <h1>JavaScript の読み込みの最適化</h1>


  <p><a href="https://azure.microsoft.com/documentation/articles/app-insights-javascript/">クライアント側のデータコレクション</a> では、ページに JavaScript コードを挿入する必要があります。 標準的なアドバイスは、次のようなマスターページにこのコードを含めることによって、サイト &ndash; のすべての web ページの先頭にこのコードを配置することです。</p>


  <pre class="prettyprint">

  Views/Shared/_Layout.cshtml.</pre>


  <p>しかし、このコードはかなり大きくなる可能性があります (ほぼ 1 KB)。 すべてのページに対してこれをダウンロードするオーバーヘッドを減らすために、別の JavaScript ファイルを作成しました。これにより、ブラウザーは複数のページにキャッシュをキャッシュできます。 これにより、ページの読み込み時間が改善されました。</p>


  <h3>Application Insights スニペットを格納する新しい JavaScript ファイルを作成する</h3>


  <p>この<a href="https://github.com/Glimpse/Glimpse.Site/blob/master/source/Glimpse.Site/Scripts/ApplicationInsightsSnippet.js">スクリプトファイル</a> &nbsp; には、web ページ &rdquo; ブレードを監視するための Application Insights クイックスタート/ &ldquo; 取得コードから取得したコードスニペットが含まれていますが、最後の近くに1つの変更があります。</p>


  <pre class="prettyprint">

  }({
      instrumentationKey: window.instrumentationKey
  });</pre>


  <p>インストルメンテーションキーをハードコーディングするのではなく、instrumentationKey に置き換えました。 これにより、キーを1つの場所のみにハードコーディングするという目標が保たれます。</p>


  <h3>サーバーからインストルメンテーションキーを設定する</h3>


  <p>ASP.NET web ページは実行時に生成されるため、インストルメンテーションキーはサーバー SDK から設定できます。 Razor 構文 ( &rsquo; 他のフレームワークに合わせて調整する必要があります) を使用して、 <a href="https://github.com/Glimpse/Glimpse.Site/blob/master/source/Glimpse.Site/Views/Shared/_Layout.cshtml">_Layout</a> (マスター) ページでキーを設定します。</p>


  <pre class="prettyprint">
   &lt;script language=&quot;javascript&quot;&gt;
          window.instrumentationKey = &quot;@Microsoft.ApplicationInsights.Extensibility.TelemetryConfiguration.Active.InstrumentationKey&quot;;
      &lt;/script&gt;
      @Scripts.Render(&quot;~/bundles/headsitejs&quot;)</pre>

  <p>スクリプトのレンダー線では、ASP.NET の<a href="https://go.microsoft.com/fwlink/?LinkId=301862">バンドル機能</a>を使用して、複数のスクリプトの読み込みを最適化します。</p>


  <h3>スクリプトファイルのバンドルを定義する</h3>


  <p>最後に、 <a href="https://github.com/Glimpse/Glimpse.Site/blob/master/source/Glimpse.Site/App_Start/BundleConfig.cs">該当/BundleConfig</a> に新しいスクリプトバンドルを追加して、コードファイルを読み込みます。</p>


  <pre class="prettyprint">
    bundles.Add(new ScriptBundle(&quot;~/bundles/headsitejs&quot;).Include(
                  &quot;~/Scripts/ApplicationInsightsSnippet.js&quot;));</pre>

  <h3>特長</h3>


  <p>目標は、インストルメンテーションキーを設定する場所を1か所にすることでした。 これにより、インストルメンテーションキーが簡単かつクリーンに更新されます。 ページのサイズを1K で小さくすることの利点は、ごくわずかに見えるかもしれませんが、大規模な web サイトの場合は、短時間で増加します。 Application Insights &rsquo; の JavaScript コードがキャッシュされていることと、縮小したページのサイズの組み合わせは、セットアップの価値があります。</p>


  <h1>不要なモジュールを削除する</h1>


  <p><a href="https://github.com/Glimpse/Glimpse.Site/blob/master/source/Glimpse.Site/ApplicationInsights.config">ApplicationInsights.config</a>には、このアプリに必要なテレメトリ初期化子 &rsquo; があります。 この初期化子は Azure cloud services で使用されますが、アプリは Azure Web アプリとしてデプロイされます。</p>


  <pre class="prettyprint">

  &lt;Add Type=&quot;Microsoft.ApplicationInsights.WindowsServer.AzureRoleEnvironmentTelemetryInitializer, Microsoft.AI.WindowsServer&quot; /&gt; </pre>


  <p>また、Azure Web Apps ではまだ動作しないパフォーマンスカウンターモジュール &rsquo; も削除しました。</p>


  <p>どちらの削除も、パフォーマンスの向上を目的としていました。</p>


  <h1>ビルドバージョンでタグ付けされたテレメトリを取得します</h1>


  <p>開発者は、多くの場合、更新プログラムをアプリにデプロイします。 例外や他のテレメトリを調査するときに、データの取得元となるバージョンを明確にすることはできないことがあり &rsquo; ます。 ただし Application Insights では、プロパティまたはフィルターをチェックできるように、すべてのテレメトリにビルドバージョンをプロパティとして簡単に追加できます。</p>


  <div><a href="https://apmtips.com/blog/2015/06/18/application-versioning-semantic-or-automatic/">buildinfo.configを生成</a>するために MSBuild を取得するだけで済みます。次のように、メインの .csproj ファイルを追加しました。<font face="Courier New">&nbsp;</font></div>


  <blockquote>

  <pre class="prettyprint">

  &lt;PropertyGroup&gt;
   &lt;GenerateBuildInfoConfigFile&gt;true&lt;/GenerateBuildInfoConfigFile&gt;
   &lt;IncludeServerNameInBuildInfo&gt;true&lt;/IncludeServerNameInBuildInfo&gt;
  &lt;/PropertyGroup&gt;</pre>

  </blockquote>


  <p>ビルド情報がある場合、Application Insights web モジュールによって、製品利用統計情報のすべての項目に対してビルドバージョンがプロパティとして自動的に追加されます。これにより、<a href="https://azure.microsoft.com/documentation/articles/app-insights-diagnostic-search/">診断検索</a>を実行するときや<a href="https://azure.microsoft.com/documentation/articles/app-insights-javascript/">メトリックを探索</a>するときにバージョンでフィルター処理できます。</p>


  <p>MSBuild を使用して web アプリをビルドする場合にのみ、正しいビルド番号が表示されることに注意してください。 Visual Studio &rsquo; s ローカルビルドプロセスでは、バージョンプロパティにプレースホルダーのみが配置されます。</p>


  <h1>完全な例外レポートの追加</h1>


  <p><a href="https://azure.microsoft.com/documentation/articles/app-insights-asp-net-exceptions/#web-api-1x">Application Insights によって例外が報告</a>されるようにするに &nbsp; は、web アプリでいくつかの追加のコードが必要です。 これらの手法は、アプリの種類によって異なります。 &rsquo;WEB API の場合は、4つのファイルをプロジェクトソリューションに<a href="https://github.com/Glimpse/Glimpse.Site/commit/a4d2fd0334328976d43f03f9a0c2d704d05955f8">追加または変更</a>する必要がありました。</p>


  <p><a href="https://github.com/Glimpse/Glimpse.Site/blob/a4d2fd0334328976d43f03f9a0c2d704d05955f8/source/Glimpse.Site/Telemetry/ApplicationInsightsErrorAttribute.cs">ApplicationInsightsErrorAttribute</a>で属性を定義しています。 これにより、適用先のクラスの例外が報告されます。</p>


  <pre class="prettyprint">

  using System;

  using System.Web.Mvc;

  using Microsoft.ApplicationInsights;

  using Microsoft.ApplicationInsights.DataContracts;


  namespace Glimpse.Site.Telemetry

  {
      [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, Inherited = true, AllowMultiple = true)]
      public class ApplicationInsightsErrorAttribute : <font style="background-color: #ffff00">HandleErrorAttribute</font>
      {
          private TelemetryClient client = new TelemetryClient();

          public override void OnException(ExceptionContext filterContext)
          {
              if (filterContext != null &amp;&amp; filterContext.HttpContext != null &amp;&amp; filterContext.Exception != null)
              {
                  //If customError is Off, then AI HTTPModule will report the exception
                  if (filterContext.HttpContext.IsCustomErrorEnabled)
                  {
                      ExceptionTelemetry exc = new ExceptionTelemetry(filterContext.Exception);
                      exc.HandledAt = ExceptionHandledAt.Platform;
                      client.TrackException(exc);
                  }
                  base.OnException(filterContext);
              }
          }
      }
  }</pre>


  <p><font style="background-color: #ffff00">注</font>: Glimpse.site には既にエラー処理があります。 エラー処理を使用するには、ドキュメントで推奨されているように、ExceptionFilterAttribute または ExceptionLogger ではなく HandleErrorAttribute を使用します。</p>


  <p><b><a href="https://github.com/Glimpse/Glimpse.Site/blob/a4d2fd0334328976d43f03f9a0c2d704d05955f8/source/Glimpse.Site/App_Start/FilterConfig.cs">filterconfig .cs</a></b>で、Application Insights のエラー属性フィルターを追加しました。 これにより、すべてのクラスに属性が効果的に適用されます。</p>


  <pre class="prettyprint">

  using System.Web.Mvc;

  using Glimpse.Site.Telemetry;


  namespace Glimpse.Site

  {
      public class FilterConfig
      {
          public static void RegisterGlobalFilters(GlobalFilterCollection filters)
          {
              filters.Add(new ApplicationInsightsErrorAttribute());
          }
      }
  }

  </pre>


  <p>次のように、新しい ApplicationInsightsErrorAttribute ファイルを追加し <b><a href="https://github.com/Glimpse/Glimpse.Site/blob/a4d2fd0334328976d43f03f9a0c2d704d05955f8/source/Glimpse.Site/Glimpse.Site.csproj">ます</a></b> 。</p>


  <pre class="prettyprint">

  &lt;Compile Include=&quot;Telemetry\ApplicationInsightsErrorAttribute.cs&quot; /&gt;</pre>


  <h1>結果</h1>


  <p>Application Insights は、参考サイトの開発者に有用なデータを提供しています。 全体像として、このサイトのサイトは正常に実行されており、ほとんどのお客様には優れたエクスペリエンスがあります。 開発者は、自分のサイトが安定していて、正常に動作しているという印象を持ちました。Application Insights もします。 ここで重要なのは、大規模なコミュニティでは、このようなサイトが絶えず進化していることです。そのため、外部サイトには、その他のサイトに存在しないページへのリンクがいくつかありました。</p>


  <p>このチームは、他のサイト上の古いリンクを認識していなかったため、リンクの破損によって発生したエラーの Application Insights 数を確認することに驚かれました。 これらのリンクが壊れていると、お客様の少ない割合で、エクスペリエンスの品質が低下します。 ほとんどのお客様は、このサイトですばらしい経験を持っています。 しかし、エクスペリエンスをさらに向上させるために、最も頻繁に発生した例外のトリアージを行いました。 検出された例外の例をいくつか次に示します。</p>


  <h3>ファイルが見つからない</h3>


  <p>FileNotFoundException がファイル &#39;D:\home\site\wwwroot\Views\Docs\Wiki\Content\Custom-Runtime-Policy.md を見つけることができませんでした&#39;</p>


  <p>この例外は恐ろしいように見えるかもしれませんが、詳細な分析では、リンクが壊れていることがわかりました。 ファイル名が変更されましたが、他のユーザーが古いドキュメントページにアクセスしようとしました。</p>


  <h3>キーが見つかりません例外</h3>


  <p>KeyNotFoundException (システムコレクション)</p>


  <p>この例外を調査した後、ユーザーが自分のバージョンをアップグレードすると、この例外が発生する可能性があります。 PowerShell スクリプトを使用してアップグレードする場合、NuGet パッケージは、ユーザーの処理の対象となるバージョンが混乱する可能性があります。 このため、NuGet パッケージは、サーバーによって予期されていないため無効なクエリ文字列を作成します。</p>


  <h3>Window. onerror</h3>


  <p>エラー: オブジェクトはこのプロパティまたはメソッドをサポートしていません&#39;</p>


  <p>このエラーを調査した後に、この問題が発生したことがわかりました。これは、Windows Media Center には window. onerror がサポートされていないバージョンがあるためです。 このエラーは一般的ではありません。</p>


  <h3>CORS スクリプトエラー</h3>


  <p>ブラウザー &rsquo; の同じオリジンポリシーによって、この例外の詳細を取得できなくなります。Web ページとは異なる配信元から読み込まれたスクリプトで例外が発生しました。 ドメイン間エラー報告の場合、クロスオリジン属性を適切な CORS HTTP ヘッダーと共に使用できます。 詳細については、「」を参照 <a href="https://www.w3.org/TR/cors/">https://www.w3.org/TR/cors/</a> してください。</p>


  <p>場合によっては、JavaScript エラーが発生し、セキュリティポリシーによってエラーがあまり有益ではないことがあります。 この問題は、例外の原因となったスクリプトが、ユーザーが例外を発生させたドメインとは異なるドメインでホストされていることが原因で発生します。 セキュリティの制限により、Application Insights ではこの種類のエラーに関する追加情報は表示されません。 ただし、この例外はめったに発生せず、1つのスクリプトでは優先度が低くなりました。</p>


  <p>Application Insights をこのサイトに追加すると、テレメトリを使用して開発者がいます。 サイトの使いやすさとパフォーマンスを向上させるために、このデータの使用を計画しています。 全体として、ユーザーの大半がサイトを完璧に体験していることがわかりました。 この分析に役立った <a href="https://github.com/nikmd23">Molnar</a> と <a href="https://github.com/avanderhoorn">Anthony van der Hoorn</a> に感謝します</p>


  <h1>まとめ</h1>


  <p>便利なテレメトリを使って、オンボードを Application Insights しています。 このプロセス中に使用した手法の一部は推奨されており、より充実した Application Insights エクスペリエンスに寄与する可能性があります。</p>
