### YamlMime:Yaml
ms.openlocfilehash: 9dab08317836122235970e1a3b523c554bfe7405
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139894181"
Slug: adal-net-3-17-0-released-2
Title: ADAL.NET 3.17.0 リリース
Summary: ADAL.NET () は、開発者が Azure AD および ADFS からトークンを取得して、Azure Active Directory に登録されている Microsoft api またはアプリケーションにアクセスするために使用できる認証ライブラリです。 ADAL.NET は、いくつかの .net プラットフォーム (デスクトップ、ユニバーサル Windows プラットフォーム、xamarin/Android、xamarin iOS、ポータブルクラスライブラリ、.net Core) で利用できます。
Content: "<p>ADAL.NET () は、開発者が Azure AD および ADFS からトークンを取得して、Azure Active Directory に登録されている Microsoft api またはアプリケーションにアクセスできるようにする認証ライブラリ<a href=\"https://www.nuget.org/packages/Microsoft.IdentityModel.Clients.ActiveDirectory/\">です。</a> ADAL.NET は、デスクトップ、ユニバーサル Windows プラットフォーム、xamarin/Android、xamarin iOS、ポータブルクラスライブラリ、.net Core など、いくつかの .net プラットフォームで利用できます。 ADAL.NET 3.17.0 をリリースするだけで、新しい機能が有効になり、ユーザビリティ、プライバシー、およびパフォーマンスの面で改善されました。</p>\n\n<h2>新機能の有効化</h2>\n\n<p>ADAL.Net 3.17.0 を使用すると、次のことができます。</p>\n\n<ul>\n    <li>より効率的なアプリケーションを作成し、Azure AD の調整に耐性ます。</li>\n    <li>アプリのエンドユーザーが、ログインしているときでも id を選択するように強制します。</li>\n    <li>より効果的な条件付きアクセスを処理します。</li>\n</ul>\n\n<h3>より効率的なアプリケーションの有効化 (たとえば、再試行)</h3>\n\n<p><em>AdalException</em>を ErrorCode <em> &quot; temporarily_unavailable &quot; </em>で処理、取得、キャッチするサンプルをいくつか見てきたかもしれません。 要求 &rdquo; の &ldquo; 数が多すぎるためにサービストークンサーバー (STS) がビジー状態になると、HTTP エラー429が返されます。これは、再試行のタイミング (応答フィールド) を、秒単位の遅延として、または日付を指定して再試行できます。</p>\n\n<p>以前は、ADAL.NET はこの情報を公開していませんでした。 そのため、エラーを処理するには、ハードコーディングされた任意の遅延を待機した後、任意の回数再試行することをお勧めします。 コンソールアプリケーションの場合、コードは次のようになります。</p>\n\n<pre class=\"prettyprint\">\ndo\n{\n    retry = false;\n    try\n    {\n        result = await authContext.AcquireTokenAsync(resource, certCred);\n    }\n    catch (AdalException ex)\n    {\n        if (ex.ErrorCode == &quot;temporarily_unavailable&quot;)\n        {\n            retry = true;\n            retryCount++;\n            Thread.Sleep(3000);\n        }\n      &hellip;\n    }\n     &hellip;\n} while ((retry == true) &amp;&amp; (retryCount &lt; 2)); \n</pre>\n\n<p>ADAL.NET 3.17.0 から、現在、システム .Net. ヘッダーを提示して<em>います。HttpResponseH</em>eaders を、 <em>microsoft.identitymodel.clients.activedirectory.adalserviceexception</em>内のヘッダーという名前の新しいプロパティとして指定します。 そのため、アプリケーションの信頼性を向上させるために、追加情報を活用できます。 ここで説明したように、RetryAfter プロパティ ( <em>Retryconditionheadervalue</em>型) を使用して、再試行のタイミングを計算できます。</p>\n\n<p>機密クライアント<a href=\"https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-authentication-scenarios#application-types-and-scenarios\">アプリケーション</a>またはパブリッククライアントアプリケーションに ADAL.Net を使用しているかどうかによって、 <em>microsoft.identitymodel.clients.activedirectory.adalserviceexception</em>を直接、または AdalException の InnerException としてキャッチする必要が<strong>あることに注意</strong>して<em>ください。</em></p>\n\n<p>次のコードスニペットは、ケースに応じて続行する方法を示しています。</p>\n\n<pre class=\"prettyprint\">\ndo\n{\n    retry = false;\n    TimeSpan ?delay;\n    try\n    {\n        result = await authContext.AcquireTokenAsync(resource, certCred);\n    }\n\n    // Case of a Confidential client flow \n    // (for instance auth code redemption in a Web App)\n    catch (AdalServiceException serviceException)\n    {\n     if (ex.ErrorCode == &quot;temporarily_unavailable&quot;)\n        {\n        RetryConditionHeaderValue retry= serviceException.Headers.RetryAfter;\n        if (retry.Delta.HasValue)\n              {\n            delay = retry.Delta;\n              }\n        else if (retry.Date.HasValue)\n              {\n            delay = retry.Date.Value.Offset;\n              }\n        }\n\n    }\n    \n    // Case of a client side exception\n    catch (AdalException ex)\n    {\n        if (ex.ErrorCode == &quot;temporarily_unavailable&quot;)\n        {\n     var serviceEx = ex.InnerException as AdalServiceException;\n    // Same kind of processing as above\n        }\n    &hellip;\n    }\n    &hellip;\n   if (delay.HasValue)\n   {\n    Thread.Sleep((int)delay.Value.TotalSeconds); // sleep or other\nretry = true;\n   }\n\n} while (retry); \n</pre>\n\n<h3>ユーザーにアカウントの選択を強制する</h3>\n\n<p>複数の個人、プロフェッショナル、および組織の id が使用されています。 アプリケーションで、使用する id を選択するユースケースがある場合があります。 このようなユースケースを有効にするために、対話 (デスクトップ、WinRT、Xamarin iOS、Xamarin Android) をサポートするプラットフォームの<em>Promptbehavior</em>列挙に新しい値<em>selectaccount</em>を追加しました。 このオプションを使用する場合、s/he が既にログインしていて、キャッシュ参照をバイパスして、UI を直接表示しているときでも、アプリ &rsquo; のユーザーにアカウントの選択を強制します。</p>\n\n<p><em>Promptbehavior</em>を使用している可能性があります。<em>常</em>に過去で、トークンキャッシュをバイパスし、ユーザーインターフェイスを提示します。 <em>Promptbehavior</em>。<em>selectaccount</em>は、使用可能なユーザーをタイルとして表示するように Azure AD に指示しますが、ユーザーが再度サインインすることはありません (cookie が使用可能であることを前提として、ユーザーと Azure AD 間の対話はブラウザーで発生します)。 タイルが存在しても、その動作は、ライブラリ &rsquo; s 管理範囲の外部で完全に管理されている cookie の有効期間によって決まるため、シングルサインオンが保証されるわけではありません。</p>\n\n<h3>アプリケーションが条件付きアクセス (およびその他の要求の課題) を処理できるようにする</h3>\n\n<p>ほとんどの <a href=\"https://github.com/Azure-Samples?utf8=%E2%9C%93&amp;q=azure-active-directory\">サンプル</a> を単純なままにしておきますが、エンタープライズ対応のアプリケーションを作成する場合は、エラー処理に多少の労力をかける必要があることがわかっているでしょう。 その結果、ADAL.NET 3.16.0 では、アプリケーションが追加のリソースにアクセスしたり、多要素認証を実行したりすることをユーザーに許可する必要がある場合に、Azure AD によって送信される要求の課題を処理できます。 ADAL.NET 3.17.0 では、この機能を有効にしました。これにより、 <em>AdalClaimChallengeException</em>の内部例外として<em>HttpRequestWrapperException</em>を API 呼び出し元に渡して、不足している要求を取得できるようにします。 その後、これらの追加の要求を、新しい要求メンバーを持つ acquireToken オーバーライドに渡すことができます。</p>\n\n<p>次のコードスニペットは、dotnet- <a href=\"https://github.com/Azure-Samples/active-directory-dotnet-webapi-onbehalfof-ca/blob/master/TodoListService/Controllers/AccessCaApiController.cs#L88-L98\">webapi</a> サンプルから抽出されています。 これは、TodoList サービス (confidential クライアント) によって Azure AD から受信した要求チャレンジと、そのチャレンジをクライアントに伝達する方法を示しています。これにより、ユーザーが必要なユーザー操作 (2 要素認証など) を行うことができます。</p>\n\n<pre class=\"prettyprint\">\ntry\n{\n    result = await authContext.AcquireTokenAsync(caResourceId, clientCred,\n                                                 userAssertion);\n}\ncatch (AdalClaimChallengeException ex)\n{\n    HttpResponseMessage myMessage = new HttpResponseMessage \n    { StatusCode = HttpStatusCode.Forbidden, ReasonPhrase = INTERACTION_REQUIRED,\n      Content = new StringContent(ex.Claims) };\n    throw new HttpResponseException(myMessage);\n}\ncatch (AdalServiceException ex)\n{\n  &hellip;\n</pre>\n\n<p>クライアント側 (TodoListClient) では、TodoList サービスを呼び出し、より多くの要求でトークンを再要求するときに、この問題が発生します。次に例を示します。</p>\n\n<pre class=\"prettyprint\">\n// We successfully got a token.\nhttpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(&quot;Bearer&quot;, result.AccessToken);\n\n// while calling the API.\nHttpResponseMessage response = await httpClient.GetAsync(todoListBaseAddress \n                                                         + &quot;/api/AccessCaApi&quot;);\n\nif (response.StatusCode == System.Net.HttpStatusCode.Forbidden \n    &amp;&amp; response.ReasonPhrase == INTERACTION_REQUIRED)\n {\n     // We need to re-request the token to account for a Conditional Access Policy\n     String claimsParam = await response.Content.ReadAsStringAsync();\n\n    try\n    {\n     result = await authContext.AcquireTokenAsync(todoListResourceId, clientId,\n                     redirectUri, new PlatformParameters(PromptBehavior.Always), \n                     new UserIdentifier(displayName,\n                                        UserIdentifierType.OptionalDisplayableId),\n                     extraQueryParameters:null, \n                     claims: claimsParam);\n     &hellip;\n</pre>\n\n<p>詳細については、<a href=\"https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-conditional-access-developer\">開発者ガイドの「条件付きアクセスの Azure Active Directory</a> 」およびこの記事からリンクされているサンプルを参照してください。</p>\n\n<h2>操作性の向上</h2>\n\n<h3>ADAL.NET NuGet パッケージに、プラットフォームごとに1つの DLL が含まれるようになりました</h3>\n\n<p>ADAL.NET は、依存関係の挿入を使用して別のプラットフォーム固有のアセンブリを動的に読み込む1つの共通アセンブリとしてパッケージ化するために使用されます。 これが問題の原因となっています (#511)。 ポータブルライブラリから NuGet パッケージを参照していた場合は、メインアセンブリからプラットフォーム固有のアセンブリを参照する必要がありました。これはあまり直感的ではありませんでした。</p>\n\n<p>ADAL.NET 3.17.0 以降、NuGet パッケージには、プラットフォームごとに1つの DLL が含まれるようになりました。</p>\n\n<p>実装の詳細に関心がある場合は、GitHub &rsquo; にある ADAL.NET &rsquo; s ソースコードを参照してください。 ADAL.NET の<a href=\"https://github.com/AzureAD/azure-activedirectory-library-for-dotnet/blob/dev/src/Microsoft.IdentityModel.Clients.ActiveDirectory/Microsoft.IdentityModel.Clients.ActiveDirectory.csproj#L11\">マルチターゲットプロジェクト</a>に移動したこと &rsquo; がわかります。</p>\n\n<h3>一部のプラットフォームでは意味のない Api を非表示にして混乱を解消する</h3>\n\n<p><strong>WinRT アプリは、1つの ClientCredential コンストラクターのみを使用できるようになりました</strong></p>\n\n<p>WinRT アプリケーションが一般にパブリッククライアントアプリケーションであっても、クライアント資格情報フローを使用して、ユーザーがログインしていないキオスクモードのシナリオを有効にすることもできます。 ここまでは、confidential クライアントシナリオで使用される <em>Clientcredential</em> クラスに2つの上書きがありました。</p>\n\n<ul>\n    <li>1つはアプリケーションシークレット、 <em>パブリック ClientCredential (文字列 clientId、文字列 Clientcredential) を使用します。</em></li>\n    <li><em>Authorizationcode</em>を引き換えするか、ユーザーアサーションを渡すものです。</li>\n</ul>\n\n<p>は、WinRT アプリケーションでは意味がありませんでした。 &rsquo;デスクトップアプリケーションでのみ使用できるようになりました。</p>\n\n<p><strong>デバイスプロファイル API は、デスクトップ、.NET core、UWP アプリでのみ使用できるようになりました</strong></p>\n\n<p>デバイスプロファイル API <em>AcquireTokenByDeviceCodeAsync (DeviceCodeResult DeviceCodeResult)</em>は、 <em>AcquireDeviceCodeAsync</em>のいずれかのオーバーライドを使用して以前に要求されたデバイスコードを使用して STS からセキュリティトークンを取得します (「 <a href=\"https://azure.microsoft.com/en-us/resources/samples/active-directory-dotnet-deviceprofile\">Azure AD によって保護された API の呼び出し</a>」を参照してください)。 <em>AcquireTokenByDeviceCodeAsync</em> は、テキストのみのデバイスではない xamarin IOS および xamarin Android では使用できなくなりました。 これは、デスクトップ、.Net Core および UWP (IoT) アプリでのみ使用する必要があります。 これにより、Android と iOS では <em>AcquireDeviceCodeAsync</em> が既に利用できないため、一貫性が向上します。</p>\n\n<h3>改善されたドキュメント</h3>\n\n<p>UserPasswordCredential と AcquireToken (654 を参照<a href=\"https://github.com/AzureAD/azure-activedirectory-library-for-dotnet/issues/654\"> # </a>) では、参照ドキュメントのいくつかの問題を修正しました。 また、 <em>IAdalLogCallback</em>インターフェイスを実装してログを有効にする方法と、外部ブローカー (xamarin IOS/xamarin Android の場合) と対話する方法について、ライブラリ &rsquo; s readme.md も更新しました。</p>\n\n<h2>プライバシーとパフォーマンスの向上</h2>\n\n<p>ご存じのように、 <em>LoggerCallbackHandler</em>に割り当てて、ADAL.NET logger でのログ記録を有効にすることができます。 Callback は、 <em>IAdalLogCallback </em>インターフェイスを実装するクラスのインスタンスです。 これを行って、詳細情報を表示するように選択した場合、ADAL.Net が Azure AD に要求を送信したときに、2つのメッセージが表示されることがあります。</p>\n\n<ul>\n    <li><em>&ldquo;完全な URL への &lsquo; 移動&rsquo;&rdquo;</em></li>\n    <li><em>&ldquo;完全な URL に移動し &lsquo; ました&rsquo;&rdquo;</em></li>\n</ul>\n\n<p><em> &lsquo; 完全な url &rsquo; </em>は Azure AD に送信される完全な url でした。 プロンプトの動作を含む、ユーザーのユーザープリンシパル名 (UPN) などの個人情報。</p>\n\n<p>完全な URL をログに記録しなくなったため、プライバシーが向上しました。</p>\n\n<p>また、Xamarin iOS プラットフォーム固有のメモリリークを修正することで、パフォーマンスを向上させました。</p>\n\n<h2>最後に</h2>\n\n<p>いつものように、お客様からのフィードバックをお待ちしており &rsquo; ます。 どうぞ：</p>\n\n<ul>\n    <li>ADAL タグを使用して<a href=\"https://stackoverflow.com/questions/tagged/adal\">Stack Overflow</a>に &nbsp; 関する質問をしてください。</li>\n    <li>ADAL.Net オープンソースリポジトリに<a href=\"https://github.com/AzureAD/azure-activedirectory-library-for-dotnet/issues\">関する問題を GitHub</a>使用して、バグまたは要求機能を報告する</li>\n    <li>ユーザーの <a href=\"https://feedback.azure.com/forums/169401-azure-active-directory\">声ページ</a> を使用して、推奨事項やフィードバックを提供する</li>\n</ul>"
