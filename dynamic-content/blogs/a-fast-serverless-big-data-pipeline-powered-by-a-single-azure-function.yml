### YamlMime:Yaml
ms.openlocfilehash: 6ff945d019a69438e9aad4b36dc649e30e4c342e
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139893325"
Slug: a-fast-serverless-big-data-pipeline-powered-by-a-single-azure-function
Title: 単一の Azure 関数を利用する高速でサーバーレスのビッグデータパイプライン
Summary: 1つの Azure 関数は、エンドツーエンドのリアルタイムのミッションクリティカルなデータパイプラインを完全に実装するために必要でした。 これは、サーバーレスアーキテクチャを使用して行われました。 サーバーレスアーキテクチャは、クラウド規模のアプリケーションの構築、デプロイ、および管理を簡略化します。
Content: >-
  <p>1つの Azure 関数は、エンドツーエンドのリアルタイムのミッションクリティカルなデータパイプラインを完全に実装するために必要でした。 これは、 <a href="https://azure.microsoft.com/en-us/overview/serverless-computing/?WT.mc_id=ms-docs-kbaroni" target="_blank">サーバーレス</a> アーキテクチャを使用して行われました。 サーバーレスアーキテクチャは、クラウド規模のアプリケーションの構築、デプロイ、および管理を簡略化します。 データエンジニアは、サーバーの調達、構成、管理などのデータインフラストラクチャを気にするのではなく、エンドツーエンドで非常に機能の高いデータパイプラインを確保するために必要なタスクに集中できます。</p>


  <p>このブログでは、Azure functions について説明します。また、1日に800万トランザクションを処理したデータインジェストパイプラインを効率的に調整する方法についても説明します。</p>


  <h2>シナリオ</h2>


  <p>大きな銀行では、携帯電話の銀行のアプリケーションを通じて送信された不正なトランザクションを検出するソリューションを構築したいと考えていました。 このソリューションには、ビッグデータパイプラインアプローチが必要です。 大量のリアルタイムデータは、一連のデータ変換と抽出アクティビティが発生するクラウドサービスに取り込まれたされます。 その結果、 <a href="https://docs.microsoft.com/en-us/azure/machine-learning/team-data-science-process/create-features/?WT.mc_id=ms-docs-kbaroni" target="_blank">機能</a> データセットが作成され、高度な分析が使用されます。 銀行では、パイプラインは非常に高速でスケーラブルで、各トランザクションのエンドツーエンドの評価は2秒以内に完了する必要がありました。</p>


  <p>銀行 &rsquo; の複数のアプリケーションゲートウェイからのテレメトリ。複雑な JSON ファイルに埋め込まれたイベントとしてストリーミングされます。 インジェストテクノロジは Azure Event Hubs です。 各イベントは、イベントハブに取り込まれたし、複数の個別のトランザクションに解析されます。 属性は各トランザクションから抽出され、不正行為を評価します。 サーバーレスアーキテクチャは、次の Azure サービスから構築されます。</p>


  <ul>
   <li><a href="https://azure.microsoft.com/en-us/services/event-hubs/?WT.mc_id=ms-docs-kbaroni" target="_blank">Azure Event Hubs</a></li>
   <li><a href="https://azure.microsoft.com/en-us/services/functions/?WT.mc_id=ms-docs-kbaroni" target="_blank">Azure Functions</a></li>
   <li><a href="https://studio.azureml.net/?WT.mc_id=ms-docs-kbaroni" target="_blank">Azure Machine Learning Studio</a></li>
   <li><a href="https://azure.microsoft.com/en-us/services/sql-database/?WT.mc_id=ms-docs-kbaroni" target="_blank">Azure SQL Database</a></li>
   <li><a href="https://azure.microsoft.com/en-us/services/cosmos-db/?WT.mc_id=ms-docs-kbaroni" target="_blank">CosmosDB</a></li>
  </ul>


  <h2>パイプラインのアーキテクチャ</h2>


  <p>アクティビティのパイプライン全体を調整および管理するために1つの Azure 関数が使用されました。 次の図は、Azure Functions パイプラインアーキテクチャを示しています。</p>


  <ul>
   <li>エンタープライズシステムバスは、イベントハブに到着した JSON ファイルに銀行トランザクションを送信します。 到着すると、取り込まれたファイルの検証と解析の応答がトリガーされます。</li>
   <li>SQL ストアドプロシージャが呼び出されます。 このプロシージャは、JSON メッセージからデータ要素を抽出し、それを顧客とアカウントのプロファイルで集計して、機能セットを生成します。これは、機械学習モデルの入力です。 集計メッセージは JSON ファイルとして書式設定されます。</li>
   <li>検証済みの JSON メッセージは Cosmos DB に書き込まれます。</li>
   <li>機械学習モデルを呼び出して、トランザクションを評価し、スコア付けします。</li>
   <li>ケース管理ソリューションと統合するために、不正行為のスコアがオンプレミスの API にポストバックされます。</li>
  </ul>


  <p>&nbsp;<a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/416c10f2-3876-48da-bba3-f3f6d993a334.png"><img alt="image" border="0" height="226" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/78320868-0fa7-4f1c-b0eb-3d3a68ef52bc.png" style="border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="絵" width="377"></a></p>


  <p align="center"><em>図 1: Azure 関数パイプラインのアーキテクチャ</em>&nbsp;</p>


  <h2>10ステップのパイプライン</h2>


  <p>Azure 関数は C# で記述されており、次の図に示すように、10個のメソッドで構成されています。 &nbsp; 次のようなメソッドがあります。</p>


  <p>1. イベントハブによってイベントが受信されると、メソッドがトリガーされます。</p>


  <pre>

  public static void Run(string myEventHubMessage, ICollector&lt;string&gt; resultsCollection, TraceWriter log)</pre>


  <p>2. メッセージが処理され、JSON が検証されます。</p>


  <pre>

  private static void ProcessInitialMessageFromEventHub(List&lt;string&gt; jsonResults, string cnnString, TelemetryClient appInsights, dynamic d)</pre>


  <p>3.コードを呼び出して、メッセージイベントを挿入 &nbsp; する SQL コマンドを実行します。</p>


  <pre>

  private static bool CheckRequestTypeForValidMessage(dynamic d)</pre>


  <p>4.JSON メッセージが有効な場合は、後でクエリを実行するために Cosmos DB に保存します。</p>


  <pre>

  private static void SaveDocDb(string json, TraceWriter log)</pre>


  <p>5. JSON を解析したら、関連する属性を抽出します。</p>


  <pre>

  private static string ProcessSQLReturnedFeaturesForAML(TraceWriter log, List&lt;string&gt;, jsonResults, TelemetryClient appInsights)</pre>


  <p>6. ストアドプロシージャを実行して、機械学習モデルへの入力となる特徴を作成します。</p>


  <pre>

  private static string SendDataToStoredProc(dynamic d, SqlCommand spCommand, dynamic t, TelemetryClient appInsights, TransactionType transactionTypeEnum = TransactionType.Other, dynamic responseData = null)</pre>


  <p>7.Azure ML services エンドポイントへの呼び出しを呼び出します。 Azure ML からスコアを取得します。 入力パラメーターを渡します。</p>


  <pre>

  private static string CallAzureMl(dynamic d, TraceWriter log, HttpClient client)</pre>


  <p>8.ML サービスは、スコアを返してから処理されます。</p>


  <pre>

  public static List&lt;string&gt; GetScoresFromAzureMl(string myEventHubMessage, TraceWriter log, TelemetryClient appInsights, HttpClient client)</pre>


  <p>9. メッセージを引数として渡すことで、オンプレミスシステムへの呼び出しを行います。</p>


  <pre>

  public static List&lt;string&gt; ProcessMessagesIntoEsb(TraceWriter log, string cnnString, TelemetryClient appInsights, string cardNumber, string accountNumber, List&lt;string&gt;esbReturnMessages)</pre>


  <p>10. スコアはしきい値に対して評価され、オンプレミスのケース管理システムに渡す必要があるかどうかが決まります。</p>


  <pre>

  public static string CheckScoreAndProcessEsbMessages(string&gt; myEventHubMessage, TraceWriter log, SqlCommand spCommand, TelemetryClient appInsights, string cardNumber, string accountNumber)</pre>


  <p>次の図は &nbsp; 、コード内のタスクごとに1つずつ、10個のブロックの垂直方向のセットとしてのロジックを示しています。</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2bbd46f9-71cb-4671-a788-3ea5bbda15ae.png"><img alt="image" border="0" height="367" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/03699ea0-5c37-41df-8044-277cf135ed41.png" style="border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="絵" width="322"></a></p>


  <p align="center"><em>図 2: Azure の関数パイプラインフロー</em>&nbsp;</p>


  <p>&nbsp;</p>


  <h2>パイプラインのスケーラビリティ</h2>


  <p>パイプラインは、大量の受信 JSON ファイルへの応答性を備えている必要があります。 各ファイルを個別のトランザクションに解析し、各トランザクションを処理して不正アクセスを処理し、評価する必要があります。 さまざまな構成パラメーターを試した後、必要に応じて Azure 関数を拡張し、必要な時間制約内のメッセージとトランザクションの量を処理できるようにするために役立ついくつかの設定がありました。&nbsp;</p>


  <ul>
   <li><a href="https://docs.microsoft.com/en-us/azure/monitoring-and-diagnostics/monitoring-autoscale-get-started?toc=%2fazure%2fapp-service%2ftoc.json/?WT.mc_id=ms-docs-kbaroni" target="_blank">Azure 自動スケール</a> は、Azure Functions などのクラウドサービスに組み込まれている機能です。 ルールベースであり、定義されたしきい値に基づいて、Azure Functions のようなサービスをスケールアップまたはスケールダウンする機能を提供します。 既定では Event Hubs にデータが取り込まれたされるため、Azure Functions サービスのスケールが非常に速くなり、作成されたインスタンスが多すぎます。 これにより、イベントハブパーティションでのロックの問題が発生し、スループットに大きな影響が生じます。 自動スケール機能を使用した実験の後、Functions サービスの設定は、少なくとも最大4つのインスタンスに設定されていました。</li>
   <li>Azure 関数のパフォーマンスとスループットを確保するために、2つの Event Hubs 設定が重要でした。<br>
   <strong>Maxbatchsize</strong>: ユーザーが受信ループごとに処理するために許容される最大イベント数を取得または設定します。 この数は、イベントハブのパーティションレベルで発生します。<br>
   <strong>Prefetchcount</strong>: 現在所有されているパーティション内のすべての受信者がアクティブにキャッシュするイベントの数を取得します。値の設定もできます。 このプロパティの既定値は300です。</li>
  </ul>


  <p>さまざまな設定を試してみると、このソリューションの最適な構成は次のようになります。</p>


  <pre>

  // Configuration settings for &#39;eventHub&#39; triggers. (Optional)
     &quot;eventHub&quot;: {
      // The maximum event count received per receive loop. The default is 64.
      &quot;maxBatchSize&quot;: 10,
      // The default PrefetchCount that will be used by the underlying EventProcessorHost.
      &quot;prefetchCount&quot;: 40,
      // The number of event batches to process before creating an EventHub cursor   checkpoint.
      &quot;batchCheckpointFrequency&quot;: 1
     },</pre>

  <h2>推奨される次の手順</h2>


  <p>サーバーレスアーキテクチャを使用すると、Data Engineering チームはデータフロー、アプリケーションロジック、およびサービス統合に専念できます。 &nbsp; リアルタイムのサーバーレスデータパイプラインを設計しており、他のサービスとの統合または継続的インテグレーションによってデプロイするために独自のメソッドをコーディングする柔軟性が必要な場合は、Azure Functions を使用してパイプラインを調整および管理することを検討してください。 Azure functions の詳細については、次のリソースを参照してください。</p>


  <ul>
   <li><a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-best-practices/?WT.mc_id=ms-docs-kbaroni" target="_blank">Azure functions のパフォーマンスと信頼性を最適化</a>します。</li>
   <li><a href="https://docs.microsoft.com/en-us/azure/monitoring-and-diagnostics/monitoring-autoscale-get-started?toc=%2fazure%2fapp-service%2ftoc.json/?WT.mc_id=ms-docs-kbaroni" target="_blank">Azure での自動スケールの使用を開始</a>します。</li>
   <li>このブログで言及されている銀行詐欺ソリューションの完全なアーキテクチャについては、「 <a href="https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fdownload.microsoft.com%2Fdownload%2F0%2F1%2F5%2F0150425C-14C7-41F4-97EA-3DE57B678C51%2FIndSG_FraudDetection.pdf&amp;data=02%7C01%7C%7Cdb1f75f50e814905327b08d60c53078e%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C636709948072813252&amp;sdata=sVMHwEWyZ%2FkpPWgNkfgmXk5TfB0tzOvkMabszoZVuH8%3D&amp;reserved=0" target="_blank">モバイルバンクの不正行為ソリューションガイド」</a>を参照してください。</li>
  </ul>


  <p>このブログでの共同作業のために、 <a href="https://www.linkedin.com/in/cedza/" target="_blank">Cedric Labuschagne</a>、 <a href="https://www.linkedin.com/in/chris-cook-49b88457/" target="_blank">Chris クック</a>、 <a href="https://www.linkedin.com/in/eujon-sellers/" target="_blank">Eujon</a> 販売者に感謝します。</p>
