### YamlMime:Yaml
ms.openlocfilehash: 5ca4574cc8ed102f80ce14dc98640e779471be22
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139896117"
Slug: better-support-for-paging-with-table-storage-in-azure-mobile-services-net-backend
Title: Azure Mobile Services .net バックエンドでの Table Storage によるページングのサポートの強化
Summary: Azure Mobile Services の .net バックエンドの新しいリリースでは Azure Storage テーブルを使用するときのエクスペリエンスが向上しました。継続リンクが公開され、大きなテーブルによるページングに使用できるようになりました。
Content: "azure Mobile Services 用の .net バックエンドをリリースしたときに、azure Table Storage と MongoDB データベース (最初のバージョンのサービス以降に使用されていた SQL Azure ストレージに加えて) にデータを格納するためのサポートが提供されました。 ただし、テーブルストレージのサポートは非常に優れていませんでした。テーブルに多数の項目が含まれている場合、テーブルストレージでは SQL クエリのような \"スキップ\" 項目がサポートされていないため、アプリケーションはページングを使用してテーブル内のすべての項目を移動できませんでした。 Table storage では、skip/take を使用する代わりに、(HTTP リンクヘッダーとして公開される) <em>継続リンク</em> によるページングがサポートされています。これには、すべての項目を含まない要求の応答に、クライアントが追加の項目を取得するために使用するリンクがあります。 ただし、これらの継続リンクはクライアントで公開されていないため、大きなテーブルを使用することはできませんでした。\n\n最新リリースの .NET バックエンドパッケージ (<a href=\"https://www.nuget.org/packages/WindowsAzure.MobileServices.Backend.Storage/1.0.405\">バージョン 1.0.405</a>) と、クライアント SDK に対するいくつかの更新 (現時点では<a href=\"https://www.nuget.org/packages/WindowsAzure.MobileServices/1.2.5\">managed version 1.2.5</a> が近日公開予定) によって、クライアントの継続リンクを取得して従うことができるようになりました。これにより、テーブルストレージを使用するデータに対して適切なページングを行うことができます。 これを実行する方法の例を見てみましょう。\n<h2>データの取得とページング</h2>\nサーバー側ではコードを変更する必要はありません。 <a href=\"https://www.nuget.org/packages/WindowsAzure.MobileServices.Backend.Storage/1.0.405\">Azure Mobile Services .net バックエンドで Azure Storage 拡張機能</a>の NuGet パッケージを更新すると、返された項目よりも多くの項目が要求に含まれている場合は、継続リンクを取得する必要があります。 まだサービスがセットアップされていない場合は、この投稿の後の方でボーナス資料を確認することができます。 サービスのセットアップが終了したので、クライアントコードから始めることができます。 既に説明したように、完全なサポートはマネージ SDK でのみ使用できます。これを見てみましょう。 このシナリオでは、次のように定義されたクライアントのクラスを使用して、ユーザーのリスト (非常に制限のある連絡先リスト) を返す単純なコントローラーを使用します。\n<pre class=\"prettyprint\">    public class Person\n    {\n        [JsonProperty(\"id\")]\n        public string Id { get; set; }\n\n        [JsonProperty(\"name\")]\n        public string Name { get; set; }\n\n        [JsonProperty(\"age\")]\n        public int Age { get; set; }\n    }</pre>\n既定では、テーブルコントローラーの読み取り操作では、最大50個の項目が返されます。 テーブルストレージにさらに多くの場合、クライアントはメソッドまたは <code>ToEnumerableAsync</code> メソッドの <code>ToListAsync</code> 結果をインターフェイスに <code>IQueryResultEnumerable&lt;T&gt;</code> キャストすることにより、さらに多くの要求を行う必要があります。 次のコードは、テーブル内のすべての要素を処理する方法を示しています。\n<pre class=\"prettyprint\">    public async Task&lt;double&gt; CalculateAverageAge()\n    {\n        var client = new MobileServiceClient(AppUrl, AppKey);\n        var table = client.GetTable&lt;Person&gt;();\n        var sum = 0.0;\n        var count = 0;\n        var items = await table.Take(10).ToEnumerableAsync();\n        while (items != null &amp;&amp; items.Count() != 0)\n        {\n            count += items.Count();\n            sum += Enumerable.Sum(items, i =&gt; i.Age);\n\n            var queryResult = items as IQueryResultEnumerable&lt;Person&gt;;\n            if (queryResult != null &amp;&amp; queryResult.NextLink != null)\n            {\n                items = await table.ReadAsync&lt;Person&gt;(queryResult.NextLink);\n            }\n            else\n            {\n                items = null;\n            }\n        }\n\n        return sum / count;\n    }</pre>\nJSON テーブル (たとえば、など <code>Person</code> の型を使用せず、ファミリを使用しない) を使用している場合は、メソッドの <code>ReadAsync</code> パラメーターにを <code>wrapResult</code> 渡す <code>true</code> ことによって、オブジェクトにラップされるように応答を要求でき <code>JToken</code> ます。 その場合、結果は次のプロパティと共にオブジェクトにラップされます。 <strong>結果</strong>は、サービスからの実際の結果を含む配列を含みます。および <strong>Nextlink</strong>。これは、HTTP 応答に継続トークンを含むリンクヘッダーがあり、テーブルから次のエントリセットを取得するためにメソッドに <code>ReadAsync</code> 渡す必要がある場合に表示されます。\n<pre class=\"prettyprint\">    public async Task&lt;double&gt; CalculateAverageAge2()\n    {\n        var client = new MobileServiceClient(AppUrl, AppKey);\n        var table = client.GetTable(\"person\");\n        var sum = 0.0;\n        var count = 0;\n        var response = await table.ReadAsync(\"$top=10\", null, wrapResult: true);\n        while (response != null)\n        {\n            var items = (JArray)response[\"results\"];\n            var nextLink = (string)response[\"nextLink\"];\n\n            count += items.Count();\n            sum += Enumerable.Sum(items, i =&gt; (int)i[\"age\"]);\n\n            if (nextLink != null)\n            {\n                response = await table.ReadAsync(nextLink, null, true);\n            }\n            else\n            {\n                response = null;\n            }\n        }\n\n        return sum / count;\n    }</pre>\n継続リンクを使用すると、クライアントはテーブルオブジェクトの read メソッドに渡すことによって、Azure Storage 内のテーブルからすべての項目を走査できるようになります。\n<h2>ボーナスマテリアル: Azure Storage テーブルを使用したサービスの設定</h2>\nTable storage でサポートされているコントローラーでサービスをまだ設定していない場合は、次の手順を実行してください。\n<h3>ストレージアカウントの設定</h3>\nまだ行っていない場合は、テーブルストレージを使用するように Azure Storage アカウントを設定する必要があります。 テーブルのデータの保存と取得を開始する前に、Azure のストレージアカウントが必要です。 アカウントを作成する方法については、「<a href=\"https://azure.microsoft.com/en-us/documentation/articles/storage-create-storage-account/\">Storage アカウントを作成する方法</a>」の手順に従ってください。\n\nアカウントがセットアップされたら、アカウント名とアクセスキーを取得して、ストレージアカウントとの通信方法をモバイルサービスに通知する必要があります。 キーを取得するには、従来のポータルのクイックスタートまたは [ダッシュボード] タブに移動し、[アクセスキーの管理] オプションを選択します。\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/10/09/000a-StorageAccountInfo.png\"><img style=\"padding-top: 0px; padding-left: 0px; padding-right: 0px; border-width: 0px;\" title=\"000a-StorageAccountInfo\" alt=\"000a-StorageAccountInfo\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/000a-StorageAccountInfo_thumb.png\" width=\"480\" height=\"350\" border=\"0\" /></a>\n\nまたは、新しいポータルで次のようにします。\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/10/09/000b-StorageAccountInfoNewPortal.png\"><img style=\"padding-top: 0px; padding-left: 0px; padding-right: 0px; border-width: 0px;\" title=\"000b-StorageAccountInfoNewPortal\" alt=\"000b-StorageAccountInfoNewPortal\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/000b-StorageAccountInfoNewPortal_thumb.png\" width=\"484\" height=\"379\" border=\"0\" /></a>\n\nアカウント名とキーを取得すると、モバイルサービスに移行できるようになります。\n<h3>サービスのセットアップ</h3>\nAzure Storage を使用してモバイルサービスのデータを格納するには、Azure Mobile Services .net バックエンドの Azure Storage 拡張機能を追加する必要があります。 サービスプロジェクトを右クリックし、[Manage NuGet Packages (パッケージの管理)] を選択します。 \"windowsazure.mobileservices\" を検索します。 上に示したパッケージ (および以下を参照) を選択し、[インストール] をクリックします。\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/10/09/001-AddStorageNuGet.png\"><img style=\"padding-top: 0px; padding-left: 0px; padding-right: 0px; border-width: 0px;\" title=\"001-AddStorageNuGet\" alt=\"001-AddStorageNuGet\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/001-AddStorageNuGet_thumb.png\" width=\"610\" height=\"344\" border=\"0\" /></a>\n\nパッケージがインストールされたら、サービスの作成を開始できます。 この例では、友人を格納する非常に単純なテーブルを作成し、次に示すようにクラス <code>Person</code> を定義します。 基本クラス (通常は Entity Framework/SQL に基づくプロジェクトで使用されます) を使用する代わり <code>EntityData</code> に、基本クラスを使用 <code>StorageData</code> します。これにより、パーティション/行キーなど、Azure Table Storage で使用されるプロパティが定義されます。\n<pre class=\"prettyprint\">    public class Person : StorageData\n    {\n        public string Name { get; set; }\n\n        public int Age { get; set; }\n    }</pre>\n次に、ストレージアカウントの接続文字列をサービスに追加します。 これは、web.config ファイルで設定できます (開発には適していますが、セキュリティではなくローカルでデバッグする場合に使用できます)。また、ポータルの [構成] タブの [接続文字列] セクションでも設定できます (ソースコードへのアクセス権を持つ方が Azure にデプロイされている場合にのみ機能します)。 わかりやすくするために、Web.config に変更を加えます。\n<pre class=\"prettyprint\">  &lt;connectionStrings&gt;\n    &lt;add name=\"MS_TableConnectionString\"\n         connectionString=\"&lt;the actual value&gt;\"\n         providerName=\"System.Data.SqlClient\" /&gt;\n    &lt;add name=\"My_StorageConnectionString\"\n         connectionString=\"DefaultEndpointsProtocol=https;AccountName=&lt;the account&gt;;AccountKey=&lt;the key&gt;;\"/&gt;\n  &lt;/connectionStrings&gt;</pre>\n最後に、ストレージアカウントのテーブルのデータをモバイルサービスのテーブルとして公開するコントローラークラスを作成できます。 実装は、ポータルの [クイックスタート] ページの [ダウンロード] リンクに生成されるものとほぼ同じですが、次のような例外があります。この場合、Entity Framework を使用したデータの Visual Studio テンプレートで生成されます。\n<ul>\n <li>ドメインマネージャーの種類 <code>StorageDomainManager&lt;T&gt;</code> はで、モバイルサービステーブルとバッキングデータストア (Azure storage) の間にマップされます。</li>\n <li>Azure storage のテーブルは、SQL データベースの do テーブルとしての完全な <code>IQueryable&lt;T&gt;</code> クエリ機能をサポートしていないため、を返すことはサポートされていません。 ただし、基本データ型 <code>TableController&lt;T&gt;</code> には、ストレージテーブルで使用できる1つのメソッドがあります。 (複数の項目をクエリする場合) と <code>LookupAsync</code> (単一の項目をクエリする場合) です。 <code>QueryAsync</code></li>\n</ul>\nこの例のコントローラークラスの完全なコードを次に示します。\n<pre class=\"prettyprint\">    public class PersonController : TableController&lt;Person&gt;\n    {\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            var tableName = controllerContext.ControllerDescriptor.ControllerName.ToLowerInvariant();\n            var connStringName = \"My_StorageConnectionString\";\n            DomainManager = new StorageDomainManager&lt;Person&gt;(connStringName, tableName, Request, Services);\n        }\n\n        // GET tables/Person\n        public Task&lt;IEnumerable&lt;Person&gt;&gt; GetAllPerson(ODataQueryOptions queryOptions)\n        {\n            return base.QueryAsync(queryOptions); \n        }\n\n        // GET tables/Person/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task&lt;SingleResult&lt;Person&gt;&gt; GetPerson(string id)\n        {\n            return base.LookupAsync(id);\n        }\n\n        // PATCH tables/Person/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task&lt;Person&gt; PatchPerson(string id, Delta&lt;Person&gt; patch)\n        {\n             return UpdateAsync(id, patch);\n        }\n\n        // POST tables/Person/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public async Task&lt;IHttpActionResult&gt; PostPerson(Person item)\n        {\n            Person current = await InsertAsync(item);\n            return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n        }\n\n        // DELETE tables/Person/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task DeletePerson(string id)\n        {\n             return DeleteAsync(id);\n        }\n    }</pre>\n注意が必要なのは、クライアント Sdk を使用したコントラクトの一部として、lookup/delete/update メソッドが文字列型の id を受け取ることです。 しかし、テーブルに格納されている項目の id は、パーティションキーと行キーの2つの部分で構成されます。 これら2つのワールドを結合するには、id がパーティションキー &gt; と &lt; 行キー &gt; の形式 &lt; であるマッピングを定義します (必要に応じて、キーを単一引用符で囲むことができます)。 たとえば、上記のコードを使用してサービスを実行した場合、次のような要求を含む項目を挿入できます。\n<pre class=\"prettyprint\">POST /tables/person HTTP/1.1\nX-ZUMO-APPLICATION: &lt;the app key&gt;\nContent-Type: application/json; charset=utf-8\nHost: mobile-service-name.azure-mobile.net\nContent-Length: 75\n\n{\n  \"id\": \"partition,row1082\",\n  \"name\": \"dibika lyzufu\",\n  \"age\": 64\n}</pre>\n<h2>まとめ</h2>\nこれで完了です。 継続リンクの取得のサポートは、現在、マネージクライアントプラットフォームで使用できますが、他のプラットフォームでも近日対応予定です。 この記事で使用されているコードを取得する場合は、 <a href=\"https://github.com/Azure/mobile-services-samples\">モバイルサンプルリポジトリ</a>の <a href=\"https://github.com/Azure/mobile-services-samples/tree/master/NetBackendWithTableStorage\">Netbackendwithtablestorage ディレクトリ</a>の下にあります。\n\n通常どおり、この投稿のコメントとして、twitter <a href=\"https://twitter.com/azuremobile\">@AzureMobile</a> または <a href=\"https://social.msdn.microsoft.com/Forums/windowsazure/en-US/home?forum=azuremobile\">MSDN フォーラム</a>からフィードバックをお送りください。"
