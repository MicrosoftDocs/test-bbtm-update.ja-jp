### YamlMime:Yaml
ms.openlocfilehash: d7f025a53fcac8c403219ff201be37af32fa184a
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139904642"
Slug: new-article-best-practices-for-performance-improvements-using-service-bus-brokered-messaging
Title: '新しい記事: ブローカー メッセージングを使用したパフォーマンスService Busベスト プラクティス'
Summary: この投稿では、最適なパフォーマンスを実現するために、Service Busメッセージング機能を使用する方法について説明します。 詳細については、MSDN の完全な記事を参照してください。  クライアント... Service Bus使用します。
Content: '<p>この投稿では、最適なパフォーマンスを実現するために、Service Busメッセージング機能を使用する方法について説明します。 詳細については、MSDN の完全 <a target="_blank" href="https://msdn.microsoft.com/en-us/library/hh528527.aspx">な記事</a> を参照してください。</p>  <h2>Service Bus クライアント プロトコルを使用する</h2>  <p>このService Busは、Service Busクライアント プロトコルと HTTP をサポートします。 クライアント Service Busは、メッセージ ファクトリが存在する限り、Service Bus サービスへの接続を維持するために、より効率的です。 また、バッチとプリフェッチも実装されます。 .NET Service Busクライアント プロトコルは、.NET マネージド API を使用して .NET アプリケーションで使用できます。 可能な限り、クライアント プロトコルをService BusしてService Bus接続します。</p>  <h2>工場とクライアントを再利用する</h2>  <p>Service Bus <a target="_blank" href="https://msdn.microsoft.com/en-us/library/microsoft.servicebus.messaging.queueclient.aspx">QueueClient</a> や <a target="_blank" href="https://msdn.microsoft.com/en-us/library/microsoft.servicebus.messaging.messagesender.aspx">MessageSender</a> などのクライアント オブジェクトは <a target="_blank" href="https://msdn.microsoft.com/en-us/library/microsoft.servicebus.messaging.messagingfactory.aspx">MessagingFactory</a> を介して作成され、接続の内部管理も提供されます。 Service Bus クライアント プロトコルを使用する場合は、メッセージを送信した後でメッセージング の工場とキュー、トピック、サブスクリプション のクライアントを閉じ、次のメッセージを送信するときにそれらを再作成しないようにします。 代わりに、複数の操作にファクトリとクライアントを使用します。 メッセージング ファクトリを閉じると、メッセージング ファクトリへの接続Service Bus。 接続の確立は、コストのかかる操作です。</p>  <h2>同時実行操作の使用</h2>  <p>操作 (送信、受信、削除など) の実行には、一定の時間が必要です。 この時間には、要求と応答の待機時間Service Busサービスによる操作の処理が含まれます。 1 回あたりの操作数を増やすには、操作を同時に実行する必要があります。 これは特に、クライアントと名前空間をホストするデータセンター間のデータ交換の待機時間が長Service Bus場合に当てはまれます。</p>  <p>複数の操作を同時に実行するには、いくつかの方法があります。</p>  <p>非同期操作。 クライアントは、非同期操作を実行して操作をパイプライン処理します。 次の要求は、前の要求が完了する前に開始されます。</p>  <p>複数の工場。 同じファクトリによって作成されたクライアント (送信者と受信者) は、1 つの TCP 接続を共有します。 最大メッセージ スループットはこの TCP 接続を通過できる操作の数によって制限されます。 1 つのファクトリで取得できるスループットは、TCP ラウンドトリップ時間とメッセージ サイズによって大幅に変わります。</p>  <h2>クライアント側のバッチ処理を使用する</h2>  <p>クライアント側のバッチ処理を使用すると、キュー/トピック クライアントは複数の送信操作を 1 つの要求にバッチ処理できます。 また、キュー/サブスクリプション クライアントは、複数の Complete 要求を 1 つの要求にバッチ処理できます。 既定では、クライアントは 20 ミリ秒のバッチ間隔を使用します。 メッセージング ファクトリを作成する前に、MessagingFactorySettings.NetMessagingTransportSettings.BatchFlushInterval を設定することで、バッチ間隔を変更できます。 この設定は、このファクトリによって作成されるすべてのクライアントに影響します。</p>  <p><span style="background-color: #ffffff; color: #33cccc;">MessagingFactorySettings</span> mfs = <span style="color: #3366ff;">new</span> <span style="color: #33cccc;">MessagingFactorySettings</span>();</p>  <p>Mfs。TokenProvider = tokenProvider;</p>  <p>Mfs。NetMessagingTransportSettings.BatchFlushInterval = <span style="color: #33cccc;">TimeSpan.FromSeconds</span>(0.05);</p>  <p><span style="color: #33cccc;">MessagingFactory</span> messagingFactory = <span style="color: #33cccc;">MessagingFactory</span>。Create(namespaceUri, mfs);</p>  <p>低スループットで待機時間の短いシナリオでは、バッチ処理を無効にします。 これを行うには、バッチ フラッシュ間隔を 0 に設定します。 高スループットのシナリオでは、バッチ処理間隔を 50ms に増やします。 複数の送信側を使用する場合は、バッチ処理の間隔を 100 ミリ秒に増やします。</p>  <p>バッチ処理は非同期の送信および完了操作でのみ使用できます。 同期操作はすぐに Service Bus サービスに送信されます。 ピーク操作や受信操作ではバッチ処理は行われません。また、クライアント間でバッチ処理も行われません。</p>  <h2>バッチ ストア アクセスを使用する</h2>  <p>キュー/トピック/サブスクリプションのスループットを向上するために、Service Busサービスは、内部ストアに書き込むときに複数のメッセージをバッチ処理します。 キューまたはトピックで有効になっている場合、ストアへのメッセージ書き込みがバッチ処理されます。 キューまたはサブスクリプションで有効になっている場合、ストアからのメッセージ削除がバッチ処理されます。 バッチ処理ストア アクセスは送信操作と完了操作にのみ影響を与えます。受信操作は影響を受けません。</p>  <p>新しいキュー、トピック、またはサブスクリプションを作成する場合、バッチ間隔が 20ms のバッチ ストア アクセスが有効になります。 低スループットで待機時間の短いシナリオでは、 <span style="color: #33cccc;">QueueDescription</span> を設定して、バッチストア アクセスを無効にします。エンティティを作成する前に EnableBatchedOperations を <span style="color: #3366ff;">false</span> に設定します。</p>  <p><span style="color: #33cccc;">QueueDescription</span> qd = <span style="color: #3366ff;">new</span> QueueDescription();</p>  <p>Qd。EnableBatchedOperations = <span style="color: #3366ff;">false</span>;</p>  <p><span style="color: #33cccc;">Queue</span> q = namespaceManager.CreateQueue(qd);</p>  <h2>プリフェッチを使用する</h2>  <p>プリフェッチにより、キュー/サブスクリプション クライアントは、受信操作を実行するときにサービスから追加のメッセージを読み込まれます。 クライアントはこれらのメッセージをローカル キャッシュに格納します。 <span style="color: #33cccc;">QueueClient。</span>PrefetchCount と <span style="color: #33cccc;">SubscriptionClient</span>。PrefetchCount 値は、プリフェッチできるメッセージの数を指定します。 プリフェッチが有効になっているクライアントはそれぞれ独自のキャッシュを保持します。 キャッシュはクライアント間で共有されません。</p>  <p>Service Busプリフェッチされたメッセージを別の受信者が受信できない場合に、プリフェッチされたメッセージをロックします。 ロックの有効期限が切れる前に受信者がメッセージを完了できない場合、メッセージは他の受信者が使用できます。 プリフェッチされたメッセージのコピーはキャッシュに残ります。 受信側は、有効期限が切れたキャッシュされたメッセージのコピーを完了しようとするときに例外を受け取ります。</p>  <p>期限切れのメッセージが消費されるのを防ぐには、キャッシュ サイズが、ロック タイムアウト間隔内にクライアントが使用できるメッセージの数よりも小さくする必要があります。 60 秒間の既定のロック有効期限を使用するとき、SubscriptionClient.PrefetchCount の適切な値はファクトリの全受信者の最大処理レートの 20 倍になります。 たとえば、ファクトリによって 3 つの受信者が作成され、各受信者が 1 秒あたり最大 10 件のメッセージを処理できる場合、プリフェッチ数は *20310* = 600 を超えないようにする必要があります。</p>  <p>既定では、QueueClient.PrefetchCount は 0 に設定されます。これはサービスから追加のメッセージがフェッチされないことを意味します。 受信側がメッセージを大量に消費する場合は、プリフェッチを有効にしてください。 待機時間の短いシナリオでは、1 つのクライアントがキューまたはサブスクリプションからのメッセージを使用する場合は、プリフェッチを有効にします。 複数のクライアントを使用する場合は、プリフェッチ数を 0 に設定します。 これにより、2 番目のクライアントは、最初のクライアントがまだ最初のメッセージを処理している間に 2 番目のメッセージを受信できます。</p>  <p>MSDN の <a target="_blank" href="https://msdn.microsoft.com/en-us/library/hh528527.aspx">完全な記事</a> を参照してください。</p>'
