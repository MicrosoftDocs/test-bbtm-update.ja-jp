### YamlMime:Yaml
ms.openlocfilehash: 769bf37143745122f1ed03f44d7f562f38ec4aa7
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139892278"
Slug: sql-azure-horizontal-partitioning-part-2
Title: '行方向のパーティション分割 SQL Azure: パート2'
Summary: '[この記事は SQL Azure チームによって提供されました。]SQL Azure は現在 1 gb と 10 gb のデータベースをサポートしていますが、2010年6月28日には 50 GB のサポートがあります。 より多くの容量を格納するには...'
Content: <p>[この記事は SQL Azure チームによって提供されました。]</p><p>SQL Azure は、現在 1 gb と 10 gb のデータベースをサポートしており、2010年6月28日に 50<sup>GB のサポート</sup>があります。 SQL Azure に大量のデータを格納する場合は、複数の SQL Azure データベース間でテーブルを分割できます。 この記事では、データアクセス層を使用して、LINQ を使用して異なる SQL Azure データベース上の2つのテーブルを結合する方法について説明します。 この手法では、データを SQL Azure に分割します。 </p>  <p>このバージョンの行方向のパーティション分割では、パーティションセット内のすべてのデータベースにすべてのテーブルが存在します。 この例 &ndash; では、ハッシュベースのパーティション分割スキーマを使用して、行の主キーをハッシュしています。 中間層では、書き込まれるデータの主キーに基づいて各行を書き込むデータベースを決定します。 これにより、個々のテーブルの拡張に関係なく、すべてのデータベース間でデータを均等に分割することができます。 データアクセスは、主キーに基づいてデータを検索する方法を認識し、結果を結合して1つの結果セットを呼び出し元に返します。</p>  <p>これは、ハッシュベースのパーティション分割と見なされます。 範囲ベースの横線 portioning の別のスタイルもあります。 主キーとして整数を使用している場合は、主キーのサイズが大きくなるにつれて、データベースを連続した順序で入力するために中間層を実装できます。 さまざまな種類のパーティション分割の詳細については、 <a href="https://social.technet.microsoft.com/wiki/contents/articles/scaling-out-with-sql-azure.aspx">こちら</a>を参照してください。</p>  <h2>パフォーマンスの向上</h2>  <p>データベースをパーティション分割することによって、パフォーマンスの向上も得られます。 SQL Azure によってデータベースが複数の物理マシンに分散されるため、ワークロードをパーティション分割することで、より多くの CPU と RAM リソースを取得できます。 たとえば、データベースを 10-1 GB SQL Azure のデータベースにパーティション分割すると、CPU とメモリのリソースが10倍になります。 TicketDirect によって、ピーク時の負荷中に数百の SQL Azure データベース間でワークロードをパーティション分割するケーススタディ (<a href="https://www.microsoft.com/casestudies/Case_Study_Detail.aspx?CaseStudyID=4000005890">ここ</a>にあります) があります。 </p>  <h2>考慮事項</h2>  <p>データベースを行方向にパーティション分割すると、すべてのデータを1つのデータベースに格納する機能の一部が失われます。 この手法を使用する場合の考慮事項は次のとおりです。</p>  <ul>  <li>複数のデータベースにまたがる外部キーはサポートされていません。 言い換えると、あるデータベースのルックアップテーブルの主キーを、別のデータベースのテーブルの外部キーから参照することはできません。 これは、外部キーに対する SQL Server &rsquo; のデータベース間サポートにも同様の制限があります。</li>  <li>クライアント側で Microsoft 分散トランザクションマネージャーを使用している場合でも、2つのデータベースにまたがるトランザクションを作成することはできません。 これは、別のデータベースへの挿入が失敗した場合に、1つのデータベースで挿入をロールバックできないことを意味します。 この制限は、例外をキャッチし、正常に完了したステートメントに対して undo &rdquo; スクリプトを実行 &ldquo; するために必要なクライアント側のコーディング &ndash; によって軽減できます。</li>  <li>主キーはすべて uniqueidentifier である必要があります。 これにより、中間層の主キーの一意性を保証できるようになります。</li>  <li>次 &rsquo; に示すコード例では、パーティションセット内のデータベースの数を動的に変更することはできません。 データベースの数は、 <b>ConnectionStringNames</b>プロパティの<b>SqlAzureHelper</b>クラスにハードコーディングされています。</li>  <li>SQL Server から水平方向にパーティション分割されたデータベースにデータをインポートするには、次のコードのように主キーのハッシュをエミュレートするときに、各行を1つずつ移動する必要があります。</li>  </ul>  <h2>コード</h2>  <p>このコードでは、SQL Azure に複数の同時要求を作成し、それらのリソースを活用するために結果を結合する方法を示します。 この記事を読む前に、Uniqueidentifier およびクラスター化インデックスと接続と SQL Azure の使用に関する前の記事について理解しておく必要があります。 行方向のパーティション分割を実行するために、列方向のパーティション分割のブログ記事で使用したのと同じ <b>SQLAzureHelper </b>クラスを使用しています。</p>  <p>コードには次のような目標があります。</p>  <ul>  <li>パフォーマンスを最大化するには、順方向専用カーソルを使用します。</li>  <li>Linq を使用して、複数の応答を完全な応答に結合します。</li>  <li>プライマリキー要求に対して1つのデータベースにのみアクセスします。</li>  <li>すべてのデータベースで行データを均等に分割します。</li>  </ul>  <h2>Accounts テーブル</h2>  <p>ここで使用しているテーブルの例では、Accounts という名前の主キーを持ち、日付列にクラスター化インデックスが構築されています。 次の2つのデータベースに対してこのスクリプトを作成しました。</p>  <pre class="csharpcode"><span class="kwrd">CREATE</span> <span class="kwrd">TABLE</span> [dbo].[Accounts](      [Id] [uniqueidentifier] <span class="kwrd">NOT</span> <span class="kwrd">NULL</span>,      [Name] [nvarchar](<span class="kwrd">max</span>) <span class="kwrd">NULL</span>,      [<span class="kwrd">Date</span>] [datetime] <span class="kwrd">NULL</span>,   <span class="kwrd">CONSTRAINT</span> [PK_Accounts] <span class="kwrd">PRIMARY</span> <span class="kwrd">KEY</span> <span class="kwrd">NONCLUSTERED</span>   (      [Id] <span class="kwrd">ASC</span>  )  )      <span class="kwrd">ALTER</span> <span class="kwrd">TABLE</span> [dbo].[Accounts] <span class="kwrd">ADD</span>  <span class="kwrd">CONSTRAINT</span> [DF__Accounts__Date__7C8480AE]  <span class="kwrd">DEFAULT</span> (getdate()) <span class="kwrd">FOR</span> [<span class="kwrd">Date</span>]      <span class="kwrd">CREATE</span> <span class="kwrd">CLUSTERED</span> <span class="kwrd">INDEX</span> [idxDate] <span class="kwrd">ON</span> [dbo].[Accounts]   (      [<span class="kwrd">Date</span>] <span class="kwrd">ASC</span>  )</pre>  <p>    </p>  <h2>主キーによるパーティション分割</h2>  <p>パーティション分割しているテーブルは主キーとして uniqueidentifier を使用しており、これらは <b>guid. NewGuid ()</b> によって生成されるので、ランダムな主キーがあります。 主キーはハッシュされ、そのキーの行がどのデータベースに含まれているかを判別します。 コードは次のようになります。</p>  <pre class="csharpcode"><span class="rem">/// &lt;summary&gt;</span>  <span class="rem">/// Names of the Databases In Horizontal Partition</span>  <span class="rem">/// &lt;/summary&gt;</span>  <span class="kwrd">public</span> <span class="kwrd">static</span> String[] ConnectionStringNames =   { <span class="str">"Database001"</span>, <span class="str">"Database002"</span> };    <span class="rem">/// &lt;summary&gt;</span>  <span class="rem">/// Connections Strings In the Horizontal Partition</span>  <span class="rem">/// &lt;/summary&gt;</span>  <span class="rem">/// &lt;returns&gt;&lt;/returns&gt;</span>  <span class="kwrd">public</span> <span class="kwrd">static</span> IEnumerable&lt;String&gt; ConnectionStrings()  {      <span class="kwrd">foreach</span> (String connectionStringName <span class="kwrd">in</span> ConnectionStringNames)          <span class="kwrd">yield</span> <span class="kwrd">return</span> ConfigurationManager.  ConnectionStrings[connectionStringName].ConnectionString;  }    <span class="rem">/// &lt;summary&gt;</span>  <span class="rem">/// Return the Index to the Database For the Primary Key</span>  <span class="rem">/// &lt;/summary&gt;</span>  <span class="rem">/// &lt;param name="primaryKey"&gt;&lt;/param&gt;</span>  <span class="rem">/// &lt;returns&gt;&lt;/returns&gt;</span>  <span class="kwrd">private</span> <span class="kwrd">static</span> <span class="kwrd">int</span> DatabaseIndex(Guid primaryKey)  {      <span class="kwrd">return</span> (BitConverter.ToInt32(primaryKey.ToByteArray(), 0));  }    <span class="rem">/// &lt;summary&gt;</span>  <span class="rem">/// Returns the Connectiong String Name for the Primary Key</span>  <span class="rem">/// &lt;/summary&gt;</span>  <span class="rem">/// &lt;param name="primaryKey"&gt;&lt;/param&gt;</span>  <span class="rem">/// &lt;returns&gt;&lt;/returns&gt;</span>  <span class="kwrd">private</span> <span class="kwrd">static</span> String ConnectionStringName(Guid primaryKey)  {      <span class="kwrd">return</span> (ConnectionStringNames[DatabaseIndex(primaryKey) %   ConnectionStringNames.Length]);  }    <span class="rem">/// &lt;summary&gt;</span>  <span class="rem">/// Returns the Connection String For the Primary Key</span>  <span class="rem">/// &lt;/summary&gt;</span>  <span class="rem">/// &lt;param name="primaryKey"&gt;&lt;/param&gt;</span>  <span class="rem">/// &lt;returns&gt;&lt;/returns&gt;</span>  <span class="kwrd">public</span> <span class="kwrd">static</span> String ConnectionString(Guid primaryKey)  {      <span class="kwrd">return</span> (ConfigurationManager.ConnectionStrings[ConnectionStringName(primaryKey)]  .ConnectionString);  } </pre>  <p>    </p>  <p><b>ConnectionString ()</b>メソッドは、主キーを参照するときに使用する接続文字列を返すことに注意してください。 アプリケーションまたは web サイトの .config ファイルで接続文字列を構成します。 .config ファイルによって参照されるデータベースの配列は、 <b>ConnectionStrings</b> プロパティに含まれています。</p>  <h2>単一行のフェッチ</h2>  <p>ブログ記事で定義されている <b>SQLAzureHelper </b>クラスの上に構築しています。 クラスの背後にある考え方は、SQL Azure に接続するための多目的アクセス層を持つことです。 <b>SQLAzureHelper</b>クラス内では、主キーを使用してサンプルデータベースでアカウント名を検索するコードは次のようになります。</p>  <pre class="csharpcode"><span class="kwrd">static</span> String AccountName(Guid id)  {      var accountDataReader = SQLAzureHelper.ExecuteReader(          SQLAzureHelper.ConnectionString(id),          sqlConnection =&gt;          {              String sql = <span class="str">@"SELECT [Name] FROM [Accounts] WHERE Id = @Id"</span>;              SqlCommand sqlCommand = <span class="kwrd">new</span> SqlCommand(sql, sqlConnection);              sqlCommand.Parameters.AddWithValue(<span class="str">"@Id"</span>, id);              <span class="kwrd">return</span> (sqlCommand.ExecuteReader());          });        <span class="kwrd">return</span> ((from row <span class="kwrd">in</span> accountDataReader select (<span class="kwrd">string</span>)row[<span class="str">"Name"</span>]).          FirstOrDefault());  }</pre>  <p>    </p>  <p>主キーを使用して、接続文字列と、 <b>SqlCommand</b>のパラメーターを計算することに注意してください。</p>  <h2>単一行の挿入 </h2>  <p>1つの行を挿入する場合は、データベースに接続する前に主キーを把握しておく必要があります。 これを実現するために、SQL Azure で<b>NewID ()</b>ではなく、C# コードで<b>guid.empty guid ()</b>を呼び出します。 <b>ExecutionContext</b>クラスを使用するコードは次のようになります。</p>  <pre class="csharpcode"><span class="kwrd">static</span> Guid InsertAccount(String name)  {      Guid id = Guid.NewGuid();        SQLAzureHelper.ExecuteNonQuery(           SQLAzureHelper.ConnectionString(id),           sqlConnection =&gt;           {               String sql = <span class="str">@"INSERT INTO [Accounts] ([Id], [Name]) VALUES (@Id, @Name)"</span>;               SqlCommand sqlCommand = <span class="kwrd">new</span> SqlCommand(sql, sqlConnection);               sqlCommand.Parameters.AddWithValue(<span class="str">"@Name"</span>, name);               sqlCommand.Parameters.AddWithValue(<span class="str">"@Id"</span>, id);               sqlCommand.ExecuteNonQuery();           });        <span class="kwrd">return</span> (id);  }</pre>  <p>    </p>  <h2>まとめ</h2>  <p>パート3では、複数の応答から結合された結果セットをフェッチする方法、および複数の行をパーティションテーブルに挿入する方法について説明します。これには、多数の SQL Azure データベースを同時に呼び出すという、いくつかの興味深い部分が含まれます。 質問、懸念事項、コメントがありますか。 これらを下に投稿してください。</p>
