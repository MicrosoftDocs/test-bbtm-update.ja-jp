### YamlMime:Yaml
ms.openlocfilehash: 181a2850f041e8f5b7b0b5c0e60a0ef067d8a4a1
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139896676"
Slug: microservices-an-application-revolution-powered-by-the-cloud
Title: マイクロサービス:クラウドによって実現されるアプリケーションの革命
Summary: 私たちは、ビジネスの現実が開発者に "マイクロサービス" と呼ばれるアプリケーション アーキテクチャ モデルの採用を推進しているクラウドによって推進されるアプリケーション開発と IT システム管理の変革の真っ最中です。
Content: >-
  <p>私たちは、クラウドによって推進されるアプリケーション開発と IT システム管理の変革の真っ最中です。 高速でアジャイルで、安価で、非常にスケーラブルなインフラストラクチャであり、完全にセルフサービスで、かつ、移動料金を支払う必要が生じ、運用効率が向上し、業界全体で価値を高めることができます。 迅速な <a href="https://azure.microsoft.com/en-us/blog/containers-docker-windows-and-trends/">起動、標準化</a>されたアプリケーション パッケージ化、分離モデルを備えたコンテナーの出現は、効率性と機敏性にさらに貢献しています。</p>


  <p>しかし、多くの企業では、アプリケーションの高可用性、スケーラブル、アジャイル化が依然として困難な課題を発見しています。 競争力のあるビジネス上の圧力により、アプリケーションは継続的に進化し、使用可能な 24 時間 365 日の間に新機能が追加される必要があります。 たとえば、銀行の Web サイトでメンテナンス期間を設定できなくなりましたが、数年前でもそれが当たり前でした。 同様に、短時間でもダウンする eコマース&rsquo; サイトは、顧客をその時点で提供できる多くの競合他社の 1 つに追い込むでしょう。 これらの要求を満たしていない場合は、関連性を持ち続け、ビジネスを失う場合の違いを意味する可能性があります。</p>


  <p>これらのビジネスの現実&ldquo;&rdquo;により、開発者はマイクロサービスと呼ばれるアプリケーション アーキテクチャ モデルを採用する必要があります。これは<a href="https://martinfowler.com/articles/microservices.html">、James James と Martin Fowler</a> によって広く使用されている用語です。 この投稿では、&#39;アーキテクチャがアプリケーションの開発タスクとライフサイクル タスクに役立つ方法と理由について説明し、それらのアーキテクチャをサポートするためにプラットフォームが提供できる機能について説明します。 &rsquo;次に、Azure&rsquo; がサポートするマイクロサービス ベースのアプリケーションの基盤として開発者が一般的に使用するプラットフォームの一部を一覧表示し、最後に、マイクロサービス ライフサイクル管理を包括的にサポートする Service Fabric と呼ばれるマイクロサービス アプリケーション プラットフォームについて簡単に説明します。</p>


  <h2>モノリシック アプリケーション モデル</h2>


  <p>何十年もの間、物理ハードウェアと仮想ハードウェアの間で新しいハードウェアをプロビジョニングするコスト、時間、複雑性は、アプリケーションの開発に大きな影響を与えてきた。 これらの要因は、これらのアプリケーションがミッション クリティカルな場合に、より顕著になります。これは、高いアップタイムには、SAN やハードウェア ロード バランサーなどの高価なハードウェアを含む高可用性インフラストラクチャが必要です。 IT インフラストラクチャは静的なので、仮想化された場合でも、アプリケーションは静的にサイズ設定され、特定のハードウェア用に設計されたように記述されています。 全体的なハードウェア要件を最小限に抑え、ある程度の機敏性と独立したスケーリングを提供するためにアプリケーションが分解された場合でも、一般的には、次の図に示すように、Web、ビジネス ロジック、データ層を含む従来の 3 層モデルに入っています。 ただし、各レベルはまだ独自のモノリスであり、ピーク時の負荷のために事前にスケーリングされたハードウェアにデプロイされた 1 つのパッケージに組み合わされた多様な機能を実装しています。 負荷が原因で&ldquo;&rdquo;&rsquo;アプリケーションがハードウェアを拡張した場合、通常、データセンターの再構成とソフトウェアの再アーキテクチャを回避するために、アプリケーション ハードウェアをスケールアップまたはアップグレードして容量を追加する方法が答えでした。</p>


  <p>&nbsp;</p>


  <p style="margin-left: 80px;"><img alt="Three-tier monolithic application" border="0" height="128" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/24d49135-5217-4611-b969-22ee42c8caf3.png" style="border-image: none; padding-top: 0px; padding-right: 0px; padding-left: 0px; display: inline; background-image: none;" title="3 層モノリシック アプリケーション" width="480"></p>


  <p style="margin-left: 160px;"><em>図 1。Three-Tier モノリシック アプリケーション</em></p>


  <p>モノリシック アプリケーション モデルは、インフラストラクチャの機敏性の制限の自然な結果でしたが、非効率性を生み出しました。 静的インフラストラクチャと長い開発サイクルでは、少数の層を超えてアプリケーションを分解する利点はほとんどなかったため、開発者は層内の関連のないアプリケーション サービス間の緊密な結合を作成しました。 アプリケーション サービス (小規模なサービスでも) を変更するには、レベル全体を再テストして再デプロイする必要がありました。 単純な更新によって、残りのレベルに予期しない影響が生じ、より厳格なテストを可能にするために、変更がリスクが高く、開発サイクルが長引く可能性があります。 静的に割り当てられたリソースと高可用性ハードウェアへの依存により、アプリケーションは負荷とハードウェアのパフォーマンスの変動の影響を受けやすく、標準の運用ゾーン外にプッシュされ、パフォーマンスが著しく低下する可能性があります。 ハードウェアの完全な障害によって、アプリケーション全体が Tailspin に送信される可能性があります。</p>


  <p>最後に、階層化されたアプローチを利用したモノリシック アプリケーションに対するもう 1 つの課題は、バックエンド層に格納されているデータを使用して高速なパフォーマンスを提供することです。 一般的なアプローチは、コンピューティングとデータの分離によって発生する非効率性に対してバッファーする中間キャッシュを導入することでしたが、未使用のハードウェア リソースを追加することでコストが発生し、開発と更新の複雑さを追加しました。</p>


  <p>&nbsp;</p>


  <p style="margin-left: 80px;"><img alt="Three-tier monolithic application with caches" border="0" height="257" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2a791874-26bd-40e1-b500-64a8c2ea2231.png" style="border-image: none; padding-top: 0px; padding-right: 0px; padding-left: 0px; display: inline; background-image: none;" title="キャッシュを使用した 3 層モノリシック アプリケーション" width="610"></p>


  <p style="margin-left: 160px;"><em>図 2。Three-Tierを使用したモノリシック アプリケーションの作成</em></p>


  <h2>マイクロサービス アーキテクチャ</h2>


  <p>モノリシック アーキテクチャが理にかなっているシンプルで限られたスケール アプリケーションは存在しますが、マイクロサービスはアプリケーションの開発とデプロイに対する異なるアプローチであり、多くの最新のクラウド アプリケーションの機敏性、スケーリング、信頼性の要件に完全に適しています。 マイクロサービス アプリケーションは、&ldquo;&rdquo;&rsquo;マイクロサービスと呼ばれる独立したコンポーネントに分解され、アプリケーション全体の機能を提供するために一緒に動作します。 マイクロサービスという &ldquo;用語&rdquo; は、各マイクロサービスが 1 つの関数を実装するように、独立した懸念を真に反映するのに十分な小さなサービスでアプリケーションを構成する必要があるという事実を強調しています。 さらに、他のマイクロサービスが通信してデータを共有するために、それぞれが、通常は RESTful で定義されたコントラクト (API コントラクト) &ndash; を持っています。 マイクロサービスは、互いに独立してバージョン管理および更新できる必要があります。 この疎結合は、アプリケーションの迅速で信頼性の高い進化をサポートします。 図 3 は、モノリシック アプリケーションが異なるマイクロサービスに分割される方法を示しています。</p>


  <p style="margin-left: 80px;"><img alt="Breaking the monolith in microservices" border="0" height="372" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/f05a4c2f-753a-408a-9732-d76d06c70604.png" style="border-image: none; padding-top: 0px; padding-right: 0px; padding-left: 0px; display: inline; background-image: none;" title="マイクロサービスでのモノリスの破損" width="480"></p>


  <p style="margin-left: 160px;"><em>図 3。モノリスをマイクロサービスに分割する</em></p>


  <p>マイクロサービス ベースのアプリケーションを使用すると、アプリケーションを実行する基になるインフラストラクチャから分離できます。 開発者が IT &ldquo;&rsquo;&rdquo; &ldquo;&rdquo;&rsquo;に対してリソース要件を宣言するモノリシック アプリケーションとは異なり、マイクロサービスは、高可用性とデータ レプリケーションの各マイクロサービス要件を受け入れながら、クラスター全体のリソース使用率を最大化するために、クラスターマネージャーと呼ばれる分散ソフトウェア システムにリソース要件を宣言し、クラスターに割り当てられたマシンにリソース要件をスケジュールまたは場所として宣言します。 図 4 に示すように、 マイクロサービス&rsquo;は一般にコンテナーとしてパッケージ化され、多くは通常、単一のサーバーまたは仮想マシン内に収まるため、デプロイは高速であり、クラスターのスケール要件を最小限に抑えるために高密度にパックできます。</p>


  <p style="margin-left: 80px;"><img alt="Cluster of servers with deployed microservices" border="0" height="250" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/8cd6d006-5210-49d5-a425-288410a2f045.png" style="border-image: none; padding-top: 0px; padding-right: 0px; padding-left: 0px; display: inline; background-image: none;" title="マイクロサービスがデプロイされたサーバーのクラスター" width="610"></p>


  <p style="margin-left: 160px;"><em>図 4。デプロイされたマイクロサービスを含むサーバーのクラスター</em></p>


  <p>このモデルでは、マイクロサービスのスケールアウトがほぼ瞬時に行えるので、アプリケーションは負荷の変化に適応できます。 また、疎結合は、マイクロサービスが個別にスケーリングできるという意味です。 たとえば、パブリック エンドポイント HTTP リスナー (アプリケーションの Web 向け機能の 1 つのマイクロサービス) は、追加の受信トラフィックを処理するためにスケールアウトするアプリケーションの唯一のマイクロサービスである可能性があります。</p>


  <p>マイクロサービス ベースのアプリケーションの独立した分散の性質により、ローリング更新も可能になります。この更新では、1 つのマイクロサービスのインスタンスのサブセットのみがいつでも更新されます。 問題が検出された場合&ldquo;&rdquo;は、問題のあるコードまたは構成ですべてのインスタンスが更新される前に、バグの多い更新プログラムをロールバックまたは元に戻すことができます。 更新システムが自動化されている場合、継続的インテグレーション (CI) および継続的デリバリー (CD) パイプラインとの統合により、開発者は可用性に影響を与えるのを恐れることなく、アプリケーションを安全かつ頻繁に進化できます。</p>


  <p>アプリケーションのスケーラビリティの従来のモデルでは、共有外部データストアまたはデータベースを持つ負荷分散されたステートレス層を使用して永続的な状態を格納しますが、ステートフル マイクロサービスは、パフォーマンスの向上、待機時間の短縮、大規模なサービス更新のための開発者の機敏性の維持を実現できます。 ステートフル マイクロサービスは永続的なデータを管理します。通常は、ネットワーク アクセスのオーバーヘッドやサービス間の操作の複雑さを回避するために、配置されているサーバーにローカルに格納します。 これにより、可能な限り最速の処理が可能であり、キャッシュの必要性を排除できます。 さらに、データ サイズを管理し、1 台のサーバーでサポートできるスループットを超えるスループットを転送するために、スケーラブルなステートフル マイクロサービスはインスタンス間でデータをパーティション分割し、スキーマのバージョン管理を実装して、クライアントが通信するマイクロサービス インスタンスに関係なく、更新中でも一貫性のあるバージョンを表示します。</p>


  <h2>マイクロサービス アプリケーション プラットフォーム</h2>


  <p>Bing、Cortana、Intune などのクラウド規模の Microsoft サービス を内部的に実行した経験から、大規模なアプリケーションの設計、開発、デプロイに伴う複雑さをクラウド規模で直接理解できます。 アプリケーションをどれだけ適切に設計しているかに関係なく、大規模で常にオンのアプリケーションを頻繁に更新する方法は課題です。 マイクロサービスを仮想マシンやコンテナーにドロップしても、マイクロサービス アプローチの可能性を完全に引き出す必要がある場合は、DevOps に重点を置いたツールを備えたマイクロサービス アプリケーション プラットフォームが必要です。</p>


  <p>フル機能のマイクロサービス アプリケーション プラットフォームは、コスト効率、スケーラビリティ、および 24 時間 365 日の可用性という、上記のすべてのマイクロサービス アーキテクチャの利点を提供します。 また、これらの手順をさらに進めも行います。 前述のように、拡張可能な正常性モデルと自動ロールバックを使用して、安全で信頼性の高いアップグレードを振り付ける必要があります。 また、マイクロサービスは、名前付けサービスを提供して互いを検出し、正常性を監視および維持するのにも役立ちます。 たとえば、スケーリングまたは回復の場合、マイクロサービス プラットフォームは、通信を迅速に確立または再確立できるよう、更新された配置情報を名前付けサービスを介して他のマイクロサービスに伝達します。</p>


  <p>マイクロサービスを正常な状態に保つために、実行中のソフトウェアまたはハードウェアで障害が発生した場合、またはアップグレードのために再起動する必要がある場合、プラットフォームはインスタンスを正常な VM またはサーバーに自動的に移動します。 さらに、マイクロサービス プラットフォームは、プライベート クラウドとパブリック クラウドにデプロイ可能である必要があります。 これは、ワークロードがプライベート クラウドからパブリック クラウドにバーストするハイブリッド シナリオをサポートし、プライベート クラウドでの実稼働デプロイによるパブリック クラウド開発/テストを有効にするには必要です。 複数のクラウドをサポートすると、アプリケーション プラットフォームを選択する際のベンダー ロックインに関する懸念にも対応し、プラットフォームをインフラストラクチャから分離します。</p>


  <p>&nbsp;</p>


  <p style="margin-left: 120px;"><img alt="Microservices platform" border="0" height="364" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/eb5cdd36-4b0e-45be-97a3-827871519e15.png" style="border-image: none; padding-top: 0px; padding-right: 0px; padding-left: 0px; display: inline; background-image: none;" title="マイクロサービス プラットフォーム" width="480"></p>


  <p style="margin-left: 240px;"><em>図 5。マイクロサービス プラットフォーム</em></p>


  <p>このセクションでは、開発者が現在マイクロサービス アプリケーションを構築およびデプロイしているいくつかの一般的なプラットフォームについて簡単に説明します。 以下のすべては Azure インフラストラクチャで実行できます。要件に基づいて選択できます。</p>


  <h4>Docker Swarm と Docker Compose</h4>


  <p>Docker コンテナーの標準的なパッケージ形式とリソースの分離により、マイクロサービス アーキテクチャに自然に適合しています。 Docker Composeは、複数の Docker パッケージ マイクロサービスをサポートするアプリケーション モデルを定義し、 <a href="https://www.docker.com/products/docker-swarm">Docker Swarm</a> は、単一ノードの Docker インストールと同じプロトコルを公開する一連のインフラストラクチャ全体でクラスター マネージャーとして機能し、広範な Docker ツール エコシステムで動作します。 このAzure Container Service Docker Swarm と Docker Compose の両方がサポートDocker Compose。 Azure でこれを実行する詳細については、こちらを参照 <a href="https://azure.microsoft.com/en-us/documentation/templates/101-acs-swarm/">してください</a>。</p>


  <h4>Kubernetes</h4>


  <p>Kubernetes は、コンテナー化されたアプリケーションのデプロイ、操作、スケーリングを自動化するオープンソース システムです。 アプリケーションを構成するコンテナーが論理ユニットにグループ化され、管理と検出が容易になります。 もともと Google によって開発されたこのサービスは、Search や Gmail などの大規模なサービスを実行するエクスペリエンスを基に構築されています。 一部の従来の PaaS ソリューションでも、Apprenda のような Kubernetes <a href="https://apprenda.com/blog/apprenda-kubernetes/">とマージされています</a>。 Azure で Kubernetes を実行する方法の詳細については、こちらを参照 <a href="https://kubernetes.io/docs/getting-started-guides/coreos/azure/">してください</a>。</p>


  <h4>Mesosphere DCOS(Apache Mesos と Marathon を使用)</h4>


  <p>Microsoft と Mesosphere は、Apache Mesos や Marathon を含む <a href="https://mesosphere.com/">Mesosphere Datacenter Operating System (DCOS</a> ) のオープン ソース コンポーネントを Azure に導入するために提携しています。 Mesos を搭載した Mesosphere DCOS は、実稼働レベルのコンテナー オーケストレーション ツールである Mesospheres&rsquo; Marathon を含むスケーラブルなクラスター マネージャーです。 これは、アプリケーションの一 <a href="https://azure.microsoft.com/en-us/services/container-service/">部としてAzure Container Service</a>。 Azure で実行される Mesosphere から利用できるエンタープライズ バージョンもあります。 Mesosphere DCOS は、サービスの検出、負荷分散、正常性チェック、配置の制約、メトリックの集計などのマイクロサービス プラットフォーム機能を提供します。 最後に、Mesosphere には、Kafka、Chronos、Cassandra、Spark など、1 つのコマンドでインストールできる追加機能を提供する認定サービスのライブラリが用意されています。 Azure でこれを実行する詳細については、こちらを参照 <a href="https://azure.microsoft.com/en-us/documentation/articles/container-service-deployment/" target="_blank">してください</a>。</p>


  <h4>OpenShift</h4>


  <p><a href="https://www.openshift.com/">OpenShift</a> by Red Hat は、Docker コンテナーベースのパッケージ化を利用して Kubernetes のコンテナー オーケストレーションおよびコンピューティング管理機能をデプロイするサービスとしてのプラットフォームです。ユーザーは、コンテナー化された JBoss ミドルウェア、複数のプログラミング言語、データベース、その他のアプリケーション ランタイムを実行できます。 OpenShift Enterprise 3 では、開発者がセキュリティで保護されたエンタープライズ レベルのアプリケーション インフラストラクチャ内でアプリケーションのビルドとデプロイプロセスを自動化できる devops エクスペリエンスが提供されています。 Azure での Red Hat Enterprise Linux イメージの最近のサポートでは、OpenShift は Azure でサポートされています。 このトピックに関するドキュメントを探してください。</p>


  <h4>Pivotal Cloud Foundry</h4>


  <p><a href="https://pivotal.io/platform">Pivotal Cloud Foundry </a>では、Cloud Foundry のワークフローとコンテナーのスケジューリングと、サービス検出、クライアント側の負荷分散、サーキット ブレーカー、分散トレースなどのマイクロサービス パターンの統合を組み合わせて、Spring Cloud と NetflixOSS を利用することで、マイクロサービス アーキテクチャを実現します。 Pivotal Cloud Foundryは、自動スケール、ブルーグリーン更新、正常性監視、アプリケーション メトリック、ストリーミング ログなどのデプロイおよびサービス管理機能を使用して、継続的なマイクロサービス操作をサポートします。 Azure での Pivotal Cloud Foundry実行の詳細については、こちらを <a href="https://azure.microsoft.com/en-us/blog/general-availability-of-cloud-foundry-and-preview-access-of-pivotal-cloud-foundry/">参照してください</a>。</p>


  <h4>Service Fabric</h4>


  <p>オンプレミスからクラウド、モノリシックからマイクロサービスベースのアプリケーションへの独自の内部進化をサポートするために、10 年以上前にService Fabricを開発しました。 Service Fabric、SQL DB、DocDB、Intune、Cortana、Skype for Business など、多くのハイパースケール クラウド サービスと、多くの内部 Azure インフラストラクチャ サービスに電力を供給します。 &rsquo;まったく同じテクノロジを採用し、Azure で Service Fabric as-a-service をリリースしました。スタンドアロン SDK を使用すると、オンプレミスクラスターや他のクラウドに Service Fabric アプリケーションをデプロイできます。 最初のパブリック リリースでは、Service Fabric .NET Windows、Linux および Java のサポートが開発中です。 Service Fabricには、ライフサイクル管理、ハイブリッド デプロイ、および 24 時間 365 日の可用性に対する組み込みサポートと、Visual Studio を使用した統合開発エクスペリエンスがあります。 このプラットフォームは、インフラストラクチャとマイクロサービスの両方に対して拡張可能な正常性モデルを提供し、正常性ベースの自動アップグレードと自動ロールバックを可能にし、アプリケーションのDevOps。 さらに、Service Fabricは、ステートレスマイクロサービスとステートフル マイクロサービスの両方をサポートし、データの整合性をサポートするリーダーの選択と、ステートフル なデータ保証のためのトランザクションをサポートする状態レプリケーション フレームワークをサポートします。 Azure でこれを実行する詳細については、こちらを参照 <a href="https://azure.microsoft.com/en-us/services/service-fabric/">してください</a>。</p>


  <h2>まとめ</h2>


  <p>クラウドの出現により、コンピューティングの世界はいつまでも変わりました。 クラウドを使用すると、開発者はインフラストラクチャに瞬時に、安価に、ほぼ無限のスケールでアクセスできます。 クラウドの機敏性と、最新のビジネスの高可用性と一定の機敏性の要求により、モノリシック アーキテクチャに負担が生じ、マイクロサービスベースのアプリケーションが増加しました。 包括的なマイクロサービス プラットフォームを使用すると、開発者は、パブリック クラウドとプライベート クラウド全体で、高パフォーマンス、高可用性、コスト効率、独立したライフサイクル管理を備える大規模なアプリケーションを作成できます。 マイクロサービスは、クラウドを利用したアプリケーションの変革です。</p>


  <p>以下のビデオをご覧ください。Channel9s&rsquo; Seth Jua込みでマイクロサービスについて説明します。</p>


  <p><iframe allowfullscreen="" frameborder="0" height="315" src="https://channel9.msdn.com/Blogs/Seth-Juarez/An-Introduction-to-Microservices-with-Mark-Russinovich/player" width="560"></iframe></p>
