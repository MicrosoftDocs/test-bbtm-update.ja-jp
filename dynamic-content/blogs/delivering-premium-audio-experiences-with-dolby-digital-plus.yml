### YamlMime:Yaml
ms.openlocfilehash: c4c0f6e25c45c7c1a2b827df37e53aae2205e213
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139891095"
Slug: delivering-premium-audio-experiences-with-dolby-digital-plus
Title: Dolby Digital Plus プレミアムオーディオ エクスペリエンスの®提供
Summary: Azure Media Encoder を使用して Dolby® Digital Plus マルチチャネル サラウンド サウンドでコンテンツをエンコードし、スマートテレビ、Xbox、Windows 8 デバイス、モバイル デバイスなど、複数のプラットフォームに配信する方法について説明します。
Content: "メディアを使用するデバイスが急増する中、ビデオ ストリーミング サービスでは、ユーザーに優れたオーディオ品質を提供し、5.1 のサラウンド サウンドでプレミアム コンテンツを配信する必要性が高まっています。 Azure Media Services を使用して、Dolby® Digital Plus マルチチャネル サラウンド サウンドを使用して HD コンテンツをエンコードできます。スマートテレビ、Xbox、Windows 8 デバイス、モバイル デバイスなど、複数のプラットフォームで使用できます。\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/08/Dolby_linear_Black.jpg\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border: 0px\" title=\"Dolby_linear_Black\" alt=\"Dolby_linear_Black\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/Dolby_linear_Black_thumb.jpg\" width=\"360\" height=\"147\" border=\"0\" /></a>\n\nDolby® Digital Plus または Enhanced AC-3 (E-AC-3) は、高品質のオーディオ用に設計された高度なサラウンド サウンド オーディオ コーデックです。 このコーデックは、コア Dolby Digital テクノロジに基づいており、2.1 B を超える製品でサポートされています。 このブログでは、このコーデックを使用して、Media Servicesを使用してコンテンツで Premium オーディオ エクスペリエンスを提供する方法について説明します。\n<h1>概要</h1>\nこの例では、Dolby Digital Plus へのエンコードに®関連する手順を次に示します。\n<ol>\n <li>アップロードソース コンテンツを Azure Media Servicesアカウントに追加し、資産を作成する</li>\n <li>カスタム エンコード プリセットをビルドし、ファイルに保存する</li>\n <li>カスタム プリセットを使用して上記の資産をエンコードするタスクを送信する</li>\n <li>出力アセットを発行し、SAS URL を作成する</li>\n <li>アプリケーションでの再生のデモンストレーション</li>\n</ol>\n最初に、これらの各手順について説明し、使用したサンプル コードを指定します。\n\nサンプル コードを実行すると、H.264 ビデオと Dolby Digital Plus オーディオを含む標準 MP4 ファイルの URL が表示されます。 その後、この URL を使用して、Dolby Digital Plus デコードをサポートするデバイスでストリームを再生できます。 Windows 8 Xbox には Dolby Digital Plus デコーダーが組み込みですが、Apple デバイスでは現在、このコーデックはネイティブにサポートされていません。私の推奨事項は、Windows 8 と Player Framework を使用して、サラウンド サウンド デコードをテストする方法に関するガイダンスに従う方法です。フル サラウンド サウンドサウンドのファイルを聞く場合は、5.1 再生が可能な AV レシーバーに接続された PC が必要です。\n<h1>ソース コンテンツのアップロード</h1>\n最初に、HD ビデオとマルチチャネル オーディオを含むソース コンテンツを Media Service アカウントにアップロードする必要があります。 次のファイル形式をお勧めします。\n<ul>\n <li>MPEG-2 AC-3 (Dolby Digital とも呼ばれる) でエンコードされた 5.1 オーディオを含むトランスポート ストリーム®</li>\n <li>AAC でエンコードされた 5.1 オーディオを含む ISO MPEG-4 (MP4) ファイル</li>\n <li>WMA でエンコードされた 5.1 オーディオを含む WMV Professional</li>\n</ul>\nソース <span style=\"font-family: Courier New\">ファイルをアップロードするサンプル コードについては、「CreateAssetAndUploadSingleFile</span>()」を参照してください。\n<h1>カスタム プリセットを作成する</h1>\nカスタム プリセットを初めて作成する場合は、前の「高度なエンコード機能」の投稿でカスタム プリセットを作成する方法の詳細を確認してください。\n\n次に、720p ビデオが 4.5 Mbps でエンコードされ、5.1 チャネルの Dolby Digital Plus オーディオが 512 kbps の MP4 ファイルにソースをトランスコードするカスタム プリセットについて説明します。 このカスタム プリセットは、\"<a href=\"https://msdn.microsoft.com/en-us/library/dn619402.aspx\">H264 Broadband 720p</a>\" プリセットに基づいて作成されます。 この <strong>&lt;プリセットの AudioProfile&gt;</strong> セクションは、 <a href=\"https://msdn.microsoft.com/en-us/library/dn296427.aspx\">Dolby Digital Plus 設定を使用するために変更されました</a>。\n<blockquote>注: この例のように、512 kbps より低いビットレートの使用など、オーディオ エンコード設定を調整する方法の詳細については、以下を参照してください。 <a href=\"https://msdn.microsoft.com/en-us/library/dn296500.aspx\">https://msdn.microsoft.com/en-us/library/dn296500.aspx</a></blockquote>\n完成した XML カスタム プリセットは次のとおりです。エンコードで使用するには、ローカル ファイルに保存する必要があります。 \"Dolby Audio Preset.xml\" という名前を使用しました。\n<pre class=\"prettyprint\">&lt;?xml version=\"1.0\" encoding=\"utf-16\"?&gt;\n&lt;Presets&gt;\n &lt;Preset\n   Version=\"5.0\"&gt;\n   &lt;MediaFile\n     DeinterlaceMode=\"AutoPixelAdaptive\"\n     ResizeQuality=\"Super\"\n     VideoResizeMode=\"Stretch\"&gt;\n     &lt;OutputFormat&gt;\n       &lt;MP4OutputFormat\n         StreamCompatibility=\"Standard\"&gt;\n         &lt;VideoProfile&gt;\n           &lt;MainH264VideoProfile\n             BFrameCount=\"3\"\n             EntropyMode=\"Cabac\"\n             RDOptimizationMode=\"Speed\"\n             HadamardTransform=\"False\"\n             SubBlockMotionSearchMode=\"Speed\"\n             MultiReferenceMotionSearchMode=\"Balanced\"\n             ReferenceBFrames=\"False\"\n             AdaptiveBFrames=\"True\"\n             SceneChangeDetector=\"True\"\n             FastIntraDecisions=\"False\"\n             FastInterDecisions=\"False\"\n             SubPixelMode=\"Quarter\"\n             SliceCount=\"0\"\n             KeyFrameDistance=\"00:00:02\"\n             InLoopFilter=\"True\"\n             MEPartitionLevel=\"EightByEight\"\n             ReferenceFrames=\"4\"\n             SearchRange=\"64\"\n             AutoFit=\"True\"\n             Force16Pixels=\"False\"\n             FrameRate=\"0\"\n             SeparateFilesPerStream=\"True\"\n             SmoothStreaming=\"False\"\n             NumberOfEncoderThreads=\"0\"&gt;\n             &lt;Streams\n               AutoSize=\"False\"\n               FreezeSort=\"False\"&gt;\n               &lt;StreamInfo\n                 Size=\"1280, 720\"&gt;\n                 &lt;Bitrate&gt;\n                   &lt;ConstantBitrate\n                     Bitrate=\"4500\"\n                     IsTwoPass=\"False\"\n                     BufferWindow=\"00:00:05\" /&gt;\n                 &lt;/Bitrate&gt;\n               &lt;/StreamInfo&gt;\n             &lt;/Streams&gt;\n           &lt;/MainH264VideoProfile&gt;\n         &lt;/VideoProfile&gt;\n          &lt;AudioProfile&gt;\n            &lt;DolbyDigitalPlusAudioProfile\n              Codec=\"DolbyDigitalPlus\"\n              EncoderMode=\"DolbyDigitalPlus\"\n              AudioCodingMode=\"Mode32\"\n              LFEOn=\"True\"\n              SamplesPerSecond=\"48000\"\n              BandwidthLimitingLowpassFilter=\"True\"\n              DialogNormalization=\"-31\"&gt;\n              &lt;Bitrate&gt;\n                &lt;ConstantBitrate\n                  Bitrate=\"512\"\n                  IsTwoPass=\"False\"\n                  BufferWindow=\"00:00:00\" /&gt;\n              &lt;/Bitrate&gt;\n            &lt;/DolbyDigitalPlusAudioProfile&gt;\n\n          &lt;/AudioProfile&gt;  \n\n       &lt;/MP4OutputFormat&gt;\n     &lt;/OutputFormat&gt;\n   &lt;/MediaFile&gt;\n &lt;/Preset&gt;\n&lt;/Presets&gt;</pre>\n<h1>ソース コンテンツをトランスコードする</h1>\nカスタム プリセットの内容を構成文字列としてタスクに渡Windows Azure Media Encoderを使用して、ソース コンテンツをトランスコードできます。 関連する  <span style=\"font-family: Courier New\">手順については、</span>以下のサンプル コードのTranscode() メソッドを参照してください。 タスクの結果、出力アセットには、Dolby Digital Plus オーディオが H.264 でエンコードされたビデオとインターリーブされた MP4 ファイルが含まれるものになります。\n<h1>出力資産を発行する</h1>\nコンテンツがトランスコードされた後は、出力アセットの SAS ロケーターを作成できます。 関連 <span style=\"font-family: Courier New\">する手順については、以下のサンプル コードの CreateSASLocator</span>() を参照してください。 SAS URI は、プレーヤー アプリケーションに渡されます。\n<h1>サンプル コード</h1>\nこのトピックのコードでは、.<a href=\"https://www.nuget.org/packages/windowsazure.mediaservices.extensions\">NET SDK 拡張機能Azure Media Services使用</a>します。Media Services .NET SDK Extensions は、コードを簡略化し、Media Services を使った開発を容易にする拡張メソッドとヘルパー関数のセットです。\n\nサンプル App.Configのファイルは次のようになります。\n<pre class=\"prettyprint\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;configuration&gt;\n  &lt;startup&gt;\n    &lt;supportedRuntime version=\"v4.0\" sku=\".NETFramework,Version=v4.5\" /&gt;\n  &lt;/startup&gt;\n  &lt;appSettings&gt;\n    &lt;add key=\"MediaServicesAccountName\" value=\"&lt;MediaAccountName&gt;\" /&gt;\n    &lt;add key=\"MediaServicesAccountKey\" value=\"&lt;MediaAccountKey&gt;\" /&gt;\n  &lt;/appSettings&gt;\n  &lt;runtime&gt;\n    &lt;assemblyBinding xmlns=\"urn:schemas-microsoft-com:asm.v1\"&gt;\n      &lt;dependentAssembly&gt;\n        &lt;assemblyIdentity name=\"Microsoft.WindowsAzure.Storage\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" /&gt;\n        &lt;bindingRedirect oldVersion=\"0.0.0.0-4.1.0.0\" newVersion=\"4.1.0.0\" /&gt;\n      &lt;/dependentAssembly&gt;\n    &lt;/assemblyBinding&gt;\n  &lt;/runtime&gt;</pre>\n上記の手順でApp.Config <strong>&lt;MediaAccountName&gt;</strong><strong> &lt;と MediaAccountKey&gt;</strong> を実際のアカウント名Media Servicesキーに置き換える必要があります。\n\nさらに、Dolby によって提供される短い映画 \"Silent\" の次のサンプル 5.1 サラウンド サウンド ファイルを使用しました。\nここでソース MP4 ファイルをダウンロードして、独自のテストで使用できます。\n\n<a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/Silent.jpg\"><img class=\"size-full wp-image-183481\" alt=\"Silent from Dolby\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/Silent.jpg\" width=\"400\" height=\"168\" /></a>\n\n(©Dolby - Dolby のサイレント提供)\n\n使用されるサンプル コードは次のとおりです。\n<pre class=\"prettyprint\">using System;\nusing System.Linq;\nusing System.Configuration;\nusing System.IO;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Globalization;\nusing Microsoft.WindowsAzure;\nusing Microsoft.WindowsAzure.MediaServices.Client;\n\nnamespace DeliveringPremiumAudio\n{\n    /// &lt;summary&gt;\n    /// \n    /// &lt;/summary&gt;\n    class Program\n    {\n        // Read values from the App.config file.\n        private static readonly string _mediaServicesAccountName =\n            ConfigurationManager.AppSettings[\"MediaServicesAccountName\"];\n        private static readonly string _mediaServicesAccountKey =\n            ConfigurationManager.AppSettings[\"MediaServicesAccountKey\"];\n        private static readonly string _storageConnectionString =\n            ConfigurationManager.AppSettings[\"StorageConnectionString\"];\n\n        private static CloudMediaContext _context = null;\n        private static MediaServicesCredentials _cachedCredentials = null;\n\n        // Pointers to sample file, and the saved custom preset XML\n        private static readonly string _sampleFile = @\"C:\\temp\\sintel.wmv\";\n        private static readonly string _customPreset = @\"C:\\temp\\Dolby Audio Preset.xml\";\n\n        static void Main(string[] args)\n        {\n            try\n            {\n                // Create and cache the Media Services credentials in a static class variable\n                _cachedCredentials = new MediaServicesCredentials(_mediaServicesAccountName, _mediaServicesAccountKey);\n\n                // Used the cached credentials to create the CloudMediaContext\n                _context = new CloudMediaContext(_cachedCredentials);\n\n                // Step 1. Upload the sample content and create an Asset\n                IAsset inputAsset = CreateAssetAndUploadSingleFile(AssetCreationOptions.None, _sampleFile);\n\n                // Step 2. Load the custom preset into a configuration string\n                string configuration = File.ReadAllText(_customPreset);\n\n                // Step 3. Transcode the input\n                IAsset outputAsset = Transcode(inputAsset, configuration);\n\n                // Step 4. Create a SAS locator for the output asset and print to console\n                if (null != outputAsset) CreateSASLocator(outputAsset);\n\n                // The above method creates a locator valid for 30 days\n                // You should consider deleting the locator after the tests are complete\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// This function creates an empty Asset\n        /// &lt;/summary&gt;\n        static private IAsset CreateEmptyAsset(string assetName, AssetCreationOptions assetCreationOptions)\n        {\n            var asset = _context.Assets.Create(assetName, assetCreationOptions);\n            Console.WriteLine(\"Asset name: \" + asset.Name);\n            Console.WriteLine(\"Time created: \" + asset.Created.Date.ToString());\n\n            return asset;\n        }\n\n        /// &lt;summary&gt;\n        /// This function creates an Asset and uploads the input file to it\n        /// &lt;/summary&gt;\n        static public IAsset CreateAssetAndUploadSingleFile(AssetCreationOptions assetCreationOptions, string singleFilePath)\n        {\n            var fileName = Path.GetFileName(singleFilePath);\n            // Create a unique asset name\n            var assetName = fileName + DateTime.UtcNow.ToString();\n            var asset = CreateEmptyAsset(assetName, assetCreationOptions);\n\n            var assetFile = asset.AssetFiles.Create(fileName);\n            Console.WriteLine(\"Created assetFile {0}\", assetFile.Name);\n\n            // In order to upload the file, we need a locator with the appropriate access policy\n            var accessPolicy = _context.AccessPolicies.Create(assetName, TimeSpan.FromDays(30),\n                                                                AccessPermissions.Write | AccessPermissions.List);\n            var locator = _context.Locators.CreateLocator(LocatorType.Sas, asset, accessPolicy);\n\n            assetFile.Upload(singleFilePath);\n            Console.WriteLine(\"Done uploading {0}\", assetFile.Name);\n            Console.WriteLine(\"\");\n            long size = assetFile.ContentFileSize;\n\n            locator.Delete();\n            accessPolicy.Delete();\n\n            return asset;\n        }\n\n        /// &lt;summary&gt;\n        /// This function transcodes the source Asset using the preset provided, and return the output Asset\n        /// &lt;/summary&gt;\n        static public IAsset Transcode(IAsset sourceAsset, string preset)\n        {\n            // Declare a new job.\n            IJob job = _context.Jobs.Create(\"Transcoding Job for \" + sourceAsset.Name);\n            // Get a reference to Windows Azure Media Encoder, and pass to it the name of the \n            // processor to use for the specific task.\n            IMediaProcessor processor = GetLatestMediaProcessorByName(\"Windows Azure Media Encoder\");\n\n            // Create a task with the encoding details, using a string preset.\n            ITask task = job.Tasks.AddNew(\"Transcoding Task for \" + sourceAsset.Name,\n                processor,\n                preset,\n                Microsoft.WindowsAzure.MediaServices.Client.TaskOptions.None);\n\n            // Specify the source asset to be encoded.\n            task.InputAssets.Add(sourceAsset);\n            // Add an output asset to contain the results of the job. \n            // This output is specified as AssetCreationOptions.None, which \n            // means the output asset is not encrypted. \n            task.OutputAssets.AddNew(\"Output asset\", AssetCreationOptions.None);\n\n            // Use the following event handler to check job progress.  \n            job.StateChanged += new\n                    EventHandler&lt;JobStateChangedEventArgs&gt;(StateChanged);\n\n            // Launch the job.\n            job.Submit();\n\n            // Check job execution and wait for job to finish. \n            Task progressJobTask = job.GetExecutionProgressTask(CancellationToken.None);\n            progressJobTask.Wait();\n\n            // Get an updated job reference.\n            job = GetJob(job.Id);\n\n            // If job state is Error the event handling \n            // method for job progress should log errors.  Here we check \n            // for error state and exit if needed.\n            if (job.State == JobState.Error)\n            {\n                Console.WriteLine(\"Transcode() failed, exiting...\");\n                return null;\n            }\n\n            // Get a reference to the output asset from the job.\n            IAsset outAsset = job.OutputMediaAssets[0];\n\n            return outAsset;\n        }\n\n        /// &lt;summary&gt;\n        /// This function returns a reference to the latest version of the specified media processor\n        /// &lt;/summary&gt;\n        private static IMediaProcessor GetLatestMediaProcessorByName(string mediaProcessorName)\n        {\n            var processor = _context.MediaProcessors.Where(p =&gt; p.Name == mediaProcessorName).\n                ToList().OrderBy(p =&gt; new Version(p.Version)).LastOrDefault();\n\n            if (processor == null)\n                throw new ArgumentException(string.Format(\"Unknown media processor\", mediaProcessorName));\n\n            return processor;\n        }\n\n        /// &lt;summary&gt;\n        /// A helper method to handle events\n        /// &lt;/summary&gt;\n        private static void StateChanged(object sender, JobStateChangedEventArgs e)\n        {\n            Console.WriteLine(\"Job state changed event:\");\n            Console.WriteLine(\"  Previous state: \" + e.PreviousState);\n            Console.WriteLine(\"  Current state: \" + e.CurrentState);\n\n            switch (e.CurrentState)\n            {\n                case JobState.Finished:\n                    Console.WriteLine();\n                    Console.WriteLine(\"********************\");\n                    Console.WriteLine(\"Job is finished.\");\n                    Console.WriteLine(\"Please wait while local tasks or downloads complete...\");\n                    Console.WriteLine(\"********************\");\n                    Console.WriteLine();\n                    Console.WriteLine();\n                    break;\n                case JobState.Canceling:\n                case JobState.Queued:\n                case JobState.Scheduled:\n                case JobState.Processing:\n                    Console.WriteLine(\"Please wait...\\n\");\n                    break;\n                case JobState.Canceled:\n                case JobState.Error:\n                    // Cast sender as a job.\n                    IJob job = (IJob)sender;\n                    // Display or log error details as needed.\n                    LogJobStop(job.Id);\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// A helper method to log information about a failed Job\n        /// &lt;/summary&gt;\n        private static void LogJobStop(string jobId)\n        {\n            StringBuilder builder = new StringBuilder();\n            IJob job = GetJob(jobId);\n\n            builder.AppendLine(\"\\nThe job stopped due to cancellation or an error.\");\n            builder.AppendLine(\"***************************\");\n            builder.AppendLine(\"Job ID: \" + job.Id);\n            builder.AppendLine(\"Job Name: \" + job.Name);\n            builder.AppendLine(\"Job State: \" + job.State.ToString());\n            builder.AppendLine(\"Job started (server UTC time): \" + job.StartTime.ToString());\n            // Log job errors if they exist.  \n            if (job.State == JobState.Error)\n            {\n                builder.Append(\"Error Details: \\n\");\n                foreach (ITask task in job.Tasks)\n                {\n                    foreach (ErrorDetail detail in task.ErrorDetails)\n                    {\n                        builder.AppendLine(\"  Task Id: \" + task.Id);\n                        builder.AppendLine(\"    Error Code: \" + detail.Code);\n                        builder.AppendLine(\"    Error Message: \" + detail.Message + \"\\n\");\n                    }\n                }\n            }\n            builder.AppendLine(\"***************************\\n\");\n            Console.Write(builder.ToString());\n        }\n\n        /// &lt;summary&gt;\n        /// This function creates a SAS locator for the given Asset\n        /// &lt;/summary&gt;\n        private static void CreateSASLocator(IAsset asset)\n        {\n            Console.WriteLine(\"Publishing asset \" + asset.Name);\n            // Publish the output asset by creating an Origin locator.  \n            // Define the Read only access policy and\n            // specify that the asset can be accessed for 30 days.  \n            _context.Locators.Create(\n                LocatorType.Sas,\n                asset,\n                AccessPermissions.Read,\n                TimeSpan.FromDays(30));\n\n            // Generate a SAS Locator for the MP4 file.\n            var mp4AssetFile = asset.AssetFiles.ToList().Where(f =&gt; f.Name.EndsWith(\".mp4\", StringComparison.OrdinalIgnoreCase)).FirstOrDefault();\n            Uri mp4Uri = mp4AssetFile.GetSasUri();\n            Console.WriteLine(\"Output is now available for progressive download: \");\n            Console.WriteLine(mp4Uri.OriginalString);\n\n            return;\n        }\n    }\n}</pre>\n<h1></h1>\n<h1>再生デモ</h1>\n再生を示す簡単な方法は、Windows 8.1 で Windows Media Player アプリケーションを起動し、File\\Open URL に移動して、エンコードされた資産への SAS ロケーターに「」と入力することです。\nPC を 5.1 再生可能な AV レシーバーに接続している場合は、完全な 5.1 サラウンドで出力を聞き取る可能性があります。\n\nエンコード ジョブサンプルの出力は、こちらからダウンロードできます。\n<h1>考慮事項</h1>\n<h2>ステレオ オーディオを使用したコンテンツのエンコード</h2>\n入力アセットにステレオ オーディオがある場合、Azure Media Encoderチャネルに無音が挿入されます。出力アセットには 5.1 オーディオが残っています。 無音の挿入は、出力コンテンツを配信する場合にのみ、Smooth Streaming。\n\nまたは、「<a href=\"https://msdn.microsoft.com/en-us/library/dn296428.aspx\"></a>Dolby Digital Plus Stereo へのエンコード」の XML に記載されている設定を使用して、<strong>DolbyDigitalPlusAudioProfile&gt; 要素を変更してステレオ出力にエンコードすることもできます。&lt;</strong>\n<h2>デバイス経由で Dolby Digital Plus オーディオをストリーミングSmooth Streaming</h2>\nDolby Digital Plus オーディオは、Windows 8.1 上の最新のアプリケーションに配信したり、Xbox One経由Smooth Streaming。 これを行うには、次のようにサンプル コードを変更する必要があります。\n<ul>\n <li>この例<strong>の&lt;カスタム プリセットの VideoProfile を、\"H264 Adaptive Bitrate MP4 Set 720p\" プリセットの VideoProfile&gt;</strong> に置き換える<a href=\"https://msdn.microsoft.com/en-us/library/dn619413.aspx\"></a></li>\n <li>SAS URL を作成する代わりに、.NET SDK 拡張機能で使用できる <span style=\"font-family: Courier New\">GetSmoothStreamingUri</span>() ヘルパー メソッドAzure Media Services<a href=\"https://www.nuget.org/packages/windowsazure.mediaservices.extensions\">使用します</a></li>\n</ul>\n次に、Windows 8 Smooth Streaming Client SDK for Windows 8 を使用して、Modern アプリケーションをビルドする必要Windows 8。dolby コンテンツを再生する Smooth Streaming Client SDK を使用してアプリケーションをビルドする方法の詳細については、「Smooth Streaming Windows Store アプリケーションをビルドする方法」<a href=\"https://azure.microsoft.com/en-us/documentation/articles/media-services-build-smooth-streaming-apps/\" target=\"_blank\">を</a>参照してください。\n\nDolby デコーダーは、現在、すべてのプラットフォーム (Apple iOS など) では使用できませんが、セット トップ ボックスやスマートテレビなどのデバイスでの Dolby のデコードをサポートする他の多くのクライアント フレームワークが市場に出回っています。 他のデバイスにアクセスしようとしている場合は、サポートされているデコーダーを製造元に確認する必要があります。\n<h2>Dolby Professional測定の有効化</h2>\n以前は、マルチチャネル オーディオを使用するブロードキャスト担当者は、平均レベルが他のプログラミングのレベルを上回る、または下回るという問題がありました。 プログラムがブレーク中に本当に大きなコマーシャルに切り替えたときに、自分でこれを経験した可能性があります。また、ステレオまたはモノラルオーディオ出力を備えたテレビ セットでサラウンド サウンド コンテンツが再生された場合にも問題が発生します。Dolby のこの<a href=\"https://www.dolby.com/uploadedFiles/Assets/US/Doc/Professional/17_.AllMetadata.pdf\"></a>レポートで説明したように、マルチチャネル オーディオを使用する場合の一般的な問題は、異なるプログラム間で一貫した音量を維持しています。 この問題に対処するには、Dolby Digital Plus ストリーム内でダイアログ レベル パラメーター (ダイアログ正規化または DialNorm) を指定する方法をお勧めします。 この値は、オーディオの音量をプリセット レベルに設定します。これにより、あるプログラムから別のプログラムへのレベル マッチングでデコーダーが支援され、問題のボリュームの変更が解消されます。\n\n上記のプリセットでは、ソース コンテンツの既定のダイアログ正規化値 -31 dB が想定されています。ソース コンテンツでダイアログの実際の音量を測定し、ダイアログの正規化に正しい値を設定する方法については、「<a href=\"https://msdn.microsoft.com/en-us/library/dn296426.aspx\">Dolby Professional Loudness Metering (DPLM)</a> サポートの使用」というタイトルのセクションを参照してください。\n\nDolby Digital Plus テクノロジの詳細については、この Dolby ページでパートナーから提供される詳細 <a href=\"https://www.dolby.com/us/en/technologies/dolby-digital-plus.html\">を確認してください</a>。"
