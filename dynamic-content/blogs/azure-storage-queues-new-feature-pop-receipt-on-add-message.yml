### YamlMime:Yaml
ms.openlocfilehash: a251b28a71dc4587546c359b24122bcff30a8649
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139896500"
Slug: azure-storage-queues-new-feature-pop-receipt-on-add-message
Title: 'Azure Storage キューの新機能: Pop-Receipt メッセージの追加'
Summary: Azure Storage キューでのメッセージの追加機能に関する popreceipt 書の発表
Content: "<p><a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/versioning-for-the-azure-storage-services\">2016-05-31 &rdquo; REST API バージョンの &ldquo; </a>一部として、ユーザーによって一般的に要求された機能であるメッセージの追加機能に対して、pop 確認メッセージが導入されました。</p>\n\n<p>Queue サービスの Pop 確認機能は、キューに入っているメッセージをさらに処理するために、開発者が簡単に識別できる優れたツールです。 &ldquo;2016-05-31 &rdquo; バージョンより前では、ユーザーが &nbsp; キューからメッセージを取得した場合にのみ、ポップ通知値を取得できました。 これを簡単にするために、メッセージを最初に取得しなくてもメッセージを更新または削除できるように、Put メッセージ (別名メッセージの追加) の応答でポップ受信の値を使用できるようになりました。</p>\n\n<p>.net 用 Azure Storage クライアントライブラリ8.0 を使用してこの新機能を利用する短いコードスニペットを以下に示します。</p>\n\n<pre class=\"prettyprint\">\n// create initial message\nCloudQueueMessage message = new CloudQueueMessage(&quot;<task id=\"123\" status=\"0\">&quot;);\n\n// add the message to the queue, but keep it hidden for 3 min\nqueue.AddMessage(message, null, TimeSpan.FromSeconds(180));\n//message.PopReceipt is now populated, and only this client can operate on the message until visibility timeout expires\n.\n.\n.\n// update the message (now no need to receive the message first, since we already have a PopReceipt for the message)\nmessage.SetMessageContent(&quot;<task id=\"123\" status=\"1\">&quot;);\nqueue.UpdateMessage(message, TimeSpan.FromSeconds(180), MessageUpdateFields.Content | MessageUpdateFields.Visibility);\n\n// remove the message using the PopReceipt before any other process sees it\nawait queue.DeleteMessageAsync(message.Id, message.PopReceipt);\n</task></task></pre>\n\n<p>クラウドアプリケーションの一般的な問題は、非トランザクションリソース間での更新の調整に役立ちます。 たとえば、イメージまたはビデオを処理するアプリケーションは次のようになります。</p>\n\n<p>1. &nbsp; &nbsp; &nbsp; イメージを処理する<br>\n2. &nbsp; &nbsp; &nbsp; blob にアップロードする<br>\n3. &nbsp; &nbsp; &nbsp; テーブルエンティティにメタデータを保存する</p>\n\n<p>これらの手順は、次のフローを使用してプロセスが正常に完了したときに、Queue サービスを使用して追跡できます。</p>\n\n<p>1. &nbsp; &nbsp; &nbsp; Queue サービスにメッセージとして状態を追加する<br>\n2. &nbsp; &nbsp; &nbsp; イメージを処理する<br>\n3. &nbsp; &nbsp; &nbsp; blob にアップロードする<br>\n4. &nbsp; &nbsp; &nbsp; テーブルエンティティにメタデータを保存する<br>\n5. すべてが成功した場合は、メッセージを削除します。 &nbsp; &nbsp; &nbsp;</p>\n\n<p>キュー内の残りのメッセージは、単に処理できなかった画像であり、クリーンアップのためにワーカーが使用できます。 上記のシナリオは、メッセージの追加機能に対して popreceipt を使用する方が簡単になりました。5番目の手順では、最初の手順で取得した popreceipt の値を使用してメッセージを削除できます。</p>\n\n<h2>Azure Cognitive Services の Face API を使用したクイックサンプル</h2>\n\n<p>次の例では、写真をローカルフォルダーから Blob service にアップロードします。また、Face API を使用して、写真の各 &rsquo; 年齢の年齢を推定し、テーブルにエンティティとして格納します。 このプロセスはキューで追跡され、完了すると、メッセージは pop 受信の値で削除されます。 このサンプルのワークフローは次のとおりです。</p>\n\n<p>1. &nbsp; &nbsp; &nbsp; : testfolder) で JPG ファイルを &lsquo; 検索する&rsquo;<br>\n2. &nbsp; &nbsp; &nbsp; 写真ごとに、手順2-7 を繰り返します。<br>\n3. &nbsp; &nbsp; &nbsp; この写真の処理を表すキューメッセージをアップロードします。 &nbsp;<br>\n4. &nbsp; &nbsp; &nbsp; Face API を呼び出して、写真の各人の年齢を見積もります。<br>\n5. &nbsp; &nbsp; &nbsp; 年齢情報をエンティティとしてテーブルに格納します。<br>\n6. 少なくとも1つの顔が検出された場合は、イメージを blob にアップロードします &nbsp; &nbsp; &nbsp; 。<br>\n7. &nbsp; &nbsp; &nbsp; blob とテーブルエンティティの両方の操作が成功した場合は、pop 確認メッセージを使用してキューからメッセージを削除します。</p>\n\n<pre class=\"prettyprint\">\n// Iterate over photos in &#39;testfolder&#39;\nvar images = Directory.EnumerateFiles(&quot;testfolder&quot;, &quot;*.jpg&quot;);\n\nforeach (string currentFile in images)\n{\n\n    string fileName = currentFile.Replace(&quot;testfolder\\\\&quot;, &quot;&quot;);\n\n    Console.WriteLine(&quot;Processing image {0}&quot;, fileName);\n\n    // Add a message to the queue for each photo. Note the visibility timeout\n    // as blob and table operations in the following process may take up to 180 seconds.\n    // After the 180 seconds, the message will be visible and a worker role can pick up \n    // the message from queue for cleanup. Default time to live for the message is 7 days.\n    CloudQueueMessage message = new CloudQueueMessage(fileName);\n    queue.AddMessage(message, null, TimeSpan.FromSeconds(180));\n\n    // read the file\n    using (var fileStream = File.OpenRead(currentFile))\n    {\n\n        // detect face and estimate the age\n        var faces = await faceClient.DetectAsync(fileStream, false, true, new FaceAttributeType[] { FaceAttributeType.Age });\n        Console.WriteLine(&quot; &gt; &quot; + faces.Length + &quot; face(s) detected.&quot;);\n\n        CloudBlockBlob blob = container.GetBlockBlobReference(fileName);\n\n        var tableEntity = new DynamicTableEntity(DateTime.Now.ToString(&quot;yyMMdd&quot;), fileName);\n\n        // iterate over detected faces\n        int i = 1;\n        foreach (var face in faces)\n        {\n\n            // append the age info as property in the table entity\n            tableEntity.Properties.Add(&quot;person&quot; + i.ToString(), new EntityProperty(face.FaceAttributes.Age.ToString()));\n            i++;\n\n        }\n\n        // upload the blob if a face was detected\n        if (faces.Length &gt; 0)\n            await blob.UploadFromFileAsync(currentFile);\n\n        // store the age info in the table\n        table.Execute(TableOperation.InsertOrReplace(tableEntity));\n\n        // delete the queue message with the pop receipt since previous operations completed successfully\n        await queue.DeleteMessageAsync(message.Id, message.PopReceipt);\n\n    }\n\n}\n</pre>\n\n<p>詳細なサンプルについては、 <a href=\"https://github.com/Azure-Samples/storage-queue-dotnet-pop-receipt\">Github サンプルリポジトリ</a>をご覧ください。</p>\n\n<p>機能に関するご要望がある場合は、ぜひご意見をお寄せください。 <a href=\"https://feedback.azure.com/forums/217298-storage\">Azure Storage フィードバック</a>をお寄せください。</p>"
