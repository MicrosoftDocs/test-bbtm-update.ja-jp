### YamlMime:Yaml
ms.openlocfilehash: a4d1df54dc208284c9a5a7aad3d631eb8f83d7b1
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139903502"
Slug: managing-concurrency-in-microsoft-azure-storage-2
Title: Microsoft Azure Storage でのコンカレンシー制御の管理
Summary: この記事では、これら3つの同時実行戦略すべてに対してファーストクラスのサポートを提供することで、Azure Storage プラットフォームが開発を簡略化する方法の概要を示します。
Content: "最新のインターネットを基盤とするアプリケーションでは、複数のユーザーが同時にデータを表示し、更新することが一般的です。 このような場合、アプリケーション開発者は予測可能なエクスペリエンスをエンド ユーザーに提供する方法を注意深く検討する必要があり、特に複数のユーザーが同じデータを更新できる場合はこれが重要になります。 開発者は、データのコンカレンシー制御の主な戦略として、次の 3 つの方法を検討する場合が一般的です。\n\n<strong>1. オプティミスティック同時実行制御</strong> –更新を実行するアプリケーションは、更新の一部として、アプリケーションが最後にそのデータを読み取った後にデータが変更されたかどうかを確認します。 たとえば、wiki のページを表示している 2 人のユーザーが同じページを更新しようとしている場合、wiki のプラットフォームは、2 番目の更新が最初の更新を上書きせず、両方のユーザーが自身の更新の成否を把握できるようにする必要があります。 この戦略は、Web アプリケーションで最も広く使用されています。\n\n<strong>2. ペシミスティック同時実行制御</strong> –更新を実行するアプリケーションは、オブジェクトをロックして、ロックが解除されるまで他のユーザーがデータを更新できないようにします。 たとえば、マスターとスレーブの間でデータを複製する場合、マスターのみが更新を実行するため、通常は、データを一定期間、排他的にロックして、該当するデータを他から更新できないようにします。\n\n<strong>3. 最後のライター優先</strong> : アプリケーションがデータを最初に読み取った後に他のアプリケーションがデータを更新したかどうかを確認せずに、更新操作を続行できる方法。 この戦略 (つまり正式な戦略を持たない) は、通常、データが分割されており、複数のユーザーが同時に同じデータにアクセスする可能性がほとんどない場合に使用されます。 また、有効期限が短いデータ ストリームの処理にも有効です。\n\nこの記事では、これら3つの同時実行戦略すべてに対してファーストクラスのサポートを提供することで、Azure Storage プラットフォームが開発を簡略化する方法の概要を示します。\n<h3>Azure Storage – クラウド開発を簡素化</h3>\nAzure ストレージ サービスでは、上記 3 つの戦略をすべてサポートしていますが、特に特徴的なのは、オプティミスティック コンカレンシーとペシミスティックコンカレンシー制御のフル サポートを提供していることです。強力な整合性モデルを備えているため、Storage サービスでデータの挿入や更新の処理がコミットされた後にサービスがそのデータにアクセスした場合でも、確実に最新のデータが提供されます。 最終的な整合性モデルを使用するストレージ プラットフォームでは、あるユーザーが書き込んだ後に他のユーザーがそのデータを表示できるようになるまでにはタイム ラグが発生します。このため、エンド ユーザーがこの不整合の影響を受けないようにするために、クライアント アプリケーションの開発は複雑になります。\n\nまた、開発者は、適切なコンカレンシー制御の戦略を選択する以外にも、特に複数のトランザクションで同一のオブジェクトを変更する場合に、ストレージ プラットフォームで変更がどのように分離されるかについて把握しておく必要があります。 Azure Storage サービスではスナップショット分離の手法を使用して、同一パーティション内での読み取り処理と書き込み処理が同時に発生できるようにしています。 他の分離レベルとは異なり、スナップショット分離では、更新の処理中でもすべての読み込み処理に対してデータのスナップショットを提供することにより整合性を確保します。これは基本的に、更新トランザクションの処理中に最後にコミットされた値を返すことで実現しています。\n<h2>Blob Service での同時実行の管理</h2>\nBLOB サービスでの BLOB およびコンテナーへのアクセスを管理する場合、オプティミスティック コンカレンシーとペシミスティック コンカレンシー制御のいずれかのモデルを使用できます。 明示的に戦略を指定しない場合は、最終書き込み者優先が既定となります。\n<h3>BLOB およびコンテナーでのオプティミスティック コンカレンシー</h3>\nStorage サービスでは、格納されているすべてのオブジェクトに識別子が割り当てられます。 オブジェクトで更新処理が実行されるたびに、この識別子が更新されます。 この識別子は、HTTP プロトコルで定義されている ETag (エントリ タグ) ヘッダーを使用して、HTTP GET 応答の一部としてクライアントに返されます。 該当するオブジェクトをユーザーが更新しようとすると、条件ヘッダーが付属している元の ETag が送信され、特定の条件を満たしているときにのみ更新が行われます。この条件には、\"If-Match\" ヘッダーが使用されます。これによって、更新要求で指定された ETag の値が Storage サービスに格納されている値と同一であることが、Storage サービスによって確認されます。\n\nこのプロセスの概要は次のとおりです。\n\n1. Storage サービスから BLOB を取得します。この応答に含まれる HTTP ETag ヘッダーの値が、Storage サービスに格納されているオブジェクトの現在のバージョンを示します。\n\n2. BLOB を更新するときに、手順 1. でサービスに送信した要求の <b>If-Match</b> 条件ヘッダーで返された ETag の値を含めます。\n\n3. サービスによって、要求内の ETag の値と BLOB の現在の ETag の値が比較されます。\n\n4. BLOB の現在の ETag の値が、要求の <b>If-Match</b> 条件ヘッダーの ETag の値と異なっている場合、サービスはクライアントに 412 エラーを返します。 これは、クライアントがこの BLOB を取得した後に、別のプロセスがこれを更新したことを示しています。\n\n5. BLOB の現在の ETag の値が、要求の <b>If-Match</b> 条件ヘッダーの ETag と同じバージョンである場合、サービスは要求された処理を実行し、この BLOB の新しいバージョンが作成されたことを示すために現在の ETag の値を更新します。\n\n次の C# スニペット (クライアント Storage ライブラリ4.2.0 を使用) は、以前に取得または挿入された blob のプロパティからアクセスされる ETag 値に基づいて、 <b>if-match</b> <b>accesscondition</b>を構築する方法の簡単な例を示しています。 BLOB を更新するときには <b>AccessCondition</b> オブジェクトを使用します。<b>AccessCondition</b> オブジェクトは <b>If-Match</b> ヘッダーを要求に追加します。 別のプロセスが BLOB を更新した場合、BLOB のサービスによって HTTP 412 (Precondition Failed) のステータス メッセージが返されます。 完全なサンプルは、 <a href=\"https://code.msdn.microsoft.com/windowsazure/Managing-Concurrency-using-56018114\">こちら</a>からダウンロードできます。\n<pre class=\"prettyprint\">// Retrieve Etag from the response of an earlier UploadText blob operation.\nstring orignalETag = blockBlob.Properties.ETag;\n// This code simulates an update by a third party.\nstring helloText = \"Blob updated by a third party.\";\n// No etag, provided so orignal blob is overwritten (thus generating a new etag)\nblockBlob.UploadText(helloText);\nConsole.WriteLine(\"Blob updated. Updated ETag = {0}\", blockBlob.Properties.ETag);\n// Now try to update the blob using the orignal ETag provided when the blob was created\ntry\n{\n     Console.WriteLine(\"Trying to update blob using orignal etag to generate if-match access condition\");\n     blockBlob.UploadText(helloText,accessCondition:\n     AccessCondition.GenerateIfMatchCondition(orignalETag));\n}\ncatch (StorageException ex)\n{\n     if (ex.RequestInformation.HttpStatusCode == (int)HttpStatusCode.PreconditionFailed)\n     {\n          Console.WriteLine(\"Precondition failure as expected. Blob's orignal etag no longer matches\");\n     }\n}</pre>\n&nbsp;\n\nまた、Storage サービスで<b>は、</b> <b>if-Modified-</b>from、if-from、および<b>if-None-if-match</b>などの追加の条件ヘッダーもサポートされています。<b> </b>詳細については、MSDN の「 <a href=\"https://msdn.microsoft.com/en-us/library/dd179371.aspx\">Blob サービス操作の条件ヘッダーの指定</a>」を参照してください。\n\n次の表は、要求に含まれている <b>If-Match</b> などの条件ヘッダーを受け取り、ETag の値を返すコンテナー操作をまとめたものです。\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"0\">\n<tbody>\n<tr>\n<td valign=\"top\" width=\"270\"><b>操作</b></td>\n<td valign=\"top\" width=\"288\"><b>コンテナーの ETag 値を返す</b></td>\n<td valign=\"top\" width=\"351\"><b>条件ヘッダーを受け取る</b></td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"270\">コンテナーの作成</td>\n<td valign=\"top\" width=\"288\">はい</td>\n<td valign=\"top\" width=\"351\">いいえ</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"270\">コンテナーのプロパティの取得</td>\n<td valign=\"top\" width=\"288\">はい</td>\n<td valign=\"top\" width=\"351\">いいえ</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"270\">Get Container Metadata</td>\n<td valign=\"top\" width=\"288\">はい</td>\n<td valign=\"top\" width=\"351\">いいえ</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"270\">Set Container Metadata</td>\n<td valign=\"top\" width=\"288\">はい</td>\n<td valign=\"top\" width=\"351\">はい</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"270\">コンテナー ACL の取得</td>\n<td valign=\"top\" width=\"288\">はい</td>\n<td valign=\"top\" width=\"351\">いいえ</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"270\">Set Container ACL</td>\n<td valign=\"top\" width=\"288\">Yes</td>\n<td valign=\"top\" width=\"351\">あり (*)</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"270\">Delete Container</td>\n<td valign=\"top\" width=\"288\">いいえ</td>\n<td valign=\"top\" width=\"351\">はい</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"270\">Lease Container</td>\n<td valign=\"top\" width=\"288\">はい</td>\n<td valign=\"top\" width=\"351\">はい</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"270\">BLOBs の一覧</td>\n<td valign=\"top\" width=\"288\">いいえ</td>\n<td valign=\"top\" width=\"351\">いいえ</td>\n</tr>\n</tbody>\n</table>\n(*) SetContainerACL で定義されたアクセス許可はキャッシュされます。このアクセス許可の更新の伝達には 30 秒間かかり、その間は更新の整合性は保証されません。\n\n次の表は、要求に含まれている <b>If-Match</b> などの条件ヘッダーを受け取り、ETag の値を返す BLOB 操作をまとめたものです。\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"0\">\n<tbody>\n<tr>\n<td valign=\"top\" width=\"270\"><b>操作</b></td>\n<td valign=\"top\" width=\"288\"><b>ETag 値を返す</b></td>\n<td valign=\"top\" width=\"351\"><b>条件ヘッダーを受け取る</b></td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"270\">Put Blob</td>\n<td valign=\"top\" width=\"288\">はい</td>\n<td valign=\"top\" width=\"351\">はい</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"270\">Get Blob</td>\n<td valign=\"top\" width=\"288\">はい</td>\n<td valign=\"top\" width=\"351\">はい</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"270\">BLOB のプロパティの取得</td>\n<td valign=\"top\" width=\"288\">はい</td>\n<td valign=\"top\" width=\"351\">はい</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"270\">Set Blob Properties</td>\n<td valign=\"top\" width=\"288\">はい</td>\n<td valign=\"top\" width=\"351\">はい</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"270\">BLOB のメタデータの取得</td>\n<td valign=\"top\" width=\"288\">はい</td>\n<td valign=\"top\" width=\"351\">はい</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"270\">Set Blob Metadata</td>\n<td valign=\"top\" width=\"288\">はい</td>\n<td valign=\"top\" width=\"351\">はい</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"270\">Lease Blob (*)</td>\n<td valign=\"top\" width=\"288\">はい</td>\n<td valign=\"top\" width=\"351\">はい</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"270\">Snapshot Blob</td>\n<td valign=\"top\" width=\"288\">はい</td>\n<td valign=\"top\" width=\"351\">はい</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"270\">BLOB のコピー</td>\n<td valign=\"top\" width=\"288\">Yes</td>\n<td valign=\"top\" width=\"351\">Yes (コピー元とコピー先 BLOB に対して)</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"270\">Abort Copy Blob</td>\n<td valign=\"top\" width=\"288\">いいえ</td>\n<td valign=\"top\" width=\"351\">いいえ</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"270\">Delete Blob</td>\n<td valign=\"top\" width=\"288\">いいえ</td>\n<td valign=\"top\" width=\"351\">はい</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"270\">Put Block</td>\n<td valign=\"top\" width=\"288\">いいえ</td>\n<td valign=\"top\" width=\"351\">いいえ</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"270\">Put Block List</td>\n<td valign=\"top\" width=\"288\">はい</td>\n<td valign=\"top\" width=\"351\">はい</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"270\">Get Block List</td>\n<td valign=\"top\" width=\"288\">はい</td>\n<td valign=\"top\" width=\"351\">いいえ</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"270\">Put Page</td>\n<td valign=\"top\" width=\"288\">はい</td>\n<td valign=\"top\" width=\"351\">はい</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"270\">ページ範囲の取得</td>\n<td valign=\"top\" width=\"288\">はい</td>\n<td valign=\"top\" width=\"351\">はい</td>\n</tr>\n</tbody>\n</table>\n(*) Lease BLOB では、BLOB の ETag は変更されません。\n<h3>BLOB でのペシミスティック コンカレンシー制御</h3>\nBLOB をロックして排他的に使用する場合は、<a href=\"https://msdn.microsoft.com/en-us/library/azure/ee691972.aspx\">リース</a>を取得します。 リースを取得すると、必要に応じてリース期間を 15 ～ 60 秒または無制限に設定できます。この期間、BLOB が排他的にロックされます。 リース期間が有限の場合は、これを延長することができます。また、完了したリースは解放できます。 有限リースの期限が切れると、BLOB サービスによって自動的に解放されます。\n\nリースでは、排他的書き込みと共有読み取り、排他的書き込みと排他的読み取り、共有書き込みと排他的読み取りなど、さまざまな同期戦略がサポートされています。 リースが存在する場合、Storage サービスは排他的書き込み (put、set、delete の各操作) を強制的に実行しますが、読み込み操作の排他性を確保するために、開発者はすべてのクライアント アプリケーションがリース ID を使用し、また有効なリース ID は同時に 1 つのクライアントのみが保持するようにする必要があります。 読み込み操作にリース ID を使用しない場合、共有読み取りになります。\n\n次の C# スニペットの例では、ある BLOB で 30 秒間の排他的リースを取得し、BLOB の内容を更新します。その後でリースを解放します。 BLOB が既に有効なリースを保持している場合、新しいリースを取得しようとすると、BLOB サービスは \"HTTP (409) Conflict\" 状態を結果として返します。 また、下記のスニペットでは、Storage サービスに BLOB の更新を要求するときに、<b>AccessCondition</b> オブジェクトを使用してリースの情報をカプセル化します。 完全なサンプルは、 <a href=\"https://code.msdn.microsoft.com/windowsazure/Managing-Concurrency-using-56018114\">こちら</a>からダウンロードできます。\n<pre class=\"prettyprint\">// Acquire lease for 15 seconds\nstring lease = blockBlob.AcquireLease(TimeSpan.FromSeconds(15), null);\nConsole.WriteLine(\"Blob lease acquired. Lease = {0}\", lease);\n\n// Update blob using lease. This operation will succeed\nconst string helloText = \"Blob updated\";\nvar accessCondition = AccessCondition.GenerateLeaseCondition(lease);\nblockBlob.UploadText(helloText, accessCondition: accessCondition);\nConsole.WriteLine(\"Blob updated using an exclusive lease\");\n\n//Simulate third party update to blob without lease\ntry\n{\n     // Below operation will fail as no valid lease provided\n     Console.WriteLine(\"Trying to update blob without valid lease\");\n     blockBlob.UploadText(\"Update without lease, will fail\");\n}\ncatch (StorageException ex)\n{\n     if (ex.RequestInformation.HttpStatusCode == (int)HttpStatusCode.PreconditionFailed)\n          Console.WriteLine(\"Precondition failure as expected. Blob's lease does not match\");\n     else\n          throw;\n}</pre>\n&nbsp;\n\nリース id を渡さずにリースされた blob に対して書き込み操作を実行すると、要求は412エラーで失敗します。 <b>Uploadtext</b>メソッドを呼び出す前にリースの有効期限が切れても、リース id を渡すと、要求は<b>412</b>エラーで失敗します。 リースの有効期限とリース id の管理の詳細については、 <a href=\"https://msdn.microsoft.com/en-us/library/azure/ee691972.aspx\">リース Blob</a> REST のドキュメントを参照してください。\n\n次の BLOB 操作では、ペシミスティック コンカレンシー制御の管理にリースを使用できます。\n\n·Blob の配置\n\n·Blob の取得\n\n·Blob のプロパティの取得\n\n·Blob のプロパティの設定\n\n·Blob メタデータの取得\n\n·Blob メタデータの設定\n\n·Blob の削除\n\n·Put ブロック\n\n·Put ブロックリスト\n\n·ブロックリストの取得\n\n·ページの配置\n\n·ページ範囲を取得する\n\n·スナップショット Blob-リースが存在する場合のリース id (省略可能)\n\n·Copy Blob-宛先 blob にリースが存在する場合はリース id が必要\n\n·Abort Copy Blob-コピー先 blob に無制限のリースが存在する場合、リース id が必要です\n\n·Blob のリース\n<h3>コンテナーでのペシミスティック コンカレンシー制御</h3>\nコンテナーのリースでは、BLOB でサポートされるものと同じ同期戦略 (排他的書き込みと共有読み取り、排他的書き込みと排他的読み取り、共有書き込みと排他的読み取り) がサポートされます。ただし、BLOB とは異なり、Storage サービスで排他的に実行できるのは削除操作のみです。 アクティブなリースを使用してコンテナーを削除するには、クライアントが削除要求に有効なリース ID を含める必要があります。 それ以外のコンテナー操作は、リース ID を含めなくてもリースされたコンテナーに対して正常に実行されます。この場合、各操作は共有操作になります。 更新操作 (put または set) または読み込み操作を排他的に行う必要がある場合、開発者はすべてのクライアントがリース ID を使用し、有効なリース ID を持つクライアントが一度に 1 つのみになるようにする必要があります。\n\n次のコンテナー操作では、ペシミスティック コンカレンシー制御の管理にリースを使用できます。\n\n·コンテナーの削除\n\n·コンテナーのプロパティを取得する\n\n·コンテナーのメタデータを取得する\n\n·コンテナーメタデータの設定\n\n·コンテナー ACL の取得\n\n·コンテナー ACL の設定\n\n·リースコンテナー\n\n詳細情報\n\n- <a href=\"https://msdn.microsoft.com/en-us/library/azure/dd179371.aspx\">BLOB サービス操作の条件ヘッダーの指定</a>\n\n- <a href=\"https://msdn.microsoft.com/en-us/library/azure/jj159103.aspx\">Lease Container</a>\n\n- <a href=\"https://msdn.microsoft.com/en-us/library/azure/ee691972.aspx\">Lease Blob</a>\n<h2>Table サービスでのコンカレンシー制御の管理</h2>\nエンティティを扱っている場合、Table サービスではオプティミスティック コンカレンシーの確認が既定の動作として使用されます。一方、BLOB サービスの場合は、オプティミスティック コンカレンシーの確認を実行するように明示的に選択する必要があります。 これ以外の相違点としては、Table サービスではエンティティのコンカレンシー制御しか管理できませんが、BLOB サービスではコンテナーと BLOB の両方のコンカレンシー制御を管理できる点があります。\n\nオプティミスティック コンカレンシーを使用して、Table ストレージ サービスからエンティティを取得した後に他のプロセスがそれを更新していないか確認するには、Table サービスがエンティティを返す時に受け取った ETag の値を使用できます。 このプロセスの概要は次のとおりです。\n\n1. Table ストレージ サービスからエンティティを取得します。この応答に含まれている ETag の値によって、ストレージ サービスでこのエンティティに関連付けられている現在の識別子を識別できます。\n\n2. エンティティを更新するときに、手順 1. でサービスに送信した要求の必須の <b>If-Match</b> ヘッダーで返された ETag の値を含めます。\n\n3. サービスによって、要求内の ETag の値とエンティティの現在の ETag の値が比較されます。\n\n4. エンティティの現在の ETag の値が、要求の必須 <b>If-Match</b> ヘッダーの ETag の値と異なっている場合、サービスはクライアントに 412 エラーを返します。 これは、クライアントがこのエンティティを取得した後に、別のプロセスがこれを更新したことを示しています。\n\n5. エンティティの現在の ETag の値が、要求に含まれる必須の <b>If-Match</b> ヘッダーの ETag の値と等しい場合、または <b>If-Match</b> ヘッダーにワイルドカード文字 (*) が含まれている場合、サービスは要求された処理を実行し、更新されたことを示すためにエンティティの ETag の値を更新します。\n\nBlob サービスとは異なり、table service では、クライアントが更新要求に <b>if-match</b> ヘッダーを含める必要があります。 ただし、クライアントが要求の <b>If-Match</b> ヘッダーにワイルドカード文字 (*) を設定していた場合、無条件の更新 (最終書き込み者優先戦略) を実行し、コンカレンシー制御の確認を省略することができます。\n\n次の C# スニペットは、前に電子メール アドレスが更新されたときに作成または取得された顧客エンティティを示しています。 最初の挿入操作または取得操作で、顧客のオブジェクトに ETag の値が格納されます。このサンプルでは置換操作を実行するときに同じオブジェクトのインスタンスを使用するため、ETag の値が自動的に Table サービスに返され、サービスがコンカレンシー制御の違反を確認できるようになっています。 別のプロセスが Table ストレージ内のエンティティを更新した場合、サービスから HTTP 412 (Precondition Failed) のステータス メッセージが返されます。 完全なサンプルは、 <a href=\"https://code.msdn.microsoft.com/windowsazure/Managing-Concurrency-using-56018114\">こちら</a>からダウンロードできます。\n<pre class=\"prettyprint\">try\n{\n     customer.Email = \"updatedEmail@contoso.org\";\n     TableOperation replaceCustomer = TableOperation.Replace(customer);\n     customerTable.Execute(replaceCustomer);\n     Console.WriteLine(\"Replace operation succeeded.\");\n}\ncatch (StorageException ex)\n{\n     if (ex.RequestInformation.HttpStatusCode == 412)\n          Console.WriteLine(\"Optimistic concurrency violation – entity has changed since it was retrieved.\");\n     else\n          throw; \n}</pre>\n&nbsp;\n\n同時実行チェックを明示的に無効にするには、replace 操作を実行する前に、 <b>employee</b>オブジェクトの<b>ETag</b>プロパティを \"*\" に設定する必要があります。\n\nお.ETag = \"*\";\n\n次の表は、Table エンティティで ETag の値がどのように使用されるかをまとめたものです。\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"0\">\n<tbody>\n<tr>\n<td valign=\"top\" width=\"279\"><b>操作</b></td>\n<td valign=\"top\" width=\"306\"><b>ETag 値を返す</b></td>\n<td valign=\"top\" width=\"342\"><b>If-Match 要求ヘッダーが必須</b></td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"279\">エンティティのクエリ</td>\n<td valign=\"top\" width=\"306\">はい</td>\n<td valign=\"top\" width=\"342\">いいえ</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"279\">エンティティの挿入</td>\n<td valign=\"top\" width=\"306\">はい</td>\n<td valign=\"top\" width=\"342\">いいえ</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"279\">エンティティの更新</td>\n<td valign=\"top\" width=\"306\">はい</td>\n<td valign=\"top\" width=\"342\">はい</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"279\">エンティティの統合</td>\n<td valign=\"top\" width=\"306\">はい</td>\n<td valign=\"top\" width=\"342\">はい</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"279\">エンティティの削除</td>\n<td valign=\"top\" width=\"306\">いいえ</td>\n<td valign=\"top\" width=\"342\">はい</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"279\">エンティティの挿入または置換</td>\n<td valign=\"top\" width=\"306\">はい</td>\n<td valign=\"top\" width=\"342\">いいえ</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"279\">エンティティの挿入または統合</td>\n<td valign=\"top\" width=\"306\">はい</td>\n<td valign=\"top\" width=\"342\">いいえ</td>\n</tr>\n</tbody>\n</table>\n<b>Insert or Replace Entity</b> と <b>Insert or Merge Entity</b> の各操作では、ETag の値は Table サービスに送信されないため、コンカレンシー制御の確認は<i>行われません</i>。\n\n一般に、テーブルを利用するスケーラブルなアプリケーションを開発するときは、オプティミスティック コンカレンシーを採用する必要があります。 ペシミスティック同時実行制御のロックが必要な場合、テーブルにアクセスする際には、テーブルに対する操作が行われる前に各テーブルに指定した BLOB を関連付け、BLOB のリースの取得を試行するという手法を利用できます。 この手法では、テーブルに対する操作が行われる前にすべてのデータのアクセス パスでリースが確実に取得されるようにアプリケーションを設計する必要があります。 また、リース期間は最低 15 秒であるため、スケーラビリティについては慎重に考慮する必要があります。\n\n詳細情報\n\n- <a href=\"https://msdn.microsoft.com/en-us/library/azure/dd179375.aspx\">エンティティに対する操作</a>\n<h3>キュー サービスでのコンカレンシー制御の管理</h3>\nキュー サービスでのコンカレンシー制御について注意が必要なケースとして、複数のクライアントが 1 つのキューからメッセージを取得する場合があります。 キューからメッセージを取得するときの応答には、メッセージと、メッセージを削除するときに必要な pop receipt 値が含まれます。 メッセージはキューから自動的に削除されることはありませんが、取得された後、visibilitytimeout パラメーターで指定された期間は他のクライアントに表示されなくなります。 メッセージを取得するクライアントは、メッセージの処理後、応答の TimeNextVisible 要素で指定された時刻までにメッセージを削除します。この時刻は visibilitytimeout パラメーターの値に基づいて算出されます。 visibilitytimeout の値をメッセージの取得時刻に加算することで、TimeNextVisible の値が決定されます。\n\nキュー サービスでは、オプティミスティックおよびペシミスティックのいずれのコンカレンシー制御もサポートしていません。このため、キューからメッセージを取得して処理するクライアントは、元の値が変わらないようにメッセージを処理する必要があります。 SetQueueServiceProperties、SetQueueMetaData、SetQueueACL、UpdateMessage などの更新操作では、最終書き込み者優先戦略が適用されます。\n\n詳細情報\n\n- <a href=\"https://msdn.microsoft.com/en-us/library/azure/dd179363.aspx\">Queue サービス REST API</a>\n\n- <a href=\"https://msdn.microsoft.com/en-us/library/azure/dd179474.aspx\">メッセージの取得</a>\n<h3>ファイル サービスでのコンカレンシー制御の管理</h3>\nファイル サービスでは、SMB と REST の 2 種類のプロトコルを使用してエンドポイントにアクセスできます。 REST サービスではオプティミスティック同時実行制御とペシミスティック同時実行制御のいずれもサポートされておらず、すべての更新操作は最終書き込み者優先戦略に従います。 ファイル共有をマウントする SMB クライアントではファイル システムのロック機構を使用して、共有ファイルへのアクセスを管理できます。ペシミスティック同時実行制御も実行できます。 SMB クライアントがファイルを開くときに、ファイルのアクセス権と共有モードの両方が指定されます。 ファイルのアクセス権のオプションが \"Write\" または \"Read/Write\" に設定され、同時にファイル共有モードが \"None\" に設定された場合、そのファイルは閉じられるまで SMB クライアントによってロックします。 SMB クライアントがロックしているファイルに REST 操作を実行しようとすると、REST サービスはステータス コード 409 (Conflict) およびエラー コード SharingViolation を返します。\n\nSMB クライアントがファイルを開いて削除する場合、そのファイルで開かれているハンドルが他のすべての SMB クライアントで閉じられるまで、ファイルは保留中の削除とマークされます。 保留中の削除であるとマークされたファイルで REST 操作を実行しようとすると、ステータス コード 409 (Conflict) とエラー コード SMBDeletePending が返されます。 SMB クライアントはファイルを閉じる前に保留中の削除を示すフラグを削除できるため、ステータス コード 404 (Not Found) は返されません。 つまり、ステータス コード 404 (Not Found) は、ファイルが削除済みである場合のみ返されることが想定されます。 SMB で保留中の削除状態にあるファイルは、List Files の結果に含まれないことに注意してください。また、REST Delete File および REST Delete Directory の各操作はアトミックにコミットされるため、保留中の削除状態になることはありません。\n\n詳細情報\n\n- <a href=\"https://msdn.microsoft.com/en-us/library/azure/dn194265.aspx\">ファイルのロックの管理</a>\n<h2>概要と次のステップ</h2>\nMicrosoft Azure Storage サービスは、非常に複雑なオンライン アプリケーションのニーズに対応するように設計されていますが、開発者は、コンカレンシー制御やデータの整合性など、当然のように想定されるようになった主要設計項目を再検討したり、妥協したりする必要がありません。\n\nこのブログで参照したサンプル アプリケーションの完全版は、次のページからダウンロードできます。\n\n- <a href=\"https://code.msdn.microsoft.com/windowsazure/Managing-Concurrency-using-56018114\">Azure Storage でのコンカレンシー制御の管理 - サンプル アプリケーション</a>\n\nAzure Storage の詳細については、以下を参照してください。\n\n- <a href=\"https://azure.microsoft.com/en-us/services/storage/\">Microsoft Azure Storage のホーム ページ</a>\n\n- <a href=\"https://azure.microsoft.com/en-us/documentation/articles/storage-introduction/\">Azure ストレージの概要</a>\n\n- Storage はじめに<a href=\"https://azure.microsoft.com/en-us/documentation/articles/storage-dotnet-how-to-use-blobs/\">、テーブル、</a><a href=\"https://azure.microsoft.com/en-us/documentation/articles/storage-dotnet-how-to-use-tables/\">および</a><a href=\"https://azure.microsoft.com/en-us/documentation/articles/storage-dotnet-how-to-use-queues/\">キューの詳細</a>\n\n- Storage アーキテクチャ – <a href=\"https://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx\">Windows Azure Storage: 強力な整合性を備Storage高可用性クラウド クラウド サービス</a>\n\n&nbsp;\n\n&nbsp;"
