### YamlMime:Yaml
ms.openlocfilehash: 474a7fff4b7c1e3acfa589370f66f4bdf2d2438d
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2022
ms.locfileid: "139893641"
Slug: auditing-media-assets-lifecycle-part-1-2
Title: メディア資産のライフサイクルの監査 – パート 1
Summary: メディア資産のライフ サイクルを監査するのに役立つ一連のブログのパート 1 (サンプル コードを含む)
Content: "高価値コンテンツを扱うメディア アプリケーションは、 <a href=\"https://www.mpaa.org/\">通常、MPAA</a>、 <a href=\"https://www.cdsaonline.org/\">CDSA</a> 、または同等のコンプライアンス要件に従う必要があります。 関連付けられている監査プロセスの一環として、アプリケーションとサービスを通じて伝達されるメディア資産のライフサイクルを示す監査レポートを生成する必要があります。 このブログ (複数の部分に分割されています) では、メディア資産が複数のパートを通過する間に監査レポートを生成する方法Media Services。 このブログのパート 1 では、メディア資産が作成および削除された時点を示す資産監査レポートを作成する方法に焦点を当て、説明します。\n\n&nbsp;\n<h2>メディアアセットのMedia Services</h2>\nメディア資産<a href=\"https://msdn.microsoft.com/en-us/library/hh974277.aspx#create_an_asset\">を</a>作成すると、Media Services GUID が生成され、その GUID を使用してメディア資産 ID が作成されます。メディア資産 ID の前に \"nb:cid:UUID:\" が付き、その後に GUID が付きます。 これらの ID は URN 形式であり、\"nb\" は実際には内部的に Media Services codename (Nimbus) を表し、cid は Content ID を表します。つまり、メディア資産 ID は \"nb:cid:UUID&lt;:GUID\" の形式です&gt;。 Media Services資産のレコードを作成し、内部的に格納します。 Media Services、\"asset- \" という名前のコンテナーも作成されます。&lt;指定したアカウントの GUID&gt; Storageします。 資産が作成されると、ストレージ コンテナーにメディア ファイルをアップロードできます。 メディア資産<a href=\"https://msdn.microsoft.com/en-us/library/hh974277.aspx#delete_an_asset\">を</a>削除すると、Media Services内部データベースから資産レコードが削除され、ストレージ コンテナーも削除されます。 この場合、Media Services API を使用して、資産が削除されていない限り資産の作成時間を決定できますが、メディア アプリケーションで追跡しない限り、資産の削除時間を決定する方法はありません。\n\n&nbsp;\n<h2>ログを使用したメディア資産の作成Storage追跡</h2>\nメディア資産は Storage のコンテナーとして表されるので、Storage ログを使用して、メディア資産の作成と削除の時間を決定できます。 これを行うには、アカウントでログ記録を有効Storage必要Storageがあります。 詳細については <a href=\"https://azure.microsoft.com/en-us/documentation/articles/storage-monitor-storage-account/#configurelogging\">、「方法: ログ記録を構成</a> する」を参照してください。 選択した保持ポリシーによって、監査レポートにどの期間まで戻る能力が決まるので注意してください。 ゼロを選択した場合、ログは削除されません。ログ記録を有効にした日付まで戻る機能があります。 Azure Storageログは、ストレージ アカウント内の $logs という名前のコンテナー<strong>に保存されます</strong>。 ログの格納方法とログの名前付け規則の詳細については、「Storage <a href=\"https://msdn.microsoft.com/en-us/library/azure/hh343262.aspx\">Analytics Logging</a> MSDN」ページを参照してください。\n\n&nbsp;\n<h2>サンプル コード</h2>\n次に示すサンプル コードでは、Media Services Assets Collection と Storage ログの両方を使用して、AssetAudit という名前の Azure Storage <strong>テーブルを生成します</strong>。 このテーブルは、資産の作成と削除の時間を示す資産監査レポートを生成するために使用できます。 大きなレベルでは、ロジックは次のようになります。\n<ul>\n <li>このコードは、api のプロパティを使用して、すべての資産Media Servicesします。</li>\n <li>列挙されたアセットごとに、Asset.Created プロパティを使用して <strong>AssetAudit テーブルにテーブル エントリを作成</strong> します。</li>\n <li>次に、blob/blob の下$logsを列挙します。</li>\n <li>各 BLOB について、ファイルをダウンロードし、Storage <a href=\"https://msdn.microsoft.com/en-us/library/azure/hh343259.aspx\">Analytics Log Format</a> MSDN ページに記載されているログ エントリ形式に基づいて解析します。</li>\n <li>このコードは、\"asset-\" で始まるオブジェクトで発生した操作を確認します。</li>\n <li>CreateContainer 操作の種類と DeleteContainer 操作の種類をフィルター処理し、AssetAudit テーブルに対応する <strong>エントリを作成</strong> します。</li>\n</ul>\nサンプルApp.Configファイルは次のとおりです。\n<pre class=\"prettyprint\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;configuration&gt;\n  &lt;startup&gt;\n    &lt;supportedRuntime version=\"v4.0\" sku=\".NETFramework,Version=v4.5\" /&gt;\n  &lt;/startup&gt;\n  &lt;appSettings&gt;\n    &lt;add key=\"MediaServicesAccountName\" value=\"&lt;MediaAccountName&gt;\" /&gt;\n    &lt;add key=\"MediaServicesAccountKey\" value=\"&lt;MediaAccountKey&gt;\" /&gt;\n    &lt;add key=\"StorageConnectionString\" value=\"DefaultEndpointsProtocol=https;AccountName=&lt;StorageAccountName&gt;;AccountKey=&lt;StorageAccountKey&gt;\"/&gt;\n  &lt;/appSettings&gt;\n  &lt;runtime&gt;\n    &lt;assemblyBinding xmlns=\"urn:schemas-microsoft-com:asm.v1\"&gt;\n      &lt;dependentAssembly&gt;\n        &lt;assemblyIdentity name=\"Microsoft.WindowsAzure.Storage\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" /&gt;\n        &lt;bindingRedirect oldVersion=\"0.0.0.0-4.1.0.0\" newVersion=\"4.1.0.0\" /&gt;\n      &lt;/dependentAssembly&gt;\n    &lt;/assemblyBinding&gt;\n  &lt;/runtime&gt;\n&lt;/configuration&gt;</pre>\n上記の手順でApp.Config &lt;MediaAccountName&gt; &lt;と MediaAccountKey&gt; を実際のアカウント名とキー Media Services置き換える必要があります。 また、&lt;StorageAccountName&gt; と &lt;StorageAccountKey&gt; を、自分のアカウントに関連付けられているストレージ アカウントの名前とキー Media Servicesします。\n\nコードは次のとおりです。\n<pre class=\"prettyprint\">using System;\nusing System.Linq;\nusing System.Configuration;\nusing System.IO;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing Microsoft.WindowsAzure;\nusing Microsoft.WindowsAzure.Storage;\nusing Microsoft.WindowsAzure.Storage.Blob;\nusing Microsoft.WindowsAzure.Storage.Table;\nusing Microsoft.WindowsAzure.MediaServices.Client;\n\nnamespace AssetAuditing\n{\n    /// &lt;summary&gt;\n    /// \n    /// &lt;/summary&gt;\n    public class AssetAuditEntity : TableEntity\n    {\n        public string OperationType { get; set; }\n    }\n\n    /// &lt;summary&gt;\n    /// \n    /// &lt;/summary&gt;\n    class Program\n    {\n        // Read values from the App.config file.\n        private static readonly string _mediaServicesAccountName = ConfigurationManager.AppSettings[\"MediaServicesAccountName\"];\n        private static readonly string _mediaServicesAccountKey = ConfigurationManager.AppSettings[\"MediaServicesAccountKey\"];\n        private static readonly string _storageConnectionString = ConfigurationManager.AppSettings[\"StorageConnectionString\"];\n        private static string _lastLogFile = ConfigurationManager.AppSettings[\"LastLogFile\"];\n\n        // Field for service context.\n        private static CloudMediaContext _context = null;\n        private static MediaServicesCredentials _cachedCredentials = null;\n        private static CloudStorageAccount _cloudStorage = null;\n\n        private static CloudBlobClient _blobClient = null;\n        private static CloudTableClient _tableClient = null;\n        private static CloudTable _assetAuditTable = null;\n\n        /// &lt;summary&gt;\n        /// \n        /// &lt;/summary&gt;\n        /// &lt;param name=\"args\"&gt;&lt;/param&gt;\n        static void Main(string[] args)\n        {\n            try\n            {\n                // Create and cache the Media Services credentials in a static class variable.\n                _cachedCredentials = new MediaServicesCredentials(_mediaServicesAccountName, _mediaServicesAccountKey);\n\n                // Used the chached credentials to create CloudMediaContext.\n                _context = new CloudMediaContext(_cachedCredentials);\n\n                _cloudStorage = CloudStorageAccount.Parse(_storageConnectionString);\n\n                _blobClient = _cloudStorage.CreateCloudBlobClient();\n                _tableClient = _cloudStorage.CreateCloudTableClient();\n\n                _assetAuditTable = _tableClient.GetTableReference(\"AssetAudit\");\n                _assetAuditTable.CreateIfNotExists();\n\n                ProcessAssetData();\n                ParseStorageLogs();\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message + ex.InnerException.StackTrace);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// This function parses all the storage log files under $logs container\n        /// It skips the files that have already been parsed in the last run based on the entry in app.config\n        /// &lt;/summary&gt;\n        static void ParseStorageLogs()\n        {\n            try\n            {\n                // Enumerate all blobs under $logs/blob\n                foreach (CloudBlockBlob _blobItem in _blobClient.ListBlobs(\"$logs/blob\", true))\n                {\n                    // The blobs will be enumerated in ascending order\n                    // Since the logs are organized in chronological order, you can compare the blob name with the last processed logfile to make sure you are not reprocessing it                    \n                    if (String.Compare(_blobItem.Name, _lastLogFile) &gt; 0)\n                    {\n                        try\n                        {\n                            Console.WriteLine(\"Processing \" + _blobItem.Name);\n                            string _logs = GetBlobData(_blobItem);  // Download the blob\n\n                            // Get individual loglines by looking for the newline separator\n                            List&lt;string&gt; _logLines = ParseDelimitedString(_logs, \"\\n\");\n\n                            for (int i = 0; i &lt; _logLines.Count; i++)\n                            {\n                                // Separate out the log items by looking for the ; separator\n                                List&lt;string&gt; _logLineItems = ParseDelimitedString(_logLines[i], \";\");\n                                if (_logLineItems.Count &gt; 0)\n                                {\n                                    // Parse each log line\n                                    ParseLogLine(_logLineItems);\n                                }\n                            }\n\n                            // Stored the blob name as the last log file that was processed\n                            _lastLogFile = _blobItem.Name;\n                            SaveLastLogFileInConfig();\n                        }\n                        catch (Exception x)\n                        {\n                            Console.WriteLine(x.Message + x.InnerException.StackTrace);\n                        }\n                    }\n                    else\n                    {\n                        Console.WriteLine(\"Skipping \" + _blobItem.Name);\n                    }\n                }\n\n                SaveLastLogFileInConfig();\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message + ex.InnerException.StackTrace);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// This function loops through all the assets (1000 at a time) in the Media Services account and logs the Asset Create time in the AssetAudit Table\n        /// &lt;/summary&gt;\n        static void ProcessAssetData()\n        {\n            try\n            {\n                int skipSize = 0;\n                int batchSize = 1000;\n                int currentSkipSize = 0;\n\n                while (true)\n                {\n                    // Enumerate through all assets (1000 at a time)\n                    foreach (IAsset asset in _context.Assets.Skip(skipSize).Take(batchSize))\n                    {\n                        currentSkipSize++;\n                        Console.WriteLine(\"Processing Asset \" + asset.Id);\n\n                        // Enter the Create time of the asset in the AssetAudit table\n                        InsertAssetData(asset.Id, asset.Created.ToString(\"o\"), \"Create\");\n                    }\n\n                    if (currentSkipSize == batchSize)\n                    {\n                        skipSize += batchSize;\n                        currentSkipSize = 0;\n                    }\n                    else\n                    {\n                        break;\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// This function saves the last log file parsed in the app config\n        /// &lt;/summary&gt;\n        static void SaveLastLogFileInConfig()\n        {\n            var configFile = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None);\n            var settings = configFile.AppSettings.Settings;\n            if (settings[\"LastLogFile\"] == null)\n            {\n                settings.Add(\"LastLogFile\", _lastLogFile);\n            }\n            else\n            {\n                settings[\"LastLogFile\"].Value = _lastLogFile;\n            }\n\n            configFile.Save(ConfigurationSaveMode.Modified);\n            ConfigurationManager.RefreshSection(configFile.AppSettings.SectionInformation.Name);\n        }\n\n        /// &lt;summary&gt;\n        /// This function downloads the blob and loads the data in it as a string\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"_blobItem\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        static string GetBlobData(CloudBlockBlob _blobItem)\n        {\n            MemoryStream ms = new MemoryStream();\n            _blobItem.DownloadToStream(ms);\n\n            byte[] buffer = new byte[ms.Length];\n            ms.Seek(0, SeekOrigin.Begin);\n            ms.Read(buffer, 0, (int)ms.Length);\n\n            string _logs = Encoding.UTF8.GetString(buffer);\n\n            ms.Dispose();\n\n            return _logs;\n        }\n\n        /// &lt;summary&gt;\n        /// This function parses a string and generates a list of substrings separated by the specified delimiter\n        /// The function ignores the delimiter insides quotes\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"_stringToParse\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"strDelimiter\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public static List&lt;string&gt; ParseDelimitedString(string _stringToParse, string strDelimiter)\n        {\n            List&lt;string&gt; _parsedStrings = new List&lt;string&gt;();\n            if (!String.IsNullOrEmpty(_stringToParse))\n            {\n                int j = 0;\n                int i = _stringToParse.IndexOf(strDelimiter);\n                while (i &gt;= 0)\n                {\n                    if (_stringToParse.Length &gt; 0)\n                    {\n                        // This piece of code is to check if the substring starts with a quote\n                        // If it does then the code finds the matching pair and looks the delimiter beyond that\n                        if (_stringToParse[j] == '\\\"')\n                        {\n                            i = _stringToParse.IndexOf(\"\\\"\", j + 1);\n                            if (i &gt; 0)\n                            {\n                                i = _stringToParse.IndexOf(strDelimiter, i);\n                            }\n                        }\n                    }\n\n                    string _str = _stringToParse.Substring(j, i - j);\n                    _parsedStrings.Add(_str);\n\n                    j = i + strDelimiter.Length;\n                    i = _stringToParse.IndexOf(strDelimiter, j);\n                }\n\n                _parsedStrings.Add(_stringToParse.Substring(j, _stringToParse.Length - j));\n            }\n\n            return _parsedStrings;\n        }\n\n        /// &lt;summary&gt;\n        /// This function parses a line of log\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"_logLineItems\"&gt;&lt;/param&gt;\n        static void ParseLogLine(List&lt;string&gt; _logLineItems)\n        {\n            try\n            {\n                // Check to make sure we are dealing 1.0 logs and that all the log items are parsed out properly\n                if ((_logLineItems[0] == \"1.0\") &amp;&amp; (_logLineItems.Count == 30))\n                {\n                    // Parsing out the necessary log items. We dont need all the items for this sample\n                    string _requestedObjectKey = _logLineItems[12];\n\n                    string _assetPrefix = \"\\\"/\" + _cloudStorage.Credentials.AccountName + \"/asset-\";\n                    int _assetIdIndex = _requestedObjectKey.IndexOf(_assetPrefix);\n                    if (_assetIdIndex == 0)\n                    {\n                        Console.WriteLine(\"Processing ObjectKey=\" + _requestedObjectKey);\n\n                        _assetIdIndex += _assetPrefix.Length;\n                        int j = _requestedObjectKey.IndexOf(\"/\", _assetIdIndex);\n                        if (j &lt; 0)\n                        {\n                            j = _requestedObjectKey.Length - 1;\n                        }\n                        string _assetId = _requestedObjectKey.Substring(_assetIdIndex, j - _assetIdIndex);\n                        _assetId = \"nb:cid:UUID:\" + _assetId;\n\n                        string _timeStamp = _logLineItems[1];\n                        string _operationType = _logLineItems[2];\n                        string _requestStatus = _logLineItems[3];\n                        string _authType = _logLineItems[7];\n\n                        string _requesterIpAddress = _logLineItems[15];\n\n                        Console.WriteLine(\"Processing Asset Id:\" + _assetId + \" TimeStamp:\" + _timeStamp + \" OperationType:\" + _operationType);\n\n                        switch (_operationType)\n                        {\n                            case \"CreateContainer\":\n                                _operationType = \"Create\";\n                                InsertAssetData(_assetId, _timeStamp, _operationType);\n                                break;\n\n                            case \"DeleteContainer\":\n                                _operationType = \"Delete\";\n                                InsertAssetData(_assetId, _timeStamp, _operationType);\n                                break;\n                        }\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message + ex.InnerException.StackTrace);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// This function adds an entry in the AssetAudit table\n        /// For Create operations, it checks if the entry already exists. This is to avoid duplicate entries as there are two sources of data\n        /// The Assets collection and the Storage logs may have slightly different timestamps due to clock skew between different Azure role instances\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"_assetId\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"_timeStamp\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"_operationType\"&gt;&lt;/param&gt;\n        static void InsertAssetData(string _assetId, string _timeStamp, string _operationType)\n        {\n            try\n            {\n                bool _insert = true;\n                if (_operationType == \"Create\")\n                {\n                    // If operationtype is Create, then check if an entry already exists for the given asset id\n\n                    TableQuery&lt;AssetAuditEntity&gt; query = new TableQuery&lt;AssetAuditEntity&gt;().Where(TableQuery.GenerateFilterCondition(\"PartitionKey\", QueryComparisons.Equal, _assetId));\n                    query.Take(1);\n\n                    TableQuerySegment&lt;AssetAuditEntity&gt; tqs = _assetAuditTable.ExecuteQuerySegmented(query, null);\n                    if ((tqs != null) &amp;&amp; (tqs.Results != null))\n                    {\n                        if (tqs.Results.Count &gt; 0)\n                        {\n                            if (tqs.Results[0].OperationType == \"Create\")\n                            {\n                                _insert = false;\n                            }\n                        }\n                    }\n                }\n\n                if (_insert)\n                {\n                    AssetAuditEntity _asset = new AssetAuditEntity();\n                    _asset.PartitionKey = _assetId;\n                    _asset.RowKey = _timeStamp;\n                    _asset.OperationType = _operationType;\n\n                    TableOperation op = TableOperation.Insert(_asset);\n                    _assetAuditTable.Execute(op);\n                }\n            }\n            catch (Exception ex)\n            {                \n                Console.WriteLine(ex.Message);                \n            }\n        }\n\n    }\n}</pre>\n上記のコードの関数の簡単な説明は次のとおりです。\n\n<strong>ProcessAssetData</strong>\n\nこの関数は、指定されたアカウント内のすべての資産をループMedia Servicesします。 既定では、Media Services Assets コレクションに 1,000 アセットが返されます。 関数では、Skip と Take を使用して、すべての資産が列挙されます (アカウントに 1,000 を超える資産がある場合)。\n\n<strong>ParseStorageLogs</strong>\n\nこの関数は <strong>、$logs/BLOB</strong> の下のすべての BLOB を列挙し、処理された BLOB を最後に処理されたログ ファイルとして保存します。これにより、コードが繰り返し実行された場合に再処理されません。\n\n<strong>SaveLastLogFileInConfig</strong>\n\nこの関数は、最後に処理されたログ ファイル名を App.Config保存して、プログラムを再実行した場合に取得できます。\n\n<strong>GetBlobData</strong>\n\nこの関数は、BLOB を Storageからダウンロードし、コンテンツを文字列に読み取ります。\n\n<strong>ParseDelimitedString</strong>\n\nこの関数は、指定された区切り記号に基づいて文字列を解析します。 解析されたデータは文字列コレクションとして返されます。\n\n<strong>ParseLogLine</strong>\n\nこの関数は、各ログ行を解析して、\"asset-\" で始まるコンテナーの CreateContainer 操作と DeleteContainer 操作を抽出します。\n\n<strong>InsertAssetData</strong>\n\nこの関数は、AssetAudit テーブルにエントリを追加します。\n\n&nbsp;\n<h2>資産監査データ</h2>\n上記のコードを実行すると、AssetAudit テーブルが作成されます。 使用したテスト アカウントに対するこのテーブルの内容のスクリーンショットを次に示します。 アセットの [作成] と [削除] の一致するペアが強調表示されています。 これらのエントリは、上記のコードStorage実行された場合にのみ、Media Servicesログからキャプチャできます。\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/07/2014-07-07_16h24_01.png\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"2014-07-07_16h24_01\" alt=\"2014-07-07_16h24_01\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2014-07-07_16h24_01_thumb.png\" width=\"644\" height=\"359\" border=\"0\" /></a>\n\nまた、 を使用<a href=\"https://office.microsoft.com/en-us/excel-help/introduction-to-microsoft-power-query-for-excel-HA104003940.aspx?CTT=5&amp;origin=HA104003813\">してExcel Power Query</a>のテーブル データを読み込み、Excel。 このExcel追加のフィルター処理を実行したり、ピボット テーブルに上記を読み込み、追加の分析を行います。 アプリを使用したことがないExcel Power Query、\"<a href=\"https://office.microsoft.com/en-us/excel/download-microsoft-power-query-for-excel-FX104018616.aspx\">Microsoft Power Query for Excel</a> のダウンロード\" Web ページからダウンロードできます。 インストールが完了したら、Excelを開始すると、\"POWER QUERY\" というタブが表示されます。 そのタブをクリックし、[From Other Sources]/(その他のソースから)ボタンをクリックすると、次のスクリーンショットに示すように、\"From Windows Azure Table Storage\" というメニュー項目が表示されます。\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/07/2014-07-06_00h21_51.png\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"2014-07-06_00h21_51\" alt=\"2014-07-06_00h21_51\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2014-07-06_00h21_51_thumb.png\" width=\"1028\" height=\"540\" border=\"0\" /></a>\n\n&nbsp;\n\n<strong>AssetAudit テーブルからデータをインポートするには</strong>、上記のメニュー項目を選択し、指示に従います。 右側の [ナビゲーター] ウィンドウにテーブルが読み込まれたら、 <strong>AssetAudit </strong>テーブルをダブルクリックすると、新しいウィンドウが開きます。 そのウィンドウのスクリーンショットは次のとおりです。\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/07/2014-07-07_16h35_30.png\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"2014-07-07_16h35_30\" alt=\"2014-07-07_16h35_30\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2014-07-07_16h35_30_thumb.png\" width=\"644\" height=\"462\" border=\"0\" /></a>\n\n[コンテンツ] というラベルの付いた列の横にあるボタンをクリックし、[OK] をクリックします。 その後、上部の [閉じるの適用 &amp; ] ボタンをクリックできます。 これにより、現在のウィンドウが閉じ、テーブル データが読み込Excel。 これで、次のExcelを使用して、適合する方法でデータを分析できます。\n\n&nbsp;\n<h2>考慮事項</h2>\n最後に、アプリケーションにこのサンプル コードを使用する場合は、次の点に注意してください\n<ul>\n <li>このブログで提供されるサンプル コードは、1 つのストレージ アカウント内のすべての資産を持つ Media Services アカウントを使用するように設計されています。ただし、複数のストレージ アカウントを使用するように簡単に調整できます。</li>\n <li>監査は、ログログに関連付けられている保持ポリシー Storageされます。</li>\n <li>デバッガーでサンプルを実行すると、App.Configファイルは、処理された最後のログ BLOB で更新されません。 これは、デバッガーの外部でサンプルを実行した場合にのみ発生します。</li>\n <li>例外はコンソールにのみ出力されます。 Azure テーブルまたはローカル ファイルに書き込み、エラーを確認できます (該当する場合)。</li>\n</ul>"
